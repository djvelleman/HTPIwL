<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.189">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>How To Prove It With Lean - 3&nbsp; Proofs</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Chap4.html" rel="next">
<link href="./IntroLean.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="HTPIwLstyles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Proofs</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">How To Prove It With Lean</a> 
        <div class="sidebar-tools-main">
    <a href="./How-To-Prove-It-With-Lean.pdf" title="Download PDF" class="sidebar-tool px-1"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Preface</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap1.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Sentential Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap2.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Quantificational Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./IntroLean.html" class="sidebar-item-text sidebar-link">Introduction to Lean</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap3.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Proofs</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap4.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Relations</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap5.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Functions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap6.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Mathematical Induction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap7.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Number Theory</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap8.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Infinite Sets</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Appendix.html" class="sidebar-item-text sidebar-link">Appendix</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">In This Chapter</h2>
   
  <ul class="collapse">
  <li><a href="#proofs-involving-negations-and-conditionals" id="toc-proofs-involving-negations-and-conditionals" class="nav-link active" data-scroll-target="#proofs-involving-negations-and-conditionals">3.1 &amp; 3.2. Proofs Involving Negations and Conditionals</a></li>
  <li><a href="#proofs-involving-quantifiers" id="toc-proofs-involving-quantifiers" class="nav-link" data-scroll-target="#proofs-involving-quantifiers">3.3. Proofs Involving Quantifiers</a></li>
  <li><a href="#proofs-involving-conjunctions-and-biconditionals" id="toc-proofs-involving-conjunctions-and-biconditionals" class="nav-link" data-scroll-target="#proofs-involving-conjunctions-and-biconditionals">3.4. Proofs Involving Conjunctions and Biconditionals</a></li>
  <li><a href="#proofs-involving-disjunctions" id="toc-proofs-involving-disjunctions" class="nav-link" data-scroll-target="#proofs-involving-disjunctions">3.5. Proofs Involving Disjunctions</a></li>
  <li><a href="#existence-and-uniqueness-proofs" id="toc-existence-and-uniqueness-proofs" class="nav-link" data-scroll-target="#existence-and-uniqueness-proofs">3.6. Existence and Uniqueness Proofs</a></li>
  <li><a href="#more-examples-of-proofs" id="toc-more-examples-of-proofs" class="nav-link" data-scroll-target="#more-examples-of-proofs">3.7. More Examples of Proofs</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<div class="hidden">
$$
\newcommand{\setmin}{\mathbin{\backslash}}
\newcommand{\symmdiff}{\bigtriangleup}
$$
</div>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Proofs</span></h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<section id="proofs-involving-negations-and-conditionals" class="level2">
<h2 class="anchored" data-anchor-id="proofs-involving-negations-and-conditionals">3.1 &amp; 3.2. Proofs Involving Negations and Conditionals</h2>
<p>Sections 3.1 and 3.2 of <em>How To Prove It</em> present strategies for dealing with givens and goals involving negations and conditionals. We restate those strategies here, and explain how to use them with Lean.</p>
<p>Section 3.1 gives two strategies for proving a goal of the form <code>P → Q</code> (<em>HTPI</em> pp.&nbsp;95, 96):</p>
<section id="to-prove-a-goal-of-the-form-p-q" class="level4">
<h4 class="anchored" data-anchor-id="to-prove-a-goal-of-the-form-p-q">To prove a goal of the form <code>P → Q</code>:</h4>
<ol type="1">
<li>Assume <code>P</code> is true and prove <code>Q</code>.</li>
<li>Assume <code>Q</code> is false and prove that <code>P</code> is false.</li>
</ol>
<p>We’ve already seen how to carry out both of these strategies in Lean. For the first strategy, use the <code>assume</code> tactic to introduce the assumption <code>P</code> and assign an identifier to it; Lean will automatically set <code>Q</code> as the goal. We can summarize the effect of using this strategy by showing how the tactic state changes if you use the tactic <code>assume h : P</code>:</p>
<div class="lftrt">
<div class="bef">
<div class="sourceCode" id="cb1"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span> ⋮</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>⊢ P → Q</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="aft">
<div class="sourceCode" id="cb2"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span> ⋮</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="in">h </span>: P</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>⊢ Q</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The second strategy is justified by the contrapositive law. In Lean, you can use the <code>contrapos</code> tactic to rewrite the goal as <code>¬Q → ¬P</code> and then use the tactic <code>assume h : ¬Q</code>. The net effect of these two tactics is:</p>
<div class="lftrt">
<div class="bef">
<div class="sourceCode" id="cb3"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span> ⋮</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>⊢ P → Q</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="aft">
<div class="sourceCode" id="cb4"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span> ⋮</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="in">h </span>: ¬Q</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>⊢ ¬P</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Section 3.2 gives two strategies for using givens of the form <code>P → Q</code>, with the second once again being a variation on the first based on the contrapositive law (<em>HTPI</em> p.&nbsp;108):</p>
</section>
<section id="to-use-a-given-of-the-form-p-q" class="level4">
<h4 class="anchored" data-anchor-id="to-use-a-given-of-the-form-p-q">To use a given of the form <code>P → Q</code>:</h4>
<ol type="1">
<li>If you are also given <code>P</code>, or you can prove that <code>P</code> is true, then you can use this given to conclude that <code>Q</code> is true.</li>
<li>If you are also given <code>¬Q</code>, or you can prove that <code>Q</code> is false, then you can use this given to conclude that <code>P</code> is false.</li>
</ol>
<p>The first strategy is the modus ponens rule of inference, and we saw in the last chapter that if you have <code>h1 : P → Q</code> and <code>h2 : P</code>, then <code>h1 h2</code> is a (term-mode) proof of <code>Q</code>; often we use this rule with the <code>have</code> or <code>show</code> tactic. For the second strategy, if you have <code>h1 : P → Q</code> and <code>h2 : ¬Q</code>, then the <code>contrapos at h1</code> tactic will change <code>h1</code> to <code>h1 : ¬Q → ¬P</code>, and then <code>h1 h2</code> will be a proof of <code>¬P</code>.</p>
<p>All of the strategies listed above for working with conditional statements as givens or goals were illustrated in examples in the last chapter.</p>
<p>Section 3.2 of <em>HTPI</em> offers two strategies for proving negative goals (<em>HTPI</em> pp.&nbsp;101, 102):</p>
</section>
<section id="to-prove-a-goal-of-the-form-p" class="level4">
<h4 class="anchored" data-anchor-id="to-prove-a-goal-of-the-form-p">To prove a goal of the form <code>¬P</code>:</h4>
<ol type="1">
<li>Reexpress the goal in some other form.</li>
<li>Use proof by contradiction: assume <code>P</code> is true and try to deduce a contradiction.</li>
</ol>
<p>For the first strategy, the tactics <code>demorgan</code>, <code>conditional</code>, <code>double_neg</code>, and <code>bicond_neg</code> may be useful, and we saw how those tactics work in the last chapter. But how do you write a proof by contradiction in Lean? The answer is to use a tactic called <code>by_contra</code>. If the goal is <code>¬P</code>, then the tactic <code>by_contra h</code> will introduce the assumption <code>h : P</code> and set the goal to be <code>False</code>, like this:</p>
<div class="lftrt">
<div class="bef">
<div class="sourceCode" id="cb5"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span> ⋮</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>⊢ ¬P</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="aft">
<div class="sourceCode" id="cb6"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span> ⋮</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="in">h </span>: P</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>⊢ False</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>In Lean, <code>False</code> represents a statement that is always false—that is, a contradiction, as that term is defined in Section 1.2 of <em>HTPI</em>. The <code>by_contra</code> tactic can actually be used even if the goal is not a negative statement. If the goal is a statement <code>P</code> that is not a negative statement, then <code>by_contra h</code> will initiate a proof by contradiction by introducing the assumption <code>h : ¬P</code> and setting the goal to be <code>False</code>.</p>
<p>You will usually complete a proof by contradiction by deducing two contradictory statements—say, <code>h1 : Q</code> and <code>h2 : ¬Q</code>. But how do you convince Lean that the proof is over? You must be able to prove the goal <code>False</code> from the two givens <code>h1</code> and <code>h2</code>. There are two ways to do this. The first is based on the fact that Lean treats a statement of the form <code>¬Q</code> as meaning the same thing as <code>Q → False</code>. This makes sense, because these statements are logically equivalent, as shown by the following truth table:</p>
<div style="margin: 0% 20%">
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;"><code>Q</code></th>
<th style="text-align: center;"><code>¬Q</code></th>
<th style="text-align: right;"><code>(Q</code></th>
<th style="text-align: center;"><code>→</code></th>
<th style="text-align: left;"><code>False)</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">F</td>
<td style="text-align: center;">T</td>
<td style="text-align: right;">F</td>
<td style="text-align: center;">T</td>
<td style="text-align: left;">&nbsp;&nbsp;<span class="excl">&nbsp;</span> F</td>
</tr>
<tr class="even">
<td style="text-align: center;">T</td>
<td style="text-align: center;">F</td>
<td style="text-align: right;">T</td>
<td style="text-align: center;">F</td>
<td style="text-align: left;">&nbsp;&nbsp;<span class="excl">&nbsp;</span> F</td>
</tr>
</tbody>
</table>
</div>
<p>Thinking of <code>h2 : ¬Q</code> as meaning <code>h2 : Q → False</code>, we can combine it with <code>h1 : Q</code> using modus ponens to deduce <code>False</code>. In other words, <code>h2 h1</code> is a proof of <code>False</code>.</p>
<p>But there is a second way of completing the proof that it is worthwhile to know about. From contradictory statements <code>h1 : Q</code> and <code>h2 : ¬Q</code> you can validly deduce <em>any</em> statement. This follows from the definition of a <em>valid argument</em> in Section 1.1 of <em>HTPI</em>. According to that definition, you can validly infer a conclusion <code>R</code> from premises <code>h1 : Q</code> and <code>h2 : ¬Q</code> if the premises cannot both be true without the conclusion also being true. In this case, that standard is met, for the simple reason that the premises cannot both be true! (This gives part of the answer to exercise 18 in Section 1.2 of <em>HTPI</em>.) Thus, Lean has a rule that allows you to prove any statement from contradictory premises. If you have <code>h1 : Q</code> and <code>h2 : ¬Q</code>, then Lean will recognize <code>absurd h1 h2</code> as a (term-mode) proof of <em>any</em> statement.</p>
<p>To summarize, if you have <code>h1 : Q</code> and <code>h2 : ¬Q</code>, then there are two ways to prove <code>False</code>. Lean will recognize <code>h2 h1</code> as a proof of <code>False</code>, and it will recognize <code>absurd h1 h2</code> as a proof of any statement, including <code>False</code>. Notice the difference in the order in which <code>h1</code> and <code>h2</code> are listed in these two proofs: In the first one, the negative statement <code>h2</code> must come first, just as the conditional statement must come first in an application of modus ponens. But in a proof using <code>absurd</code>, the negative statement must come second.</p>
<p>To illustrate proof by contradiction in Lean, let’s redo our first example from the last Chapter in a different way. That example was based on Example 3.2.4 in <em>HTPI</em>. We’ll begin with the same first two steps, introducing two assumptions.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb7"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_2_4_v2 (P Q R : <span class="kw">Prop</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    (h : P → (Q → R)) : ¬R → (P → ¬Q) := <span class="kw">by</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : ¬R</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : P</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb8"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="in">P Q R </span>: Prop</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="in">h </span>: P → Q → R</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬R</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: P</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>⊢ ¬Q</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now the goal is a negative statement, so we use the tactic <code>by_contra h4</code> to introduce the assumption <code>h4 : Q</code> and set the goal to be <code>False</code>:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb9"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_2_4_v2 (P Q R : <span class="kw">Prop</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    (h : P → (Q → R)) : ¬R → (P → ¬Q) := <span class="kw">by</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : ¬R</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : P</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_contra</span> h4</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb10"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="in">P Q R </span>: Prop</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="in">h </span>: P → Q → R</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬R</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: P</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: Q</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>⊢ False</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Using the givens <code>h</code>, <code>h3</code>, and <code>h4</code> we can deduce first <code>Q → R</code> and then <code>R</code> by two applications of modus ponens:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb11"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_2_4_v2 (P Q R : <span class="kw">Prop</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    (h : P → (Q → R)) : ¬R → (P → ¬Q) := <span class="kw">by</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : ¬R</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : P</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_contra</span> h4</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : Q → R := h h3</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : R := h5 h4</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb12"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="in">P Q R </span>: Prop</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="in">h </span>: P → Q → R</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬R</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: P</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: Q</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="in">h5 </span>: Q → R</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="in">h6 </span>: R</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>⊢ False</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now we have a contradiction: <code>h2 : ¬R</code> and <code>h6 : R</code>. To complete the proof, we deduce <code>False</code> from these two givens. Either <code>h2 h6</code> or <code>absurd h6 h2</code> would be accepted by Lean as a proof of <code>False</code>:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb13"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_2_4_v2 (P Q R : <span class="kw">Prop</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    (h : P → (Q → R)) : ¬R → (P → ¬Q) := <span class="kw">by</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : ¬R</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : P</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_contra</span> h4</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : Q → R := h h3</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : R := h5 h4</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> False <span class="kw">from</span> h2 h6</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb14"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ss">No</span><span class="in"> </span><span class="ss">goals</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Finally, we have two strategies for using a given that is a negative statement (<em>HTPI</em> pp.&nbsp;105, 108):</p>
</section>
<section id="to-use-a-given-of-the-form-p" class="level4">
<h4 class="anchored" data-anchor-id="to-use-a-given-of-the-form-p">To use a given of the form <code>¬P</code>:</h4>
<ol type="1">
<li>Reexpress the given in some other form.</li>
<li>If you are doing a proof by contradiction, you can achieve a contradiction by proving <code>P</code>, since that would contradict the given <code>¬P</code>.</li>
</ol>
<p>Of course, strategy 1 suggests the use of the <code>demorgan</code>, <code>conditional</code>, <code>double_neg</code>, and <code>bicond_neg</code> tactics, if they apply. For strategy 2, if you are doing a proof by contradiction and you have a given <code>h : ¬P</code>, then the tactic <code>contradict h</code> will set the goal to be <code>P</code>, which will complete the proof by contradicting <code>h</code>. In fact, this tactic can be used with any given; if you have a given <code>h : P</code>, where <code>P</code> is not a negative statement, then <code>contradict h</code> will set the goal to be <code>¬P</code>. You can also follow the word <code>contradict</code> with a proof that is more complicated than a single identifier. For example, if you have givens <code>h1 : P → ¬Q</code> and <code>h2 : P</code>, then <code>h1 h2</code> is a proof of <code>¬Q</code>, so the tactic <code>contradict h1 h2</code> will set the goal to be <code>Q</code>.</p>
<p>If you’re not doing a proof by contradiction, then the tactic <code>contradict h with h'</code> will first initiate a proof by contradiction by assuming the negation of the goal, giving that assumption the identifier <code>h'</code>, and then it will set the goal to be the negation of the statement proven by <code>h</code>. In other words, <code>contradict h with h'</code> is shorthand for <code>by_contra h'; contradict h</code>.</p>
<p>We can illustrate this with yet another way to write the proof from Example 3.2.4. Our first three steps will be the same as last time:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb15"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_2_4_v3 (P Q R : <span class="kw">Prop</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    (h : P → (Q → R)) : ¬R → (P → ¬Q) := <span class="kw">by</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : ¬R</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : P</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_contra</span> h4</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb16"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="in">P Q R </span>: Prop</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="in">h </span>: P → Q → R</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬R</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: P</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: Q</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>⊢ False</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Since we are now doing a proof by contradiction and the given <code>h2 : ¬R</code> is a negative statement, a likely way to proceed is to try to prove <code>R</code>, which would contradict <code>h2</code>. So we use the tactic <code>contradict h2</code>:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb17"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_2_4_v3 (P Q R : <span class="kw">Prop</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    (h : P → (Q → R)) : ¬R → (P → ¬Q) := <span class="kw">by</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : ¬R</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : P</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_contra</span> h4</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">contradict</span> h2</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb18"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="in">P Q R </span>: Prop</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="in">h </span>: P → Q → R</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬R</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: P</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: Q</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>⊢ R</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>As before, we can now prove <code>R</code> by combining <code>h</code>, <code>h3</code>, and <code>h4</code>. In fact, we could do it in one step: by modus ponens, <code>h h3</code> is a proof of <code>Q → R</code>, and therefore, by another application of modus ponens, <code>(h h3) h4</code> is a proof of <code>R</code>. The parentheses here are not necessary; Lean will interpret <code>h h3 h4</code> as <code>(h h3) h4</code>, so we can complete the proof like this:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb19"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_2_4_v3 (P Q R : <span class="kw">Prop</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    (h : P → (Q → R)) : ¬R → (P → ¬Q) := <span class="kw">by</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : ¬R</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : P</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_contra</span> h4</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">contradict</span> h2</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> R <span class="kw">from</span> h h3 h4</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb20"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ss">No</span><span class="in"> </span><span class="ss">goals</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>You could shorten this proof slightly by replacing the lines <code>by_contra h4</code> and <code>contradict h2</code> with the single line <code>contradict h2 with h4</code>.</p>
<p>There is one more idea that is introduced in Section 3.2 of <em>HTPI</em>. The last example in that section illustrates how you can sometimes use rules of inference to work backwards. Here’s a similar example in Lean:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb21"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_2_5</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    (U : <span class="kw">Type</span>) (A B C : Set U) (a : U)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    (h1 : a ∈ A) (h2 : a ∉ A \ B)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    (h3 : a ∈ B → a ∈ C) : a ∈ C := <span class="kw">by</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb22"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: a ∈ A</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: a ∉ A \ B</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: a ∈ B → a ∈ C</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>⊢ a ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The goal is <code>a ∈ C</code>, and the only given that even mentions <code>C</code> is <code>h3 : a ∈ B → a ∈ C</code>. If only we could prove <code>a ∈ B</code>, then we could apply <code>h3</code>, using modus ponens, to reach our goal. So it would make sense to work toward the goal of proving <code>a ∈ B</code>.</p>
<p>To get Lean to use this proof strategy, we use the tactic <code>apply h3 _</code>. The underscore here represents a blank to be filled in by Lean. You might think of this tactic as asking Lean the question: If we want <code>h3 _</code> to be a proof of the goal <code>a ∈ C</code>, what do we have to put in the blank? Lean is able to figure out that the answer is: a proof of <code>a ∈ B</code>. So it sets the goal to be <code>a ∈ B</code>, since a proof of that goal, when inserted into the blank in <code>h3 _</code>, would prove the original goal <code>a ∈ C</code>:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb23"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_2_5</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    (U : <span class="kw">Type</span>) (A B C : Set U) (a : U)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    (h1 : a ∈ A) (h2 : a ∉ A \ B)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    (h3 : a ∈ B → a ∈ C) : a ∈ C := <span class="kw">by</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> h3 _</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb24"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C</span>: Set U</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: a ∈ A</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: a ∉ A \ B</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: a ∈ B → a ∈ C</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>⊢ a ∈ B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Our situation now is very much like the one in the theorem <code>Example_3_2_5_Simple</code> in the previous chapter, and the rest of our proof will be similar to the proof there. The given <code>h2</code> is a negative statement (<code>a ∉ A \ B</code> is shorthand for <code>¬a ∈ A \ B</code>), so, as suggested by our first strategy for using negative givens, we reexpress it as an equivalent positive statement. Writing out the definition of set difference, <code>h2</code> means <code>¬(a ∈ A ∧ a ∉ B)</code>, and then one of De Morgan’s laws and a conditional law allow us to rewrite it first as <code>a ∉ A ∨ a ∈ B</code> and then as <code>a ∈ A → a ∈ B</code>. Of course, we have tactics to accomplish all of these reexpressions:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb25"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_2_5</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    (U : <span class="kw">Type</span>) (A B C : Set U) (a : U)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    (h1 : a ∈ A) (h2 : a ∉ A \ B)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    (h3 : a ∈ B → a ∈ C) : a ∈ C := <span class="kw">by</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> h3 _</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">demorgan</span> <span class="kw">at</span> h2; <span class="kw">conditional</span> <span class="kw">at</span> h2</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb26"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: a ∈ A</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: a ∈ A → a ∈ B</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: a ∈ B → a ∈ C</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>⊢ a ∈ B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>And now it is easy to complete the proof by applying modus ponens, using <code>h2</code> and <code>h1</code>:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb27"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_2_5</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    (U : <span class="kw">Type</span>) (A B C : Set U) (a : U)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    (h1 : a ∈ A) (h2 : a ∉ A \ B)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    (h3 : a ∈ B → a ∈ C) : a ∈ C := <span class="kw">by</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> h3 _</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">demorgan</span> <span class="kw">at</span> h2; <span class="kw">conditional</span> <span class="kw">at</span> h2</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a ∈ B <span class="kw">from</span> h2 h1</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb28"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ss">No</span><span class="in"> </span><span class="ss">goals</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>We will see many more uses of the <code>apply</code> tactic later in this book.</p>
<p>Sections 3.1 and 3.2 of <em>HTPI</em> contain several proofs that involve algebraic reasoning. Although one can do such proofs in Lean, it requires ideas that we are not ready to introduce yet. So for the moment we will stick to proofs involving only logic and set theory.</p>
</section>
<section id="exercises" class="level3">
<h3 class="anchored" data-anchor-id="exercises">Exercises</h3>
<p>Fill in proofs of the following theorems. All of them are based on exercises in <em>HTPI</em>.</p>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb29"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_2_1a (P Q R : <span class="kw">Prop</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    (h1 : P → Q) (h2 : Q → R) : P → R := <span class="kw">by</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb30"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_2_1b (P Q R : <span class="kw">Prop</span>)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ¬R → (P → ¬Q)) : P → (Q → R) := <span class="kw">by</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb31"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_2_2a (P Q R : <span class="kw">Prop</span>)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    (h1 : P → Q) (h2 : R → ¬Q) : P → ¬R := <span class="kw">by</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb32"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_2_2b (P Q : <span class="kw">Prop</span>)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    (h1 : P) : Q → ¬(Q → ¬P) := <span class="kw">by</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="proofs-involving-quantifiers" class="level2">
<h2 class="anchored" data-anchor-id="proofs-involving-quantifiers">3.3. Proofs Involving Quantifiers</h2>
<p>In the notation used in <em>HTPI</em>, if <span class="math inline">\(P(x)\)</span> is a statement about <span class="math inline">\(x\)</span>, then <span class="math inline">\(\forall x\, P(x)\)</span> means “for all <span class="math inline">\(x\)</span>, <span class="math inline">\(P(x)\)</span>,” and <span class="math inline">\(\exists x\, P(x)\)</span> means “there exists at least one <span class="math inline">\(x\)</span> such that <span class="math inline">\(P(x)\)</span>.” The letter <span class="math inline">\(P\)</span> here does not stand for a proposition; it is only when it is applied to some object <span class="math inline">\(x\)</span> that we get a proposition. We will say that <span class="math inline">\(P\)</span> is a <em>predicate</em>, and when we apply <span class="math inline">\(P\)</span> to an object <span class="math inline">\(x\)</span> we get the proposition <span class="math inline">\(P(x)\)</span>. You might want to think of the predicate <span class="math inline">\(P\)</span> as representing some property that an object might have, and the proposition <span class="math inline">\(P(x)\)</span> asserts that <span class="math inline">\(x\)</span> has that property.</p>
<p>To use a predicate in Lean, you must tell Lean the type of objects to which it applies. If <code>U</code> is a type, then <code>Pred U</code> is the type of predicates that apply to objects of type <code>U</code>. If <code>P</code> has type <code>Pred U</code> (that is, <code>P</code> is a predicate applying to objects of type <code>U</code>) and <code>x</code> has type <code>U</code>, then to apply <code>P</code> to <code>x</code> we just write <code>P x</code> (with a space but no parentheses). Thus, if we have <code>P : Pred U</code> and <code>x : U</code>, then <code>P x</code> is an expression of type <code>Prop</code>. That is, <code>P x</code> is a proposition, and its meaning is that <code>x</code> has the property represented by the predicate <code>P</code>.</p>
<p>There are a few differences between the way quantified statements are written in <em>HTPI</em> and the way they are written in Lean. First of all, when we apply a quantifier to a variable in Lean we will specify the type of the variable explicitly. Also, Lean requires that after specifying the variable and its type, you must put a comma before the proposition to which the quantifier is applied. Thus, if <code>P</code> has type <code>Pred U</code>, then to say that <code>P</code> holds for all objects of type <code>U</code> we would write <code>∀ (x : U), P x</code>. Similarly, <code>∃ (x : U), P x</code> is the proposition asserting that there exists at least one <code>x</code> of type <code>U</code> such that <code>P x</code>.</p>
<p>And there is one more important difference between the way quantified statements are written in <em>HTPI</em> and Lean. In <em>HTPI</em>, a quantifier is interpreted as applying to as little as possible. Thus, <span class="math inline">\(\forall x\, P(x) \wedge Q(x)\)</span> is interpreted as <span class="math inline">\((\forall x\, P(x)) \wedge Q(x)\)</span>; if you want the quantifier <span class="math inline">\(\forall x\)</span> to apply to the entire statement <span class="math inline">\(P(x) \wedge Q(x)\)</span> you must use parentheses and write <span class="math inline">\(\forall x(P(x) \wedge Q(x))\)</span>. The convention in Lean is exactly the opposite: a quantifier applies to as much as possible. Thus, Lean will interpret <code>∀ (x : U), P x ∧ Q x</code> as meaning <code>∀ (x : U), (P x ∧ Q x)</code>. If you want the quantifier to apply to only <code>P x</code>, then you must use parentheses and write <code>(∀ (x : U), P x) ∧ Q x</code>.</p>
<p>With this preparation, we are ready to consider how to write proofs involving quantifiers in Lean. The most common way to prove a goal of the form <code>∀ (x : U), P x</code> is to use the following strategy (<em>HTPI</em> p.&nbsp;114):</p>
<section id="to-prove-a-goal-of-the-form-x-u-p-x" class="level4">
<h4 class="anchored" data-anchor-id="to-prove-a-goal-of-the-form-x-u-p-x">To prove a goal of the form <code>∀ (x : U), P x</code>:</h4>
<div class="ind">
<p>Let <code>x</code> stand for an arbitrary object of type <code>U</code> and prove <code>P x</code>. If the letter <code>x</code> is already being used in the proof to stand for something, then you must choose an unused variable, say <code>y</code>, to stand for the arbitrary object, and prove <code>P y</code>.</p>
</div>
<p>To do this in Lean, you should use the tactic <code>fix x : U</code>, which tells Lean to treat <code>x</code> as standing for some fixed but arbitrary object of type <code>U</code>. This has the following effect on the tactic state:</p>
<div class="lftrt">
<div class="bef">
<div class="sourceCode" id="cb33"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span> ⋮</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>⊢ ∀ (x : U), P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="aft">
<div class="sourceCode" id="cb34"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span> ⋮</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>⊢ P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>To use a given of the form <code>∀ (x : U), P x</code>, we usually apply a rule of inference called <em>universal instantiation</em>, which is described by the following proof strategy (<em>HTPI</em> p.&nbsp;121):</p>
</section>
<section id="to-use-a-given-of-the-form-x-u-p-x" class="level4">
<h4 class="anchored" data-anchor-id="to-use-a-given-of-the-form-x-u-p-x">To use a given of the form <code>∀ (x : U), P x</code>:</h4>
<div class="ind">
<p>You may plug in any value of type <code>U</code>, say <code>a</code>, for <code>x</code> and use this given to conclude that <code>P a</code> is true.</p>
</div>
<p>This strategy says that if you have <code>h : ∀ (x : U), P x</code> and <code>a : U</code>, then you can infer <code>P a</code>. Indeed, in this situation Lean will recognize <code>h a</code> as a proof of <code>P a</code>. For example, you can write <code>have h' : P a := h a</code> in a Lean tactic-mode proof, and Lean will add <code>h' : P a</code> to the tactic state. Note that <code>a</code> here need not be simply a variable; it can be any expression denoting an object of type <code>U</code>.</p>
<p>Let’s try these strategies out in a Lean proof. In Lean, if you don’t want to give a theorem a name, you can simply call it an <code>example</code> rather than a <code>theorem</code>, and then there is no need to give it a name. In the following theorem, you can enter the symbol <code>∀</code> by typing <code>\forall</code> or <code>\all</code>, and you can enter <code>∃</code> by typing <code>\exists</code> or <code>\ex</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb35"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x : U), P x → ¬Q x)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ∀ (x : U), Q x) :</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    ¬∃ (x : U), P x := <span class="kw">by</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb36"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x → ¬Q x</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ (x : U), Q x</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>⊢ ¬∃ (x : U), P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>To use the givens <code>h1</code> and <code>h2</code>, we will probably want to use universal instantiation. But to do that we would need an object of type <code>U</code> to plug in for <code>x</code> in <code>h1</code> and <code>h2</code>, and there is no object of type <code>U</code> in the tactic state. So at this point, we can’t apply universal instantiation to <code>h1</code> and <code>h2</code>. We should watch for an object of type <code>U</code> to come up in the course of the proof, and consider applying universal instantiation if one does. Until then, we turn our attention to the goal.</p>
<p>The goal is a negative statement, so we begin by reexpressing it as an equivalent positive statement, using a quantifier negation law. The tactic <code>quant_neg</code> applies a quantifier negation law to rewrite the goal. As with the other tactics for applying logical equivalences, you can write <code>quant_neg at h</code> if you want to apply a quantifier negation law to a given <code>h</code>. The effect of the tactic can be summarized as follows:</p>
<div style="margin: 0% 10%">
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"><code>quant_neg</code> Tactic</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>¬∀ (x : U), P x</code></td>
<td style="text-align: center;">is changed to</td>
<td style="text-align: center;"><code>∃ (x : U), ¬P x</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>¬∃ (x : U), P x</code></td>
<td style="text-align: center;">is changed to</td>
<td style="text-align: center;"><code>∀ (x : U), ¬P x</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>∀ (x : U), P x</code></td>
<td style="text-align: center;">is changed to</td>
<td style="text-align: center;"><code>¬∃ (x : U), ¬P x</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>∃ (x : U), P x</code></td>
<td style="text-align: center;">is changed to</td>
<td style="text-align: center;"><code>¬∀ (x : U), ¬P x</code></td>
</tr>
</tbody>
</table>
</div>
<p>Using the <code>quant_neg</code> tactic leads to the following result.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb37"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x : U), P x → ¬Q x)</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ∀ (x : U), Q x) :</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    ¬∃ (x : U), P x := <span class="kw">by</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">quant_neg</span>     <span class="co">--Goal is now ∀ (x : U), ¬P x</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb38"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x → ¬Q x</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ (x : U), Q x</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>⊢ ∀ (x : U), ¬P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now the goal starts with <code>∀</code>, so we use the strategy above and introduce an arbitrary object of type <code>U</code>. Since the variable <code>x</code> occurs as a bound variable in several statements in this theorem, it might be best to use a different letter for the arbitrary object; this isn’t absolutely necessary, but it may help to avoid confusion. So our next tactic is <code>fix y : U</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb39"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x : U), P x → ¬Q x)</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ∀ (x : U), Q x) :</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    ¬∃ (x : U), P x := <span class="kw">by</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">quant_neg</span>     <span class="co">--Goal is now ∀ (x : U), ¬P x</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb40"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x → ¬Q x</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ (x : U), Q x</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>⊢ ¬P y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now we have an object of type <code>U</code> in the tactic state, namely, <code>y</code>. So let’s try applying universal instantiation to <code>h1</code> and <code>h2</code> and see if it helps.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb41"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x : U), P x → ¬Q x)</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ∀ (x : U), Q x) :</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    ¬∃ (x : U), P x := <span class="kw">by</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">quant_neg</span>     <span class="co">--Goal is now ∀ (x : U), ¬P x</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : P y → ¬Q y := h1 y</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : Q y := h2 y</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb42"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x → ¬Q x</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ (x : U), Q x</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: P y → ¬Q y</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: Q y</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>⊢ ¬P y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>We’re almost done, because the goal now follows easily from <code>h3</code> and <code>h4</code>. If we use the contrapositive law to rewrite <code>h3</code> as <code>Q y → ¬P y</code>, then we can apply modus ponens to the rewritten <code>h3</code> and <code>h4</code> to reach the goal:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb43"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x : U), P x → ¬Q x)</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ∀ (x : U), Q x) :</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    ¬∃ (x : U), P x := <span class="kw">by</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">quant_neg</span>     <span class="co">--Goal is now ∀ (x : U), ¬P x</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : P y → ¬Q y := h1 y</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : Q y := h2 y</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">contrapos</span> <span class="kw">at</span> h3  <span class="co">--Now h3 : Q y → ¬P y</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ¬P y <span class="kw">from</span> h3 h4</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb44"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="ss">No</span><span class="in"> </span><span class="ss">goals</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Our next example is a theorem of set theory. You already know how to type a few set theory symbols in Lean, but you’ll need a few more for our next example. Here’s a summary of the most important set theory symbols and how to type them in Lean.</p>
<div style="margin: 0% 10%">
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">Symbol</th>
<th style="text-align: center;">How To Type It</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>∈</code></td>
<td style="text-align: center;"><code>\in</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>∉</code></td>
<td style="text-align: center;"><code>\notin</code> or <code>\inn</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>⊆</code></td>
<td style="text-align: center;"><code>\sub</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>⊈</code></td>
<td style="text-align: center;"><code>\subn</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>=</code></td>
<td style="text-align: center;"><code>=</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>≠</code></td>
<td style="text-align: center;"><code>\ne</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>∪</code></td>
<td style="text-align: center;"><code>\union</code> or <code>\cup</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>∩</code></td>
<td style="text-align: center;"><code>\inter</code> or <code>\cap</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>\</code></td>
<td style="text-align: center;"><code>\\</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>△</code></td>
<td style="text-align: center;"><code>\bigtriangleup</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>∅</code></td>
<td style="text-align: center;"><code>\emptyset</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>𝒫</code></td>
<td style="text-align: center;"><code>\powerset</code></td>
</tr>
</tbody>
</table>
</div>
<p>With this preparation, we can turn to our next example.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb45"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>    (h2 : ∀ (x : U), x ∈ A → x ∉ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb46"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B ∪ C</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ x ∈ A, x ∉ B</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>⊢ A ⊆ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Notice that in the Infoview, Lean has written <code>h2</code> as <code>∀ x ∈ A, x ∉ B</code>, using a bounded quantifier. As explained in Section 2.2 of <em>HTPI</em> (see p.&nbsp;72), this is a shorter way of writing the statement <code>∀ (x : U), x ∈ A → x ∉ B</code>. We begin by using the <code>define</code> tactic to write out the definition of the goal.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb47"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    (h2 : ∀ (x : U), x ∈ A → x ∉ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>  <span class="co">--Goal : ∀ ⦃a : U⦄, a ∈ A → a ∈ C</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb48"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C</span>: Set U</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B ∪ C</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ x ∈ A, x ∉ B</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>⊢ ∀ ⦃a : U⦄,</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  a ∈ A → a ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Notice that Lean’s definition of the goal starts with <code>∀ ⦃a : U⦄</code>, not <code>∀ (a : U)</code>. Why did Lean use those funny double braces rather than parentheses? We’ll return to that question shortly. The difference doesn’t affect our next steps, which are to introduce an arbitrary object <code>y</code> of type <code>U</code> and assume <code>y ∈ A</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb49"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    (h2 : ∀ (x : U), x ∈ A → x ∉ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>  <span class="co">--Goal : ∀ ⦃a : U⦄, a ∈ A → a ∈ C</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ A</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb50"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B ∪ C</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ x ∈ A, x ∉ B</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: y ∈ A</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>⊢ y ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now we can combine <code>h2</code> and <code>h3</code> to conclude that <code>y ∉ B</code>. Since we have <code>y : U</code>, by universal instantiation, <code>h2 y</code> is a proof of <code>y ∈ A → y ∉ B</code>, and therefore by modus ponens, <code>h2 y h3</code> is a proof of <code>y ∉ B</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb51"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    (h2 : ∀ (x : U), x ∈ A → x ∉ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>  <span class="co">--Goal : ∀ ⦃a : U⦄, a ∈ A → a ∈ C</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ A</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : y ∉ B := h2 y h3</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb52"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B ∪ C</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ x ∈ A, x ∉ B</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: y ∈ A</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: y ∉ B</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>⊢ y ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>We should be able to use similar reasoning to combine <code>h1</code> and <code>h3</code>, if we first write out the definition of <code>h1</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb53"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>    (h2 : ∀ (x : U), x ∈ A → x ∉ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>  <span class="co">--Goal : ∀ ⦃a : U⦄, a ∈ A → a ∈ C</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ A</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : y ∉ B := h2 y h3</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1  <span class="co">--h1 : ∀ ⦃a : U⦄, a ∈ A → a ∈ B ∪ C</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb54"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ ⦃a : U⦄,</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  a ∈ A → a ∈ B ∪ C</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ x ∈ A, x ∉ B</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: y ∈ A</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: y ∉ B</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>⊢ y ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Once again, Lean has used double braces to define <code>h1</code>, and now we are ready to explain what they mean. If the definition had been <code>h1 : ∀ (a : U), a ∈ A → a ∈ B ∪ C</code>, then exactly as in the previous step, <code>h1 y h3</code> would be a proof of <code>y ∈ B ∪ C</code>. The use of double braces in the definition <code>h1 : ∀ ⦃a : U⦄, a ∈ A → a ∈ B ∪ C</code> means that you don’t need to tell Lean that <code>y</code> is being plugged in for <code>a</code> in the universal instantiation step; Lean will figure that out on its own. Thus, you can just write <code>h1 h3</code> as a proof of <code>y ∈ B ∪ C</code>. Indeed, if you write <code>h1 y h3</code> then you will get an error message, because Lean expects <em>not</em> to be told what to plug in for <code>a</code>. You might think of the definition of <code>h1</code> as meaning <code>h1 : _ ∈ A → _ ∈ B ∪ C</code>, where the blanks can be filled in with anything of type <code>U</code> (with the same thing being put in both blanks). When you ask Lean to apply modus ponens by combining this statement with <code>h3 : y ∈ A</code>, Lean figures out that in order for modus ponens to apply, the blanks must be filled in with <code>y</code>.</p>
<p>In this situation, the <code>a</code> in <code>h1</code> is called an <em>implicit argument</em>. What this means is that, when <code>h1</code> is applied to make an inference in a proof, the value to be assigned to <code>a</code> is not specified explicitly; rather, the value is inferred by Lean. We will see many more examples of implicit arguments later in this book. In fact, there are two slightly different kinds of implicit arguments in Lean. One kind is indicated using the double braces <code>⦃ ⦄</code> used in this example, and the other is indicated using curly braces, <code>{ }</code>. The difference between these two kinds of implicit arguments won’t be important in this book; all that will matter to us is that if you see either <code>∀ ⦃a : U⦄</code> or <code>∀ {a : U}</code> rather than <code>∀ (a : U)</code>, then you must remember that <code>a</code> is an implicit argument.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb55"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>    (h2 : ∀ (x : U), x ∈ A → x ∉ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>  <span class="co">--Goal : ∀ ⦃a : U⦄, a ∈ A → a ∈ C</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ A</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : y ∉ B := h2 y h3</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1  <span class="co">--h1 : ∀ ⦃a : U⦄, a ∈ A → a ∈ B ∪ C</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : y ∈ B ∪ C := h1 h3</span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb56"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ ⦃a : U⦄,</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  a ∈ A → a ∈ B ∪ C</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ x ∈ A, x ∉ B</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: y ∈ A</span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: y ∉ B</span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a><span class="in">h5 </span>: y ∈ B ∪ C</span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a>⊢ y ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>If Lean was able to figure out that <code>y</code> should be plugged in for <code>a</code> in <code>h1</code> in this step, couldn’t it have figured out that <code>y</code> should be plugged in for <code>x</code> in <code>h2</code> in the previous <code>have</code> step? The answer is yes. Of course, in <code>h2</code>, <code>x</code> was not an implicit argument, so Lean wouldn’t <em>automatically</em> figure out what to plug in for <code>x</code>. But we could have asked it to figure it out by writing the proof in the previous step as <code>h2 _ h3</code> rather than <code>h2 y h3</code>. In a term-mode proof, an underscore represents a blank to be filled in by Lean. Try changing the earlier step of the proof to <code>have h4 : y ∉ B := h2 _ h3</code> and you will see that Lean will accept it. Of course, in this case this doesn’t save us any typing, but in some situations it is useful to let Lean figure out some part of a proof.</p>
<p>Lean’s ability to fill in blanks in term-mode proofs is limited. For example, if you try changing the previous step to <code>have h4 : y ∉ B := h2 y _</code>, you’ll get a red squiggle under the blank, and the error message in the Infoview pane will say <code>don't know how to synthesize placeholder</code>. In other words, Lean was unable to figure out how to fill in the blank in this case. In future proofs you might try replacing some expressions with blanks to get a feel for what Lean can and cannot figure out for itself.</p>
<p>Continuing with the proof, we see that we’re almost done, because we can combine <code>h4</code> and <code>h5</code> to reach our goal. To see how, we first write out the definition of <code>h5</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb57"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>    (h2 : ∀ (x : U), x ∈ A → x ∉ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>  <span class="co">--Goal : ∀ ⦃a : U⦄, a ∈ A → a ∈ C</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ A</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : y ∉ B := h2 y h3</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1  <span class="co">--h1 : ∀ ⦃a : U⦄, a ∈ A → a ∈ B ∪ C</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : y ∈ B ∪ C := h1 h3</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h5  <span class="co">--h5 : y ∈ B ∨ y ∈ C</span></span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb58"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ ⦃a : U⦄,</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  a ∈ A → a ∈ B ∪ C</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ x ∈ A, x ∉ B</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: y ∈ A</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: y ∉ B</span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a><span class="in">h5 </span>: y ∈ B ∨ y ∈ C</span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>⊢ y ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>A conditional law will convert <code>h5</code> to <code>y ∉ B → y ∈ C</code>, and then modus ponens with <code>h4</code> will complete the proof.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb59"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>    (h2 : ∀ (x : U), x ∈ A → x ∉ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>  <span class="co">--Goal : ∀ ⦃a : U⦄, a ∈ A → a ∈ C</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ A</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : y ∉ B := h2 y h3</span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1  <span class="co">--h1 : ∀ ⦃a : U⦄, a ∈ A → a ∈ B ∪ C</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : y ∈ B ∪ C := h1 h3</span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h5  <span class="co">--h5 : y ∈ B ∨ y ∈ C</span></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">conditional</span> <span class="kw">at</span> h5  <span class="co">--h5 : y ∉ B → y ∈ C</span></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> y ∈ C <span class="kw">from</span> h5 h4</span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb60"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="ss">No</span><span class="in"> </span><span class="ss">goals</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Next we turn to strategies for working with existential quantifiers (<em>HTPI</em> p.&nbsp;118).</p>
</section>
<section id="to-prove-a-goal-of-the-form-x-u-p-x-1" class="level4">
<h4 class="anchored" data-anchor-id="to-prove-a-goal-of-the-form-x-u-p-x-1">To prove a goal of the form <code>∃ (x : U), P x</code>:</h4>
<div class="ind">
<p>Find a value of <code>x</code>, say <code>a</code>, for which you think <code>P a</code> is true, and prove <code>P a</code>.</p>
</div>
<p>This strategy is based on the fact that if you have <code>a : U</code> and <code>h : P a</code>, then you can infer <code>∃ (x : U), P x</code>. Indeed, in this situation the expression <code>Exists.intro a h</code> is a Lean term-mode proof of <code>∃ (x : U), P x</code>. The name <code>Exists.intro</code> indicates that this is a rule for introducing an existential quantifier.</p>
<p>Note that, as with the universal instantiation rule, <code>a</code> here can be any expression denoting an object of type <code>U</code>; it need not be simply a variable. For example, if <code>A</code> and <code>B</code> have type <code>Set U</code>, <code>F</code> has type <code>Set (Set U)</code>, and you have a given <code>h : A ∪ B ∈ F</code>, then <code>Exists.intro (A ∪ B) h</code> is a proof of <code>∃ (x : Set U), x ∈ F</code>.</p>
<p>As suggested by the strategy above, we will often want to use the <code>Exists.intro</code> rule in situations in which our goal is <code>∃ (x : U), P x</code> and we have an object <code>a</code> of type <code>U</code> that we think makes <code>P a</code> true, but we don’t yet have a proof of <code>P a</code>. In that situation we can use the tactic <code>apply Exists.intro a _</code>. Recall that the <code>apply</code> tactic asks Lean to figure out what to put in the blank to turn <code>Exists.intro a _</code> into a proof of the goal. Lean will figure out that what needs to go in the blank is a proof of <code>P a</code>, so it sets <code>P a</code> to be the goal. In other words, the tactic <code>apply Exists.intro a _</code> has the following effect on the tactic state:</p>
<div class="lftrt">
<div class="bef">
<div class="sourceCode" id="cb61"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span> ⋮</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>⊢ ∃ (x : U), P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="aft">
<div class="sourceCode" id="cb62"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span> ⋮</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>⊢ P a</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Our strategy for using an existential given is a rule that is called <em>existential instantiation</em> in <em>HTPI</em> (<em>HTPI</em> p.&nbsp;120):</p>
</section>
<section id="to-use-a-given-of-the-form-x-u-p-x-1" class="level4">
<h4 class="anchored" data-anchor-id="to-use-a-given-of-the-form-x-u-p-x-1">To use a given of the form <code>∃ (x : U), P x</code>:</h4>
<div class="ind">
<p>Introduce a new variable, say <code>u</code>, into the proof to stand for an object of type <code>U</code> for which <code>P u</code> is true.</p>
</div>
<p>Suppose that, in a Lean proof, you have <code>h : ∃ (x : U), P x</code>. To apply the existential instantiation rule, you would use the tactic <code>obtain (u : U) (h' : P u) from h</code>. This tactic introduces into the tactic state both a new variable <code>u</code> of type <code>U</code> and also the identifier <code>h'</code> for the new given <code>P u</code>. Note that <code>h</code> can be any proof of a statement of the form <code>∃ (x : U), P x</code>; it need not be just a single identifier.</p>
<p>Often, if your goal is an existential statement <code>∃ (x : U), P x</code>, you won’t be able to use the strategy above for existential goals right away, because you won’t know what object <code>a</code> to use in the tactic <code>apply Exists.intro a _</code>. You may have to wait until a likely candidate for <code>a</code> pops up in the course of the proof. On the other hand, it is usually best to use the <code>obtain</code> tactic right away if you have an existential given. This is illustrated in our next example.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb63"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>    ∃ (x : U), ¬P x := <span class="kw">by</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb64"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), ∃ (y : U),</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  P x → ¬Q y</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (x : U), ∀ (y : U),</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  P x → Q y</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>⊢ ∃ (x : U), ¬P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The goal is the existential statement <code>∃ (x : U), ¬P x</code>, and our strategy for existential goals says that we should try to find an object <code>a</code> of type <code>U</code> that we think would make the statement <code>¬P a</code> true. But we don’t have any objects of type <code>U</code> in the tactic state, so it looks like we can’t use that strategy yet. Similarly, we can’t use the given <code>h1</code> yet, since we have nothing to plug in for <code>x</code> in <code>h1</code>. However, <code>h2</code> is an existential given, and we can use it right away.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb65"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>    ∃ (x : U), ¬P x := <span class="kw">by</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : U)</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>    (h3 : ∀ (y : U), P a → Q y) <span class="kw">from</span> h2</span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb66"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), ∃ (y : U),</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  P x → ¬Q y</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (x : U), ∀ (y : U),</span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  P x → Q y</span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: ∀ (y : U), P a → Q y</span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>⊢ ∃ (x : U), ¬P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now that we have <code>a : U</code>, we can apply universal instantiation to <code>h1</code>, plugging in <code>a</code> for <code>x</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb67"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>    ∃ (x : U), ¬P x := <span class="kw">by</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : U)</span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>    (h3 : ∀ (y : U), P a → Q y) <span class="kw">from</span> h2</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : ∃ (y : U), P a → ¬ Q y := h1 a</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb68"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), ∃ (y : U),</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  P x → ¬Q y</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (x : U), ∀ (y : U),</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  P x → Q y</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: ∀ (y : U), P a → Q y</span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: ∃ (y : U), P a → ¬Q y</span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>⊢ ∃ (x : U), ¬P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>By the way, this is another case in which Lean could have figured out a part of the proof on its own. Try changing <code>h1 a</code> in the last step to <code>h1 _</code>, and you’ll see that Lean will be able to figure out how to fill in the blank.</p>
<p>Our new given <code>h4</code> is another existential statement, so again we use it right away to introduce another object of type <code>U</code>. Since this object might not be the same as <code>a</code>, we must give it a different name. (Indeed, if you try to use the name <code>a</code> again, Lean will give you an error message.)</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb69"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>    ∃ (x : U), ¬P x := <span class="kw">by</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : U)</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>    (h3 : ∀ (y : U), P a → Q y) <span class="kw">from</span> h2</span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : ∃ (y : U), P a → ¬ Q y := h1 a</span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (b : U) (h5 : P a → ¬ Q b) <span class="kw">from</span> h4</span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb70"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), ∃ (y : U),</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  P x → ¬Q y</span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (x : U), ∀ (y : U),</span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  P x → Q y</span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: ∀ (y : U), P a → Q y</span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: ∃ (y : U), P a → ¬Q y</span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a><span class="in">b </span>: U</span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a><span class="in">h5 </span>: P a → ¬Q b</span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a>⊢ ∃ (x : U), ¬P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>We have not yet used <code>h3</code>. We could plug in either <code>a</code> or <code>b</code> for <code>y</code> in <code>h3</code>, but a little thought should show you that plugging in <code>b</code> is more useful.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb71"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>    ∃ (x : U), ¬P x := <span class="kw">by</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : U)</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>    (h3 : ∀ (y : U), P a → Q y) <span class="kw">from</span> h2</span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : ∃ (y : U), P a → ¬ Q y := h1 a</span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (b : U) (h5 : P a → ¬ Q b) <span class="kw">from</span> h4</span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : P a → Q b := h3 b</span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb72"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), ∃ (y : U),</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  P x → ¬Q y</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (x : U), ∀ (y : U),</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  P x → Q y</span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: ∀ (y : U), P a → Q y</span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: ∃ (y : U), P a → ¬Q y</span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a><span class="in">b </span>: U</span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a><span class="in">h5 </span>: P a → ¬Q b</span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a><span class="in">h6 </span>: P a → Q b</span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a>⊢ ∃ (x : U), ¬P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now look at <code>h5</code> and <code>h6</code>. They show that <code>P a</code> leads to contradictory conclusions, <code>¬Q b</code> and <code>Q b</code>. This means that <code>P a</code> must be false. We finally know what value of <code>x</code> to use to prove the goal.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb73"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>    ∃ (x : U), ¬P x := <span class="kw">by</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : U)</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>    (h3 : ∀ (y : U), P a → Q y) <span class="kw">from</span> h2</span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : ∃ (y : U), P a → ¬ Q y := h1 a</span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (b : U) (h5 : P a → ¬ Q b) <span class="kw">from</span> h4</span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : P a → Q b := h3 b</span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro a _</span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb74"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), ∃ (y : U),</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  P x → ¬Q y</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (x : U), ∀ (y : U),</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  P x → Q y</span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: ∀ (y : U), P a → Q y</span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: ∃ (y : U), P a → ¬Q y</span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a><span class="in">b </span>: U</span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a><span class="in">h5 </span>: P a → ¬Q b</span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a><span class="in">h6 </span>: P a → Q b</span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a>⊢ ¬P a</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Since the goal is now a negative statement that cannot be reexpressed as a positive statement, we use proof by contradiction.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb75"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>    ∃ (x : U), ¬P x := <span class="kw">by</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : U)</span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>    (h3 : ∀ (y : U), P a → Q y) <span class="kw">from</span> h2</span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : ∃ (y : U), P a → ¬ Q y := h1 a</span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (b : U) (h5 : P a → ¬ Q b) <span class="kw">from</span> h4</span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : P a → Q b := h3 b</span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro a _</span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_contra</span> h7</span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb76"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), ∃ (y : U),</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  P x → ¬Q y</span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (x : U), ∀ (y : U),</span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  P x → Q y</span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: ∀ (y : U), P a → Q y</span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: ∃ (y : U), P a → ¬Q y</span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a><span class="in">b </span>: U</span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a><span class="in">h5 </span>: P a → ¬Q b</span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a><span class="in">h6 </span>: P a → Q b</span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true" tabindex="-1"></a><span class="in">h7 </span>: P a</span>
<span id="cb76-14"><a href="#cb76-14" aria-hidden="true" tabindex="-1"></a>⊢ False</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now <code>h5 h7</code> is a proof of <code>¬Q b</code> and <code>h6 h7</code> is a proof of <code>Q b</code>, so <code>h5 h7 (h6 h7)</code> is a proof of <code>False</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb77"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>    ∃ (x : U), ¬P x := <span class="kw">by</span></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : U)</span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>    (h3 : ∀ (y : U), P a → Q y) <span class="kw">from</span> h2</span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : ∃ (y : U), P a → ¬ Q y := h1 a</span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (b : U) (h5 : P a → ¬ Q b) <span class="kw">from</span> h4</span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : P a → Q b := h3 b</span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro a _</span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_contra</span> h7</span>
<span id="cb77-12"><a href="#cb77-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> False <span class="kw">from</span> h5 h7 (h6 h7)</span>
<span id="cb77-13"><a href="#cb77-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb78"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="ss">No</span><span class="in"> </span><span class="ss">goals</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>We conclude this section with the theorem from Example 3.3.5 in <em>HTPI</em>. That theorem concerns a union of a family of sets. In <em>HTPI</em>, such a union is written using a large union symbol, <span class="math inline">\(\bigcup\)</span>. Lean uses the symbol <code>⋃₀</code>, which is entered by typing <code>\U0</code> (that is, backslash–capital U–zero). For an intersection of a family of sets, Lean uses <code>⋂₀</code>, typed as <code>\I0</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb79"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_3_5 (U : <span class="kw">Type</span>) (B : Set U)</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>    (F : Set (Set U)) : ⋃₀ F ⊆ B → F ⊆ 𝒫 B := <span class="kw">by</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb80"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="in">B </span>: Set U</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="in">F </span>: Set (Set U)</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>⊢ ⋃₀ F ⊆ B → F ⊆ 𝒫 B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Note that <code>F</code> has type <code>Set (Set U)</code>, which means that it is a set whose elements are sets of objects of type <code>U</code>. Since the goal is a conditional statement, we assume the antecedent and set the consequent as our goal. We’ll also write out the definition of the new goal.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb81"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_3_5 (U : <span class="kw">Type</span>) (B : Set U)</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>    (F : Set (Set U)) : ⋃₀ F ⊆ B → F ⊆ 𝒫 B := <span class="kw">by</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : ⋃₀ F ⊆ B</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb82"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="in">B </span>: Set U</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a><span class="in">F </span>: Set (Set U)</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ⋃₀ F ⊆ B</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>⊢ ∀ ⦃a : Set U⦄,</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  a ∈ F → a ∈ 𝒫 B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Based on the form of the goal, we introduce an arbitrary object <code>x</code> of type <code>Set U</code> and assume <code>x ∈ F</code>. The new goal will be <code>x ∈ 𝒫 B</code>. The <code>define</code> tactic works out that this means <code>x ⊆ B</code>, which can be further expanded to <code>∀ ⦃a : U⦄, a ∈ x → a ∈ B</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb83"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_3_5 (U : <span class="kw">Type</span>) (B : Set U)</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>    (F : Set (Set U)) : ⋃₀ F ⊆ B → F ⊆ 𝒫 B := <span class="kw">by</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : ⋃₀ F ⊆ B</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : Set U</span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : x ∈ F</span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb84"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a><span class="in">B </span>: Set U</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a><span class="in">F </span>: Set (Set U)</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ⋃₀ F ⊆ B</span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: Set U</span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: x ∈ F</span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a>⊢ ∀ ⦃a : U⦄,</span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  a ∈ x → a ∈ B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Once again the form of the goal dictates our next steps: introduce an arbitrary <code>y</code> of type <code>U</code> and assume <code>y ∈ x</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb85"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_3_5 (U : <span class="kw">Type</span>) (B : Set U)</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>    (F : Set (Set U)) : ⋃₀ F ⊆ B → F ⊆ 𝒫 B := <span class="kw">by</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : ⋃₀ F ⊆ B</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : Set U</span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : x ∈ F</span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ x</span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb86"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a><span class="in">B </span>: Set U</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a><span class="in">F </span>: Set (Set U)</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ⋃₀ F ⊆ B</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: Set U</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: x ∈ F</span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: y ∈ x</span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a>⊢ y ∈ B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The goal can be analyzed no further, so we turn to the givens. We haven’t used <code>h1</code> yet. To see how to use it, we write out its definition.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb87"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_3_5 (U : <span class="kw">Type</span>) (B : Set U)</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>    (F : Set (Set U)) : ⋃₀ F ⊆ B → F ⊆ 𝒫 B := <span class="kw">by</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : ⋃₀ F ⊆ B</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : Set U</span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : x ∈ F</span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ x</span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb88"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="in">B </span>: Set U</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a><span class="in">F </span>: Set (Set U)</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ ⦃a : U⦄,</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  a ∈ ⋃₀ F → a ∈ B</span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: Set U</span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: x ∈ F</span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: y ∈ x</span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>⊢ y ∈ B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now we see that we can try to use <code>h1</code> to reach our goal. Indeed, <code>h1 _</code> would be a proof of the goal if we could fill in the blank with a proof of <code>y ∈ ∪₀F</code>. So we use the <code>apply h1 _</code> tactic.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb89"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_3_5 (U : <span class="kw">Type</span>) (B : Set U)</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>    (F : Set (Set U)) : ⋃₀ F ⊆ B → F ⊆ 𝒫 B := <span class="kw">by</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : ⋃₀ F ⊆ B</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : Set U</span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : x ∈ F</span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ x</span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> h1 _</span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb90"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a><span class="in">B </span>: Set U</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a><span class="in">F </span>: Set (Set U)</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ ⦃a : U⦄,</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  a ∈ ⋃₀ F → a ∈ B</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: Set U</span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: x ∈ F</span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: y ∈ x</span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a>⊢ y ∈ ⋃₀ F</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Once again we have a goal that can be analyzed by using the <code>define</code> tactic.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb91"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_3_5 (U : <span class="kw">Type</span>) (B : Set U)</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>    (F : Set (Set U)) : ⋃₀ F ⊆ B → F ⊆ 𝒫 B := <span class="kw">by</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : ⋃₀ F ⊆ B</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : Set U</span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : x ∈ F</span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ x</span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> h1 _</span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb92"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a><span class="in">B </span>: Set U</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a><span class="in">F </span>: Set (Set U)</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ ⦃a : U⦄,</span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  a ∈ ⋃₀ F → a ∈ B</span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: Set U</span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: x ∈ F</span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: y ∈ x</span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true" tabindex="-1"></a>⊢ ∃ t ∈ F, y ∈ t</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Our goal now is <code>∃ (t : Set U), t ∈ F ∧ y ∈ t</code>, although once again Lean has used a bounded quantifier to write this in a shorter form. So we look for a value of <code>t</code> that will make the statement <code>t ∈ F ∧ y ∈ t</code> true. The givens <code>h2</code> and <code>h3</code> tell us that <code>x</code> is such a value, so as described earlier our next tactic should be <code>apply Exists.intro x _</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb93"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_3_5 (U : <span class="kw">Type</span>) (B : Set U)</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>    (F : Set (Set U)) : ⋃₀ F ⊆ B → F ⊆ 𝒫 B := <span class="kw">by</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : ⋃₀ F ⊆ B</span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : Set U</span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : x ∈ F</span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ x</span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> h1 _</span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb93-13"><a href="#cb93-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro x _</span>
<span id="cb93-14"><a href="#cb93-14" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb94"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a><span class="in">B </span>: Set U</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a><span class="in">F </span>: Set (Set U)</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ ⦃a : U⦄,</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  a ∈ ⋃₀ F → a ∈ B</span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: Set U</span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: x ∈ F</span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a><span class="in">y </span>: U</span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: y ∈ x</span>
<span id="cb94-10"><a href="#cb94-10" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ F ∧ y ∈ x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Clearly the goal now follows from <code>h2</code> and <code>h3</code>, but how do we write the proof in Lean? Since we need to introduce the “and” symbol <code>∧</code>, you shouldn’t be surprised to learn that the rule we need is called <code>And.intro</code>. Proof strategies for statements involving “and” will be the subject of the next section.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb95"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_3_5 (U : <span class="kw">Type</span>) (B : Set U)</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>    (F : Set (Set U)) : ⋃₀ F ⊆ B → F ⊆ 𝒫 B := <span class="kw">by</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : ⋃₀ F ⊆ B</span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : Set U</span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : x ∈ F</span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb95-9"><a href="#cb95-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : y ∈ x</span>
<span id="cb95-10"><a href="#cb95-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb95-11"><a href="#cb95-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> h1 _</span>
<span id="cb95-12"><a href="#cb95-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb95-13"><a href="#cb95-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro x _</span>
<span id="cb95-14"><a href="#cb95-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> x ∈ F ∧ y ∈ x <span class="kw">from</span> And.intro h2 h3</span>
<span id="cb95-15"><a href="#cb95-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb96"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="ss">No</span><span class="in"> </span><span class="ss">goals</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>You might want to compare the Lean proof above to the way the proof was written in <em>HTPI</em>. Here are the theorem and proof from <em>HTPI</em> (<em>HTPI</em> p.&nbsp;125):</p>
<div class="thm">
<p>Suppose <span class="math inline">\(B\)</span> is a set and <span class="math inline">\(\mathcal{F}\)</span> is a family of sets. If <span class="math inline">\(\bigcup\mathcal{F} \subseteq B\)</span> then <span class="math inline">\(\mathcal{F} \subseteq \mathscr{P}(B)\)</span>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Suppose <span class="math inline">\(\bigcup \mathcal{F} \subseteq B\)</span>. Let <span class="math inline">\(x\)</span> be an arbitrary element of <span class="math inline">\(\mathcal{F}\)</span>. Let <span class="math inline">\(y\)</span> be an arbitrary element of <span class="math inline">\(x\)</span>. Since <span class="math inline">\(y \in x\)</span> and <span class="math inline">\(x \in \mathcal{F}\)</span>, by the definition of <span class="math inline">\(\bigcup \mathcal{F}\)</span>, <span class="math inline">\(y \in \bigcup \mathcal{F}\)</span>. But then since <span class="math inline">\(\bigcup \mathcal{F} \subseteq B\)</span>, <span class="math inline">\(y \in B\)</span>. Since <span class="math inline">\(y\)</span> was an arbitrary element of <span class="math inline">\(x\)</span>, we can conclude that <span class="math inline">\(x \subseteq B\)</span>, so <span class="math inline">\(x \in \mathscr{P}(B)\)</span>. But <span class="math inline">\(x\)</span> was an arbitrary element of <span class="math inline">\(\mathcal{F}\)</span>, so this shows that <span class="math inline">\(\mathcal{F} \subseteq \mathscr{P}(B)\)</span>, as required. <span class="excl">&nbsp;□</span></p>
</div>
</section>
<section id="exercises-1" class="level3">
<h3 class="anchored" data-anchor-id="exercises-1">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb97"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_3_1</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>    (U : <span class="kw">Type</span>) (P Q : Pred U) (h1 : ∃ (x : U), P x → Q x) :</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>    (∀ (x : U), P x) → ∃ (x : U), Q x := <span class="kw">by</span></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb98"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_3_8 (U : <span class="kw">Type</span>) (F : Set (Set U)) (A : Set U)</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>    (h1 : A ∈ F) : A ⊆ ⋃₀ F := <span class="kw">by</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb99"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_3_9 (U : <span class="kw">Type</span>) (F : Set (Set U)) (A : Set U)</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>    (h1 : A ∈ F) : ⋂₀ F ⊆ A := <span class="kw">by</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb100"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_3_10 (U : <span class="kw">Type</span>) (B : Set U) (F : Set (Set U))</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (A : Set U), A ∈ F → B ⊆ A) : B ⊆ ⋂₀ F := <span class="kw">by</span></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb101"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_3_13 (U : <span class="kw">Type</span>)</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>    (F G : Set (Set U)) : F ⊆ G → ⋂₀ G ⊆ ⋂₀ F := <span class="kw">by</span></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="proofs-involving-conjunctions-and-biconditionals" class="level2">
<h2 class="anchored" data-anchor-id="proofs-involving-conjunctions-and-biconditionals">3.4. Proofs Involving Conjunctions and Biconditionals</h2>
<p>The strategies in <em>HTPI</em> for working with conjunctions are very simple (<em>HTPI</em> p.&nbsp;130).</p>
<section id="to-prove-a-goal-of-the-form-p-q-1" class="level4">
<h4 class="anchored" data-anchor-id="to-prove-a-goal-of-the-form-p-q-1">To prove a goal of the form <code>P ∧ Q</code>:</h4>
<div class="ind">
<p>Prove <code>P</code> and <code>Q</code> separately.</p>
</div>
<p>We already saw an example, at the end of the last section, of the use of the rule <code>And.intro</code> to prove a conjunction. In general, if you have <code>h1 : P</code> and <code>h2 : Q</code>, then <code>And.intro h1 h2</code> is a proof of <code>P ∧ Q</code>. It follows that if your goal is <code>P ∧ Q</code> but you don’t yet have proofs of <code>P</code> and <code>Q</code>, then you can use the tactic <code>apply And.intro _ _</code>. Lean will figure out that the blanks need to be filled in with proofs of <code>P</code> and <code>Q</code>, so it will ask you to prove <code>P</code> and <code>Q</code> separately, as suggested by the strategy above.</p>
<p>If you already have a proof of either <code>P</code> or <code>Q</code>, then you can fill in one of the blanks in the <code>apply</code> tactic. For example, if you have <code>h : P</code>, then you can write <code>apply And.intro h _</code>, and Lean will tell you that you just have to prove <code>Q</code> to complete the proof. Similarly, if you have <code>h : Q</code>, then <code>apply And.intro _ h</code> will lead to just the single goal <code>P</code>. There is also a shortcut you can use with the <code>apply</code> tactic: any blanks that come at the end of the tactic can be left out. So instead of <code>apply And.intro _ _</code>, you can just write <code>apply And.intro</code>, and instead of <code>apply And.intro h _</code>, you can write <code>apply And.intro h</code>. On the other hand, <code>apply And.intro _ h</code> can’t be shortened; it is only blanks <em>at the end</em> that can be left out.</p>
<p>The strategy for a given that is a conjunction is similar (<em>HTPI</em> p.&nbsp;131).</p>
</section>
<section id="to-use-a-given-of-the-form-p-q-1" class="level4">
<h4 class="anchored" data-anchor-id="to-use-a-given-of-the-form-p-q-1">To use a given of the form <code>P ∧ Q</code>:</h4>
<div class="ind">
<p>Treat this as two separate givens: <code>P</code>, and <code>Q</code>.</p>
</div>
<p>If you have a given <code>h : P ∧ Q</code>, then Lean will recognize <code>h.left</code> as a proof of <code>P</code>, and <code>h.right</code> as a proof of <code>Q</code>.</p>
<p>Here’s an example that illustrates these strategies. It is similar to Example 3.4.1 in <em>HTPI</em></p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb102"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_4_1 (U : <span class="kw">Type</span>)</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>    (A B C D : Set U) (h1 : A ⊆ B)</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ¬∃ (c : U), c ∈ C ∩ D) :</span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>    A ∩ C ⊆ B \ D := <span class="kw">by</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb103"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C D </span>: Set U</span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B</span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬∃ (c : U), c ∈ C ∩ D</span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a>⊢ A ∩ C ⊆ B \ D</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The <code>define</code> tactic will rewrite the goal as <code>∀ ⦃a : U⦄, a ∈ A ∩ C → a ∈ B \ D</code>, and then we can introduce an arbitrary <code>x : U</code> and assume <code>x ∈ A ∩ C</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb104"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_4_1 (U : <span class="kw">Type</span>)</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>    (A B C D : Set U) (h1 : A ⊆ B)</span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ¬∃ (c : U), c ∈ C ∩ D) :</span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a>    A ∩ C ⊆ B \ D := <span class="kw">by</span></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : x ∈ A ∩ C</span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb105"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C D </span>: Set U</span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B</span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬∃ (c : U), c ∈ C ∩ D</span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: x ∈ A ∩ C</span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ B \ D</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now let’s take a look at the definitions of <code>h3</code> and the goal:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb106"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_4_1 (U : <span class="kw">Type</span>)</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>    (A B C D : Set U) (h1 : A ⊆ B)</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ¬∃ (c : U), c ∈ C ∩ D) :</span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a>    A ∩ C ⊆ B \ D := <span class="kw">by</span></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : x ∈ A ∩ C</span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h3; <span class="kw">define</span></span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb107"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C D </span>: Set U</span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B</span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬∃ (c : U), c ∈ C ∩ D</span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: x ∈ A ∧ x ∈ C</span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ B ∧ x ∉ D</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Since the goal is now a conjunction, we apply the strategy above by using the tactic <code>apply And.intro</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb108"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_4_1 (U : <span class="kw">Type</span>)</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>    (A B C D : Set U) (h1 : A ⊆ B)</span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ¬∃ (c : U), c ∈ C ∩ D) :</span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a>    A ∩ C ⊆ B \ D := <span class="kw">by</span></span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : x ∈ A ∩ C</span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h3; <span class="kw">define</span></span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro</span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb109"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> left</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a><span class="in">A B C D </span>: Set U</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B</span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬∃ (c : U), c ∈ C ∩ D</span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: x ∈ A ∧ x ∈ C</span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ B</span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> right</span>
<span id="cb109-10"><a href="#cb109-10" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb109-11"><a href="#cb109-11" aria-hidden="true" tabindex="-1"></a><span class="in">A B C D </span>: Set U</span>
<span id="cb109-12"><a href="#cb109-12" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B</span>
<span id="cb109-13"><a href="#cb109-13" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬∃ (c : U), c ∈ C ∩ D</span>
<span id="cb109-14"><a href="#cb109-14" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb109-15"><a href="#cb109-15" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: x ∈ A ∧ x ∈ C</span>
<span id="cb109-16"><a href="#cb109-16" aria-hidden="true" tabindex="-1"></a>⊢ x ∉ D</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Look carefully at the tactic state. Lean has listed <em>two</em> goals, one after the other, and it has helpfully labeled them “case left” and “case right,” indicating that the first goal is to prove the left side of the conjunction and the second is to prove the right. The given information in both cases is the same, but in the first case the goal is <code>x ∈ B</code>, and in the second it is <code>x ∉ D</code>. At this point, if we simply continue with the proof, Lean will interpret our tactics as applying to the first goal, until we achieve that goal. Once we achieve it, Lean will move on to the second goal.</p>
<p>However, we can make our proof more readable by separating and labeling the proofs of the two goals. To do this, we type a bullet (which looks like this: <code>·</code>) and then a comment describing the first goal. (To type a bullet, type <code>\.</code>—that is, backslash–period.) The proof of the first goal will appear below this line, indented further and ending with <code>done</code>. To prepare for this, we leave a blank line, type tab to increase the indenting, and then type <code>done</code>. Then we do the same for the second goal: on the next line, we return to the previous level of indenting and type a bullet and a comment describing the second goal. We follow this with a blank line and then an indented <code>done</code> to indicate the end of the proof of the second goal. We’re going to work on the first goal first, so we click on the first blank line to position the cursor there. The screen now looks like this:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb110"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_4_1 (U : <span class="kw">Type</span>)</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>    (A B C D : Set U) (h1 : A ⊆ B)</span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ¬∃ (c : U), c ∈ C ∩ D) :</span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>    A ∩ C ⊆ B \ D := <span class="kw">by</span></span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : x ∈ A ∩ C</span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h3; <span class="kw">define</span></span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro</span>
<span id="cb110-10"><a href="#cb110-10" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that x ∈ B</span></span>
<span id="cb110-11"><a href="#cb110-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-12"><a href="#cb110-12" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb110-13"><a href="#cb110-13" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that x ∉ D</span></span>
<span id="cb110-14"><a href="#cb110-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-15"><a href="#cb110-15" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb110-16"><a href="#cb110-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb111"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> left</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a><span class="in">A B C D </span>: Set U</span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B</span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬∃ (c : U), c ∈ C ∩ D</span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: x ∈ A ∧ x ∈ C</span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Of course, there are red squiggles under both new occurrences of <code>done</code>, since neither goal has yet been achieved. We can work on the goals in either order by positioning the cursor on either blank line, and the Infoview pane will show the tactic state for the goal at the position of the cursor. In the display above, we have positioned the cursor on the first blank line, so the Infoview shows the tactic state for the first goal.</p>
<p>This first goal is easy: We have <code>h1 : A ⊆ B</code> and, as explained above, <code>h3.left : x ∈ A</code>. As we have seen in several previous examples, the tactic <code>define at h1</code> will rewrite <code>h1</code> as <code>∀ ⦃a : U⦄, a ∈ A → a ∈ B</code>, and then <code>h1 h3.left</code> will be a proof of <code>x ∈ B</code>. And now we’ll let you in on a little secret: usually the <code>define</code> tactic isn’t really necessary. <em>You</em> may find the <code>define</code> tactic to be useful in many situations, because it helps you see what a statement means. But <em>Lean</em> doesn’t need to be told to work out what the statement means; it will do that automatically. So we can skip the define tactic and just give <code>h1 h3.left</code> as a proof of <code>x ∈ B</code>. In general, if you have <code>h1 : A ⊆ B</code> and <code>h2 : x ∈ A</code>, then Lean will recognize <code>h1 h2</code> as a proof of <code>x ∈ B</code>. Thus, the tactic <code>show x ∈ B from h1 h3.left</code> will complete the first goal. Once we type this (indented to the same position as the <code>done</code> for the first goal), the red squiggle disappears from the first <code>done</code>, and the tactic state shows the <code>No goals</code> message. If we then click on the blank line for the second goal, the Infoview pane shows the tactic state for that goal:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb112"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_4_1 (U : <span class="kw">Type</span>)</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>    (A B C D : Set U) (h1 : A ⊆ B)</span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ¬∃ (c : U), c ∈ C ∩ D) :</span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a>    A ∩ C ⊆ B \ D := <span class="kw">by</span></span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : x ∈ A ∩ C</span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h3; <span class="kw">define</span></span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro</span>
<span id="cb112-10"><a href="#cb112-10" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that x ∈ B:</span></span>
<span id="cb112-11"><a href="#cb112-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> x ∈ B <span class="kw">from</span> h1 h3.left</span>
<span id="cb112-12"><a href="#cb112-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb112-13"><a href="#cb112-13" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that x ∉ D</span></span>
<span id="cb112-14"><a href="#cb112-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-15"><a href="#cb112-15" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb112-16"><a href="#cb112-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb113"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> right</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a><span class="in">A B C D </span>: Set U</span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B</span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬∃ (c : U), c ∈ C ∩ D</span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: x ∈ A ∧ x ∈ C</span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a>⊢ x ∉ D</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The second goal is a negative statement, and the given <code>h2</code> is also a negative statement. This suggests using proof by contradiction, and achieving the contradiction by contradicting <code>h2</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb114"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_4_1 (U : <span class="kw">Type</span>)</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>    (A B C D : Set U) (h1 : A ⊆ B)</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ¬∃ (c : U), c ∈ C ∩ D) :</span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>    A ∩ C ⊆ B \ D := <span class="kw">by</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : x ∈ A ∩ C</span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h3; <span class="kw">define</span></span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro</span>
<span id="cb114-10"><a href="#cb114-10" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that x ∈ B.</span></span>
<span id="cb114-11"><a href="#cb114-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> x ∈ B <span class="kw">from</span> h1 h3.left</span>
<span id="cb114-12"><a href="#cb114-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb114-13"><a href="#cb114-13" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that x ∉ D.</span></span>
<span id="cb114-14"><a href="#cb114-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">contradict</span> h2 <span class="kw">with</span> h4</span>
<span id="cb114-15"><a href="#cb114-15" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb114-16"><a href="#cb114-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb115"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> right</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a><span class="in">A B C D </span>: Set U</span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B</span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬∃ (c : U), c ∈ C ∩ D</span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: x ∈ A ∧ x ∈ C</span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: x ∈ D</span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a>⊢ ∃ (c : U), c ∈ C ∩ D</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The goal is now an existential statement, and looking at <code>h3</code> and <code>h4</code> it is clear that the right value to plug in for <code>c</code> in the goal is <code>x</code>. The tactic <code>apply Exists.intro x</code> will change the goal to <code>x ∈ C ∩ D</code> (we have again left off the unnecessary blank at the end of the <code>apply</code> tactic).</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb116"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_4_1 (U : <span class="kw">Type</span>)</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>    (A B C D : Set U) (h1 : A ⊆ B)</span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ¬∃ (c : U), c ∈ C ∩ D) :</span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>    A ∩ C ⊆ B \ D := <span class="kw">by</span></span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : x ∈ A ∩ C</span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h3; <span class="kw">define</span></span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro</span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that x ∈ B.</span></span>
<span id="cb116-11"><a href="#cb116-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> x ∈ B <span class="kw">from</span> h1 h3.left</span>
<span id="cb116-12"><a href="#cb116-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb116-13"><a href="#cb116-13" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that x ∉ D.</span></span>
<span id="cb116-14"><a href="#cb116-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">contradict</span> h2 <span class="kw">with</span> h4</span>
<span id="cb116-15"><a href="#cb116-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro x</span>
<span id="cb116-16"><a href="#cb116-16" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb116-17"><a href="#cb116-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb117"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> right</span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a><span class="in">A B C D </span>: Set U</span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B</span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬∃ (c : U), c ∈ C ∩ D</span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb117-7"><a href="#cb117-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: x ∈ A ∧ x ∈ C</span>
<span id="cb117-8"><a href="#cb117-8" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: x ∈ D</span>
<span id="cb117-9"><a href="#cb117-9" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ C ∩ D</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The <code>define</code> tactic would now rewrite the goal as <code>x ∈ C ∧ x ∈ D</code>, and we could prove this goal by combining <code>h3.right</code> and <code>h4</code>, using the <code>And.intro</code> rule. But since we know what the result of the <code>define</code> tactic will be, there is really no need to use it. We can just use <code>And.intro</code> right away to complete the proof.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb118"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_3_4_1 (U : <span class="kw">Type</span>)</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>    (A B C D : Set U) (h1 : A ⊆ B)</span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ¬∃ (c : U), c ∈ C ∩ D) :</span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>    A ∩ C ⊆ B \ D := <span class="kw">by</span></span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : x ∈ A ∩ C</span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h3; <span class="kw">define</span></span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro</span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that x ∈ B.</span></span>
<span id="cb118-11"><a href="#cb118-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> x ∈ B <span class="kw">from</span> h1 h3.left</span>
<span id="cb118-12"><a href="#cb118-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb118-13"><a href="#cb118-13" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that x ∉ D.</span></span>
<span id="cb118-14"><a href="#cb118-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">contradict</span> h2 <span class="kw">with</span> h4</span>
<span id="cb118-15"><a href="#cb118-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro x</span>
<span id="cb118-16"><a href="#cb118-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> x ∈ C ∩ D <span class="kw">from</span> And.intro h3.right h4</span>
<span id="cb118-17"><a href="#cb118-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb118-18"><a href="#cb118-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb119"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="ss">No</span><span class="in"> </span><span class="ss">goals</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Since <code>P ↔︎ Q</code> is shorthand for <code>(P → Q) ∧ (Q → P)</code>, the strategies given above for conjunctions lead immediately to the following strategies for biconditionals (<em>HTPI</em> p.&nbsp;132):</p>
</section>
<section id="to-prove-a-goal-of-the-form-p-q-2" class="level4">
<h4 class="anchored" data-anchor-id="to-prove-a-goal-of-the-form-p-q-2">To prove a goal of the form <code>P ↔︎ Q</code>:</h4>
<div class="ind">
<p>Prove <code>P → Q</code> and <code>Q → P</code> separately.</p>
</div>
</section>
<section id="to-use-a-given-of-the-form-p-q-2" class="level4">
<h4 class="anchored" data-anchor-id="to-use-a-given-of-the-form-p-q-2">To use a given of the form <code>P ↔︎ Q</code>:</h4>
<div class="ind">
<p>Treat this as two separate givens: <code>P → Q</code>, and <code>Q → P</code>.</p>
</div>
<p>The methods for using these strategies in Lean are similar to those we used above for conjunctions. If we have <code>h1 : P → Q</code> and <code>h2 : Q → P</code>, then <code>Iff.intro h1 h2</code> is a proof of <code>P ↔︎ Q</code>. Thus, if the goal is <code>P ↔︎ Q</code>, then the tactic <code>apply Iff.intro _ _</code> will convert this into two separate goals, <code>P → Q</code> and <code>Q → P</code>. Once again, you can fill in one of these blanks if you already have a proof of either <code>P → Q</code> or <code>Q → P</code>, and you can leave out any blanks at the end of the tactic. If you have a given <code>h : P ↔︎ Q</code>, then <code>h.ltr</code> is a proof of the left-to-right direction of the biconditional, <code>P → Q</code>, and <code>h.rtl</code> is a proof of the right-to-left direction, <code>Q → P</code>.</p>
<p>Let’s try these strategies out in an example.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb120"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x : U), P x ↔ Q x) :</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>    (∃ (x : U), P x) ↔ ∃ (x : U), Q x := <span class="kw">by</span></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb121"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x ↔ Q x</span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>⊢ (∃ (x : U), P x) ↔</span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  ∃ (x : U), Q x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The goal is a biconditional statement, so we begin with the tactic <code>apply Iff.intro</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb122"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x : U), P x ↔ Q x) :</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>    (∃ (x : U), P x) ↔ ∃ (x : U), Q x := <span class="kw">by</span></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb123"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mp</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x ↔ Q x</span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>⊢ (∃ (x : U), P x) →</span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  ∃ (x : U), Q x</span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mpr</span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb123-9"><a href="#cb123-9" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb123-10"><a href="#cb123-10" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x ↔ Q x</span>
<span id="cb123-11"><a href="#cb123-11" aria-hidden="true" tabindex="-1"></a>⊢ (∃ (x : U), Q x) →</span>
<span id="cb123-12"><a href="#cb123-12" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  ∃ (x : U), P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Once again, we have two goals. (The case labels this time aren’t very intuitive; “mp” stands for “modus ponens” and “mpr” stands for “modus ponens reverse”.) Whenever we have multiple goals, we’ll use the bulleted-and-indented style introduced in the last example. As in <em>HTPI</em>, we’ll label the proofs of the two goals with <code>(→)</code> and <code>(←)</code>, representing the two directions of the biconditional symbol <code>↔︎</code>. (You can type <code>←</code> in VS Code by typing <code>\l</code>, short for “left”.) The first goal is a conditional statement, so we assume the antecedent.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb124"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x : U), P x ↔ Q x) :</span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a>    (∃ (x : U), P x) ↔ ∃ (x : U), Q x := <span class="kw">by</span></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : ∃ (x : U), P x</span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb124-9"><a href="#cb124-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-10"><a href="#cb124-10" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb124-11"><a href="#cb124-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb125"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mp</span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x ↔ Q x</span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (x : U), P x</span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true" tabindex="-1"></a>⊢ ∃ (x : U), Q x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>As usual, when we have an existential given, we use it right away.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb126"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x : U), P x ↔ Q x) :</span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>    (∃ (x : U), P x) ↔ ∃ (x : U), Q x := <span class="kw">by</span></span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : ∃ (x : U), P x</span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (u : U) (h3 : P u) <span class="kw">from</span> h2</span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb126-9"><a href="#cb126-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb126-10"><a href="#cb126-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-11"><a href="#cb126-11" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb126-12"><a href="#cb126-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb127"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mp</span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x ↔ Q x</span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (x : U), P x</span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a><span class="in">u </span>: U</span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: P u</span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a>⊢ ∃ (x : U), Q x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now that we have an object of type <code>U</code> in the tactic state, we can use <code>h1</code> by applying universal instantiation.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb128"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x : U), P x ↔ Q x) :</span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a>    (∃ (x : U), P x) ↔ ∃ (x : U), Q x := <span class="kw">by</span></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : ∃ (x : U), P x</span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (u : U) (h3 : P u) <span class="kw">from</span> h2</span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : P u ↔ Q u := h1 u</span>
<span id="cb128-9"><a href="#cb128-9" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb128-10"><a href="#cb128-10" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb128-11"><a href="#cb128-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-12"><a href="#cb128-12" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb128-13"><a href="#cb128-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb129"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mp</span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x ↔ Q x</span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (x : U), P x</span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a><span class="in">u </span>: U</span>
<span id="cb129-7"><a href="#cb129-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: P u</span>
<span id="cb129-8"><a href="#cb129-8" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: P u ↔ Q u</span>
<span id="cb129-9"><a href="#cb129-9" aria-hidden="true" tabindex="-1"></a>⊢ ∃ (x : U), Q x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Looking at <code>h3</code> and <code>h4</code>, we can now see that we will be able to complete the proof if we assign the value <code>u</code> to <code>x</code> in the goal. So our next step is the tactic <code>apply Exists.intro u</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb130"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x : U), P x ↔ Q x) :</span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a>    (∃ (x : U), P x) ↔ ∃ (x : U), Q x := <span class="kw">by</span></span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb130-6"><a href="#cb130-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : ∃ (x : U), P x</span>
<span id="cb130-7"><a href="#cb130-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (u : U) (h3 : P u) <span class="kw">from</span> h2</span>
<span id="cb130-8"><a href="#cb130-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : P u ↔ Q u := h1 u</span>
<span id="cb130-9"><a href="#cb130-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro u</span>
<span id="cb130-10"><a href="#cb130-10" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb130-11"><a href="#cb130-11" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb130-12"><a href="#cb130-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-13"><a href="#cb130-13" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb130-14"><a href="#cb130-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb131"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mp</span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x ↔ Q x</span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (x : U), P x</span>
<span id="cb131-6"><a href="#cb131-6" aria-hidden="true" tabindex="-1"></a><span class="in">u </span>: U</span>
<span id="cb131-7"><a href="#cb131-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: P u</span>
<span id="cb131-8"><a href="#cb131-8" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: P u ↔ Q u</span>
<span id="cb131-9"><a href="#cb131-9" aria-hidden="true" tabindex="-1"></a>⊢ Q u</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>To complete the proof, we use the left-to-right direction of <code>h4</code>. We have <code>h4.ltr : P u → Q u</code> and <code>h3 : P u</code>, so by modus ponens, <code>h4.ltr h3</code> proves the goal <code>Q u</code>. Once we enter this step, Lean indicates that the left-to-right proof is complete, and we can position the cursor below the right-to-left bullet to see the tactic state for the second half of the proof.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb132"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x : U), P x ↔ Q x) :</span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a>    (∃ (x : U), P x) ↔ ∃ (x : U), Q x := <span class="kw">by</span></span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : ∃ (x : U), P x</span>
<span id="cb132-7"><a href="#cb132-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (u : U) (h3 : P u) <span class="kw">from</span> h2</span>
<span id="cb132-8"><a href="#cb132-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : P u ↔ Q u := h1 u</span>
<span id="cb132-9"><a href="#cb132-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro u</span>
<span id="cb132-10"><a href="#cb132-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> Q u <span class="kw">from</span> h4.ltr h3</span>
<span id="cb132-11"><a href="#cb132-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb132-12"><a href="#cb132-12" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb132-13"><a href="#cb132-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-14"><a href="#cb132-14" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb132-15"><a href="#cb132-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb133"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mpr</span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x ↔ Q x</span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a>⊢ (∃ (x : U), Q x) →</span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  ∃ (x : U), P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The second half of the proof is similar to the first. We begin by assuming <code>h2 : ∃ (x : U), Q x</code>, and then we use that assumption to obtain <code>u : U</code> and <code>h3 : Q u</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb134"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x : U), P x ↔ Q x) :</span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>    (∃ (x : U), P x) ↔ ∃ (x : U), Q x := <span class="kw">by</span></span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : ∃ (x : U), P x</span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (u : U) (h3 : P u) <span class="kw">from</span> h2</span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : P u ↔ Q u := h1 u</span>
<span id="cb134-9"><a href="#cb134-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro u</span>
<span id="cb134-10"><a href="#cb134-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> Q u <span class="kw">from</span> h4.ltr h3</span>
<span id="cb134-11"><a href="#cb134-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb134-12"><a href="#cb134-12" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb134-13"><a href="#cb134-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : ∃ (x : U), Q x</span>
<span id="cb134-14"><a href="#cb134-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (u : U) (h3 : Q u) <span class="kw">from</span> h2</span>
<span id="cb134-15"><a href="#cb134-15" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb134-16"><a href="#cb134-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb135"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mpr</span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a><span class="in">P Q </span>: Pred U</span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (x : U), P x ↔ Q x</span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (x : U), Q x</span>
<span id="cb135-6"><a href="#cb135-6" aria-hidden="true" tabindex="-1"></a><span class="in">u </span>: U</span>
<span id="cb135-7"><a href="#cb135-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: Q u</span>
<span id="cb135-8"><a href="#cb135-8" aria-hidden="true" tabindex="-1"></a>⊢ ∃ (x : U), P x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>We can actually shorten the proof by packing a lot into a single step. See if you can figure out the last line of the completed proof below; we’ll give an explanation after the proof.</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (P Q : Pred U)</span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x : U), P x ↔ Q x) :</span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a>    (∃ (x : U), P x) ↔ ∃ (x : U), Q x := <span class="kw">by</span></span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb136-5"><a href="#cb136-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb136-6"><a href="#cb136-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : ∃ (x : U), P x</span>
<span id="cb136-7"><a href="#cb136-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (u : U) (h3 : P u) <span class="kw">from</span> h2</span>
<span id="cb136-8"><a href="#cb136-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : P u ↔ Q u := h1 u</span>
<span id="cb136-9"><a href="#cb136-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro u</span>
<span id="cb136-10"><a href="#cb136-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> Q u <span class="kw">from</span> h4.ltr h3</span>
<span id="cb136-11"><a href="#cb136-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb136-12"><a href="#cb136-12" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb136-13"><a href="#cb136-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : ∃ (x : U), Q x</span>
<span id="cb136-14"><a href="#cb136-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (u : U) (h3 : Q u) <span class="kw">from</span> h2</span>
<span id="cb136-15"><a href="#cb136-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ∃ (x : U), P x <span class="kw">from</span> Exists.intro u ((h1 u).rtl h3)</span>
<span id="cb136-16"><a href="#cb136-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb136-17"><a href="#cb136-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To understand the last step, start with the fact that <code>h1 u</code> is a proof of <code>P u ↔︎ Q u</code>. Therefore <code>(h1 u).rtl</code> is a proof of <code>Q u → P u</code>, so by modus ponens, <code>(h1 u).rtl h3</code> is a proof of <code>P u</code>. It follows that <code>Exists.intro u ((h1 u).rtl h3)</code> is a proof of <code>∃ (x : U), P x</code>, which was the goal.</p>
<p>There is one more style of reasoning that is sometimes used in proofs of biconditional statements. It is illustrated in Example 3.4.5 of <em>HTPI</em>. Here is that theorem, as it is presented in <em>HTPI</em> (<em>HTPI</em> p.&nbsp;137).</p>
<div class="thm">
<p>Suppose <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, and <span class="math inline">\(C\)</span> are sets. Then <span class="math inline">\(A \cap (B \setmin C) = (A \cap B) \setmin C\)</span>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Let <span class="math inline">\(x\)</span> be arbitrary. Then <span class="math display">\[\begin{align*}
x \in A \cap (B \setmin C) &amp;\text{ iff } x \in A \wedge x \in B \setmin C\\
&amp;\text{ iff } x \in A \wedge x \in B \wedge x \notin C\\
&amp;\text{ iff } x \in (A \cap B) \wedge x \notin C\\
&amp;\text{ iff } x \in (A \cap B) \setmin C.
\end{align*}\]</span> Thus, <span class="math inline">\(\forall x(x \in A \cap (B \setmin C) \leftrightarrow x \in (A \cap B) \setmin C)\)</span>, so <span class="math inline">\(A \cap (B \setmin C) = (A \cap B) \setmin C\)</span>. <span class="excl">&nbsp;□</span></p>
</div>
<p>This proof is based on a fundamental principle of set theory that says that if two sets have exactly the same elements, then they are equal. This principle is called the <em>axiom of extensionality</em>, and it is what justifies the inference, in the last sentence, from <span class="math inline">\(\forall x(x \in A \cap (B \setmin C) \leftrightarrow x \in (A \cap B) \setmin C)\)</span> to <span class="math inline">\(A \cap (B \setmin C) = (A \cap B) \setmin C\)</span>.</p>
<p>The heart of the proof is a string of equivalences that, taken together, establish the biconditional statement <span class="math inline">\(x \in A \cap (B \setmin C) \leftrightarrow x \in (A \cap B) \setmin C\)</span>. One can also use this technique to prove a biconditional statement in Lean. This time we’ll simply present the complete proof first, and then explain it afterwards.</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_4_5 (U : <span class="kw">Type</span>)</span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>    (A B C : Set U) : A ∩ (B \ C) = (A ∩ B) \ C := <span class="kw">by</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> x ∈ A ∩ (B \ C) ↔ x ∈ (A ∩ B) \ C <span class="kw">from</span></span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> x ∈ A ∩ (B \ C)</span>
<span id="cb137-7"><a href="#cb137-7" aria-hidden="true" tabindex="-1"></a>      _ ↔ x ∈ A ∧ (x ∈ B ∧ x ∉ C) := Iff.refl _</span>
<span id="cb137-8"><a href="#cb137-8" aria-hidden="true" tabindex="-1"></a>      _ ↔ (x ∈ A ∧ x ∈ B) ∧ x ∉ C := and_assoc.symm</span>
<span id="cb137-9"><a href="#cb137-9" aria-hidden="true" tabindex="-1"></a>      _ ↔ x ∈ (A ∩ B) \ C := Iff.refl _</span>
<span id="cb137-10"><a href="#cb137-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The name of the axiom of extensionality in Lean is <code>Set.ext</code>, and it is applied in the first step of the Lean proof. As usual, the <code>apply</code> tactic works backwards from the goal. In other words, after the first line of the proof, the goal is <code>∀ (x : U), x ∈ A ∩ (B \ C) ↔︎ x ∈ (A ∩ B) \ C</code>, because by <code>Set.ext</code>, the conclusion of the theorem would follow from this statement. The rest of the proof then proves this goal by introducing an arbitrary <code>x</code> of type <code>U</code> and then proving the biconditional by stringing together several equivalences, exactly as in the <em>HTPI</em> proof.</p>
<p>The proof of the biconditional is called a <em>calculational proof</em>, and it is introduced by the keyword <code>calc</code>. The calculational proof consists of a string of biconditional statements, each of which is provided with a proof. You can think of the underscore on the left side of each biconditional as standing for the right side of the previous biconditional (or, in the case of the first biconditional, the statement after <code>calc</code>).</p>
<p>The proofs of the individual biconditionals in the calculational proof require some explanation. Lean has a large library of theorems that it knows, and you can use those theorems in your proofs. In particular, <code>Iff.refl</code> and <code>and_assoc</code> are names of theorems in Lean’s library. You can find out what any theorem says by using the Lean command <code>#check</code>. (Commands that ask Lean for a response generally start with the character <code>#</code>.) If you type <code>#check Iff.refl</code> in a Lean file, you will see Lean’s response in the Infoview pane: <code>Iff.refl (a : Prop) : a ↔︎ a</code>. What this tells us is that Lean already knows the theorem</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Iff.refl (a : <span class="kw">Prop</span>) : a ↔ a</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>(This theorem says that “iff” has a property called <em>reflexivity</em>; we’ll discuss reflexivity in Chapter 4.) When variables are declared in the statement of a theorem, it is understood that they can stand for anything of the appropriate type (see Section 3.1 of <em>HTPI</em>). Thus, the theorem <code>Iff.refl</code> can be thought of as establishing the truth of the statement <code>∀ (a : Prop), a ↔︎ a</code>. In fact, you can get Lean to report the meaning of the theorem in this form with the command <code>#check @Iff.refl</code>. What this means is that, in any proof, Lean lets you treat <code>Iff.refl</code> as a proof of the statement <code>∀ (a : Prop), a ↔︎ a</code>. Thus, by universal instantiation, for any proposition <code>a</code>, Lean will recognize <code>Iff.refl a</code> as a proof of <code>a ↔︎ a</code>. This is used to justify the first biconditional in the calculational proof.</p>
<p>But wait! The first biconditional in the calculational proof is <code>x ∈ A ∩ (B \ C) ↔︎ x ∈ A ∧ (x ∈ B ∧ x ∉ C)</code>, which does not have the form <code>a ↔︎ a</code>. How can it be justified by the theorem <code>Iff.refl</code>? Recall that Lean doesn’t need to be told to write out definitions of mathematical notation; it does that automatically. When the definitions of the set theory notation are written out, the first biconditional in the calculational proof becomes <code>x ∈ A ∧ (x ∈ B ∧ x ∉ C) ↔︎ x ∈ A ∧ (x ∈ B ∧ x ∉ C)</code>, which <em>does</em> have the form <code>a ↔︎ a</code>, so it can be proven with the term-mode proof <code>Iff.refl _</code>. Note that we are using an underscore here to ask Lean to figure out what to plug in for <code>a</code>. This saves us the trouble of writing out the full term-mode proof, which would be <code>Iff.refl (x ∈ A ∧ (x ∈ B ∧ x ∉ C))</code>. The lesson of this example is that the theorem <code>Iff.refl</code> is more powerful than it looks. Not only can we use <code>Iff.refl _</code> to prove statements of the form <code>a ↔︎ a</code>, we can also use it to prove statements of the form <code>a ↔︎ a'</code>, if <code>a</code> and <code>a'</code> reduce to the same thing when definitions are filled in. We say in this case that <code>a</code> and <code>a'</code> are <em>definitionally equal</em>. This explains the third line of the calculational proof, which is also justified by the proof <code>Iff.refl _</code>.</p>
<p>The second line uses the theorem <code>and_assoc</code>. If you type <code>#check and_assoc</code>, you will get this response from Lean:</p>
<div class="ind">
<pre><code>and_assoc {a b c : Prop} : (a ∧ b) ∧ c ↔ a ∧ b ∧ c</code></pre>
</div>
<p>Once again, it is understood that the variables <code>a</code>, <code>b</code>, and <code>c</code> can stand for any propositions, as you can see by giving the command <code>#check @and_assoc</code>. This generates the response</p>
<div class="ind">
<pre><code>@and_assoc : ∀ {a b c : Prop}, (a ∧ b) ∧ c ↔ a ∧ b ∧ c</code></pre>
</div>
<p>which is shorthand for</p>
<div class="ind">
<pre><code>@and_assoc : ∀ {a : Prop}, ∀ {b : Prop}, ∀ {c : Prop},
              (a ∧ b) ∧ c ↔ a ∧ (b ∧ c)</code></pre>
</div>
<p>Recall that the curly braces indicate that <code>a</code>, <code>b</code>, and <code>c</code> are implicit arguments, and that Lean groups the logical connectives to the right, which means that it interprets <code>a ∧ b ∧ c</code> as <code>a ∧ (b ∧ c)</code>. This is the associative law for “and” (see Section 1.2 of <em>HTPI</em>). Since <code>a</code>, <code>b</code>, and <code>c</code> are implicit, Lean will recognize <code>and_assoc</code> as a proof of any statement of the form <code>(a ∧ b) ∧ c ↔︎ a ∧ (b ∧ c)</code>, where <code>a</code>, <code>b</code>, and <code>c</code> can be replaced with any propositions. Lean doesn’t need to be told what propositions are being used as <code>a</code>, <code>b</code>, and <code>c</code>; it will figure that out for itself. Unfortunately, the second biconditional in the calculational proof is <code>x ∈ A ∧ (x ∈ B ∧ x ∉ C) ↔︎ (x ∈ A ∧ x ∈ B) ∧ x ∉ C</code>, which has the form <code>a ∧ (b ∧ c) ↔︎ (a ∧ b) ∧ c</code>, not <code>(a ∧ b) ∧ c ↔︎ a ∧ (b ∧ c)</code>. (Notice that the first of these biconditionals is the same as the second except that the left and right sides have been swapped.) To account for this discrepancy, we use the fact that if <code>h</code> is a proof of any biconditional <code>P ↔︎ Q</code>, then <code>h.symm</code> is a proof of <code>Q ↔︎ P</code>. Thus <code>and_assoc.symm</code> proves the second biconditional in the calculational proof. (By the way, the <em>HTPI</em> proof avoids any mention of the associativity of “and” by simply leaving out parentheses in the conjunction <span class="math inline">\(x \in A \wedge x \in B \wedge x \notin C\)</span>. As explained in Section 1.2 of <em>HTPI</em>, this represents an implicit use of the associativity of “and.”)</p>
<p>You can get a better understanding of the first step of our last proof by typing <code>#check @Set.ext</code>. The result is</p>
<div class="ind">
<pre><code>@Set.ext : ∀ {α : Type u_1} {a b : Set α},
            (∀ (x : α), x ∈ a ↔ x ∈ b) → a = b</code></pre>
</div>
<p>which is shorthand for</p>
<div class="ind">
<pre><code>@Set.ext : ∀ {α : Type u_1}, ∀ {a : Set α}, ∀ {b : Set α},
            (∀ (x : α), x ∈ a ↔ x ∈ b) → a = b</code></pre>
</div>
<p>Ignoring the <code>u_1</code>, whose significance won’t be important to us, this means that <code>Set.ext</code> can be used to prove any statement of the form <code>(∀ (x : α), x ∈ a ↔︎ x ∈ b) → a = b</code>, where <code>α</code> can be replaced by any type and <code>a</code> and <code>b</code> can be replaced by any sets of objects of type <code>α</code>. Make sure you understand how this explains the effect of the tactic <code>apply Set.ext</code> in the first step of our last proof. Almost all of our proofs that two sets are equal will start with <code>apply Set.ext</code>.</p>
<p>Notice that in Lean’s responses to both <code>#check @and_assoc</code> and <code>#check @Set.ext</code>, multiple universal quantifiers in a row were grouped together and written as a single universal quantifier followed by a list of variables (with types). Lean allows this notational shorthand for any sequence of consecutive quantifiers, as long as they are all of the same kind (all existential or all universal), and we will use this notation from now on.</p>
</section>
<section id="exercises-2" class="level3">
<h3 class="anchored" data-anchor-id="exercises-2">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb144"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_4_2 (U : <span class="kw">Type</span>) (A B C : Set U)</span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>    (h1 : A ⊆ B) (h2 : A ⊆ C) : A ⊆ B ∩ C := <span class="kw">by</span></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb145"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_4_4 (U : <span class="kw">Type</span>) (A B C : Set U)</span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a>    (h1 : A ⊆ B) (h2 : A ⊈ C) : B ⊈ C := <span class="kw">by</span></span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb146"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_3_16 (U : <span class="kw">Type</span>) (B : Set U)</span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a>    (F : Set (Set U)) : F ⊆ 𝒫 B → ⋃₀ F ⊆ B := <span class="kw">by</span></span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb147"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_3_17 (U : <span class="kw">Type</span>) (F G : Set (Set U))</span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (A : Set U), A ∈ F → ∀ (B : Set U), B ∈ G → A ⊆ B) :</span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a>    ⋃₀ F ⊆ ⋂₀ G := <span class="kw">by</span></span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb148"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_4_7 (U : <span class="kw">Type</span>) (A B : Set U) :</span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a>    𝒫 (A ∩ B) = 𝒫 A ∩ 𝒫 B := <span class="kw">by</span></span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb148-4"><a href="#cb148-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="6">
<div class="sourceCode" id="cb149"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_4_17 (U : <span class="kw">Type</span>) (A : Set U) : A = ⋃₀ (𝒫 A) := <span class="kw">by</span></span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="7">
<div class="sourceCode" id="cb150"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_4_18a (U : <span class="kw">Type</span>) (F G : Set (Set U)) :</span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a>    ⋃₀ (F ∩ G) ⊆ (⋃₀ F) ∩ (⋃₀ G) := <span class="kw">by</span></span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="8">
<div class="sourceCode" id="cb151"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_4_19 (U : <span class="kw">Type</span>) (F G : Set (Set U)) :</span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a>    (⋃₀ F) ∩ (⋃₀ G) ⊆ ⋃₀ (F ∩ G) ↔</span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a>      ∀ (A B : Set U), A ∈ F → B ∈ G → A ∩ B ⊆ ⋃₀ (F ∩ G) := <span class="kw">by</span></span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb151-5"><a href="#cb151-5" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="proofs-involving-disjunctions" class="level2">
<h2 class="anchored" data-anchor-id="proofs-involving-disjunctions">3.5. Proofs Involving Disjunctions</h2>
<p>A common proof method for dealing with givens or goals that are disjunctions is <em>proof by cases</em>. Here’s how it works (<em>HTPI</em> p.&nbsp;143).</p>
<section id="to-use-a-given-of-the-form-p-q-3" class="level4">
<h4 class="anchored" data-anchor-id="to-use-a-given-of-the-form-p-q-3">To use a given of the form <code>P ∨ Q</code>:</h4>
<div class="ind">
<p>Break your proof into cases. For case 1, assume that <code>P</code> is true and use this assumption to prove the goal. For case 2, assume that <code>Q</code> is true and prove the goal.</p>
</div>
<p>In Lean, you can break a proof into cases by using the <code>by_cases</code> tactic. If you have a given <code>h : P ∨ Q</code>, then the tactic <code>by_cases on h</code> will break your proof into two cases. For the first case, the given <code>h</code> will be changed to <code>h : P</code>, and for the second, it will be changed to <code>h : Q</code>; the goal for both cases will be the same as the original goal. Thus, the effect of the <code>by_cases on h</code> tactic is as follows:</p>
<div class="lftrt">
<div class="bef">
<div class="sourceCode" id="cb152"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span> ⋮</span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a><span class="in">h </span>: P ∨ Q</span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a>⊢ goal</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="aft">
<div class="sourceCode" id="cb153"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> Case_1</span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span> ⋮</span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a><span class="in">h </span>: P</span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a>⊢ goal</span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> Case_2</span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span> ⋮</span>
<span id="cb153-7"><a href="#cb153-7" aria-hidden="true" tabindex="-1"></a><span class="in">h </span>: Q</span>
<span id="cb153-8"><a href="#cb153-8" aria-hidden="true" tabindex="-1"></a>⊢ goal</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Notice that the original given <code>h : P ∨ Q</code> gets <em>replaced</em> by <code>h : P</code> in case 1 and <code>h : Q</code> in case 2. This is usually what is most convenient, but if you write <code>by_cases on h with h1</code>, then the original given <code>h</code> will be preserved, and new givens <code>h1 : P</code> and <code>h1 : Q</code> will be added to cases 1 and 2, respectively. If you want different names for the new givens in the two cases, then use <code>by_cases on h with h1, h2</code> to add the new given <code>h1 : P</code> in case 1 and <code>h2 : Q</code> in case 2.</p>
<p>You can follow <code>by_cases on</code> with any proof of a disjunction, even if that proof is not just a single identifier. In that cases you will want to add <code>with</code> to specify the identifier or identifiers to be used for the new assumptions in the two cases. Another variant is that you can use the tactic <code>by_cases h : P</code> to break your proof into two cases, with the new assumptions being <code>h : P</code> in case 1 and <code>h : ¬P</code> in case 2. In other words, the effect of <code>by_cases h : P</code> is the same as adding the new given <code>h : P ∨ ¬P</code> (which, of course, is a tautology) and then using the tactic <code>by_cases on h</code>.</p>
<p>There are several introduction rules that you can use in Lean to prove a goal of the form <code>P ∨ Q</code>. If you have <code>h : P</code>, then Lean will accept <code>Or.intro_left Q h</code> as a proof of <code>P ∨ Q</code>. In most situations Lean can infer the proposition <code>Q</code> from context, and in that case you can use the shorter form <code>Or.inl h</code> as a proof of <code>P ∨ Q</code>. You can see the difference between <code>Or.intro_left</code> and <code>Or.inl</code> by using the <code>#check</code> command:</p>
<div class="ind">
<pre><code>@Or.intro_left : ∀ {a : Prop} (b : Prop), a → a ∨ b

@Or.inl : ∀ {a b : Prop}, a → a ∨ b</code></pre>
</div>
<p>Notice that <code>b</code> is an implicit argument in <code>Or.inl</code>, but not in <code>Or.intro_left</code>.</p>
<p>Similarly, if you have <code>h : Q</code>, then <code>Or.intro_right P h</code> is a proof of <code>P ∨ Q</code>. In most situations Lean can infer <code>P</code> from context, and you can use the shorter form <code>Or.inr h</code>.</p>
<p>Often, when your goal has the form <code>P ∨ Q</code>, you will be unable to prove <code>P</code>, and also unable to prove <code>Q</code>. Proof by cases can help in that situation as well (<em>HTPI</em> p.&nbsp;145).</p>
</section>
<section id="to-prove-a-goal-of-the-form-p-q-3" class="level4">
<h4 class="anchored" data-anchor-id="to-prove-a-goal-of-the-form-p-q-3">To prove a goal of the form <code>P ∨ Q</code>:</h4>
<div class="ind">
<p>Break your proof into cases. In each case, either prove <code>P</code> or prove <code>Q</code>.</p>
</div>
<p>Example 3.5.2 from <em>HTPI</em> illustrates these strategies:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb155"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_5_2</span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a>    (U : <span class="kw">Type</span>) (A B C : Set U) :</span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a>    A \ (B \ C) ⊆ (A \ B) ∪ C := <span class="kw">by</span></span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb155-5"><a href="#cb155-5" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb156"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a>⊢ A \ (B \ C) ⊆ A \ B ∪ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The <code>define</code> tactic would rewrite the goal as <code>∀ ⦃a : U⦄, a ∈ A \ (B \ C) → a ∈ A \ B ∪ C</code>, which suggests that our next two tactics should be <code>fix x : U</code> and <code>assume h1 : x ∈ A \ (B \ C)</code>. But as we have seen before, if you know what the result of the <code>define</code> tactic is going to be, then there is usually no need to use it. After introducing <code>x</code> as an arbitrary element of <code>A \ (B \ C)</code>, we write out the definitions of our new given and goal to help guide our next strategy choice:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb157"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_5_2</span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a>    (U : <span class="kw">Type</span>) (A B C : Set U) :</span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a>    A \ (B \ C) ⊆ (A \ B) ∪ C := <span class="kw">by</span></span>
<span id="cb157-4"><a href="#cb157-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb157-5"><a href="#cb157-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : x ∈ A \ (B \ C)</span>
<span id="cb157-6"><a href="#cb157-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>; <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb157-7"><a href="#cb157-7" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb158"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: x ∈ A ∧ x ∉ B \ C</span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ A \ B ∨ x ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The goal is now a disjunction, which suggests that proof by cases might be helpful. But what cases should we use? The key is to look at the meaning of the right half of the given <code>h1</code>. The meaning of <code>x ∉ B \ C</code> is <code>¬(x ∈ B ∧ x ∉ C)</code>, which, by one of the De Morgan laws, is equivalent to <code>x ∉ B ∨ x ∈ C</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb159"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_5_2</span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a>    (U : <span class="kw">Type</span>) (A B C : Set U) :</span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a>    A \ (B \ C) ⊆ (A \ B) ∪ C := <span class="kw">by</span></span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb159-5"><a href="#cb159-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : x ∈ A \ (B \ C)</span>
<span id="cb159-6"><a href="#cb159-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>; <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb159-7"><a href="#cb159-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : x ∉ B \ C := h1.right</span>
<span id="cb159-8"><a href="#cb159-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2; <span class="kw">demorgan</span> <span class="kw">at</span> h2</span>
<span id="cb159-9"><a href="#cb159-9" aria-hidden="true" tabindex="-1"></a>            <span class="co">--h2 : x ∉ B ∨ x ∈ C</span></span>
<span id="cb159-10"><a href="#cb159-10" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb160"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: x ∈ A ∧ x ∉ B \ C</span>
<span id="cb160-5"><a href="#cb160-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: x ∉ B ∨ x ∈ C</span>
<span id="cb160-6"><a href="#cb160-6" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ A \ B ∨ x ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The new given <code>h2</code> is now a disjunction, which suggests what cases we should use:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb161"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_5_2</span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>    (U : <span class="kw">Type</span>) (A B C : Set U) :</span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>    A \ (B \ C) ⊆ (A \ B) ∪ C := <span class="kw">by</span></span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : x ∈ A \ (B \ C)</span>
<span id="cb161-6"><a href="#cb161-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>; <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb161-7"><a href="#cb161-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : x ∉ B \ C := h1.right</span>
<span id="cb161-8"><a href="#cb161-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2; <span class="kw">demorgan</span> <span class="kw">at</span> h2</span>
<span id="cb161-9"><a href="#cb161-9" aria-hidden="true" tabindex="-1"></a>            <span class="co">--h2 : x ∉ B ∨ x ∈ C</span></span>
<span id="cb161-10"><a href="#cb161-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> <span class="kw">on</span> h2</span>
<span id="cb161-11"><a href="#cb161-11" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb162"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> Case_1</span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb162-5"><a href="#cb162-5" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: x ∈ A ∧ x ∉ B \ C</span>
<span id="cb162-6"><a href="#cb162-6" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: x ∉ B</span>
<span id="cb162-7"><a href="#cb162-7" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ A \ B ∨ x ∈ C</span>
<span id="cb162-8"><a href="#cb162-8" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> Case_2</span>
<span id="cb162-9"><a href="#cb162-9" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb162-10"><a href="#cb162-10" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb162-11"><a href="#cb162-11" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb162-12"><a href="#cb162-12" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: x ∈ A ∧ x ∉ B \ C</span>
<span id="cb162-13"><a href="#cb162-13" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: x ∈ C</span>
<span id="cb162-14"><a href="#cb162-14" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ A \ B ∨ x ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Of course, now that we have two goals, we will introduce bullets labeling the two parts of the proof as case 1 and case 2. Looking at the givens <code>h1</code> and <code>h2</code> in both cases, it is not hard to see that we should be able to prove <code>x ∈ A \ B</code> in case 1 and <code>x ∈ C</code> in case 2. Thus, in case 1 we will be able to give a proof of the goal that has the form <code>Or.inl _</code>, where the blank will be filled in with a proof of <code>x ∈ A \ B</code>, and in case 2 we can use <code>Or.inr _</code>, filling in the blank with a proof of <code>x ∈ C</code>. This suggests that we should use the tactics <code>apply Or.inl</code> in case 1 and <code>apply Or.inr</code> in case 2. Focusing first on case 1, we get:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb163"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_5_2</span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a>    (U : <span class="kw">Type</span>) (A B C : Set U) :</span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a>    A \ (B \ C) ⊆ (A \ B) ∪ C := <span class="kw">by</span></span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb163-5"><a href="#cb163-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : x ∈ A \ (B \ C)</span>
<span id="cb163-6"><a href="#cb163-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>; <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb163-7"><a href="#cb163-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : x ∉ B \ C := h1.right</span>
<span id="cb163-8"><a href="#cb163-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2; <span class="kw">demorgan</span> <span class="kw">at</span> h2</span>
<span id="cb163-9"><a href="#cb163-9" aria-hidden="true" tabindex="-1"></a>            <span class="co">--h2 : x ∉ B ∨ x ∈ C</span></span>
<span id="cb163-10"><a href="#cb163-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> <span class="kw">on</span> h2</span>
<span id="cb163-11"><a href="#cb163-11" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h2 : x ∉ B</span></span>
<span id="cb163-12"><a href="#cb163-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Or.inl</span>
<span id="cb163-13"><a href="#cb163-13" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb163-14"><a href="#cb163-14" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h2 : x ∈ C</span></span>
<span id="cb163-15"><a href="#cb163-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-16"><a href="#cb163-16" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb163-17"><a href="#cb163-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb164"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> Case_1.h</span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb164-5"><a href="#cb164-5" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: x ∈ A ∧ x ∉ B \ C</span>
<span id="cb164-6"><a href="#cb164-6" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: x ∉ B</span>
<span id="cb164-7"><a href="#cb164-7" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ A \ B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Notice that the tactic <code>apply Or.inl</code> has changed the goal for case 1 to the left half of the original goal, <code>x ∈ A \ B</code>. Since this means <code>x ∈ A ∧ x ∉ B</code>, we can complete case 1 by combining <code>h1.left</code> with <code>h2</code>, and then we can move on to case 2.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb165"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_5_2</span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a>    (U : <span class="kw">Type</span>) (A B C : Set U) :</span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a>    A \ (B \ C) ⊆ (A \ B) ∪ C := <span class="kw">by</span></span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb165-5"><a href="#cb165-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : x ∈ A \ (B \ C)</span>
<span id="cb165-6"><a href="#cb165-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>; <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb165-7"><a href="#cb165-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : x ∉ B \ C := h1.right</span>
<span id="cb165-8"><a href="#cb165-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2; <span class="kw">demorgan</span> <span class="kw">at</span> h2</span>
<span id="cb165-9"><a href="#cb165-9" aria-hidden="true" tabindex="-1"></a>            <span class="co">--h2 : x ∉ B ∨ x ∈ C</span></span>
<span id="cb165-10"><a href="#cb165-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> <span class="kw">on</span> h2</span>
<span id="cb165-11"><a href="#cb165-11" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h2 : x ∉ B</span></span>
<span id="cb165-12"><a href="#cb165-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Or.inl</span>
<span id="cb165-13"><a href="#cb165-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> x ∈ A \ B <span class="kw">from</span> And.intro h1.left h2</span>
<span id="cb165-14"><a href="#cb165-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb165-15"><a href="#cb165-15" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h2 : x ∈ C</span></span>
<span id="cb165-16"><a href="#cb165-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-17"><a href="#cb165-17" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb165-18"><a href="#cb165-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb166"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> Case_2</span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb166-5"><a href="#cb166-5" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: x ∈ A ∧ x ∉ B \ C</span>
<span id="cb166-6"><a href="#cb166-6" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: x ∈ C</span>
<span id="cb166-7"><a href="#cb166-7" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ A \ B ∨ x ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Case 2 is similar, using <code>Or.inr</code> and <code>h2</code></p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb167"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_5_2</span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a>    (U : <span class="kw">Type</span>) (A B C : Set U) :</span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a>    A \ (B \ C) ⊆ (A \ B) ∪ C := <span class="kw">by</span></span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb167-5"><a href="#cb167-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : x ∈ A \ (B \ C)</span>
<span id="cb167-6"><a href="#cb167-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>; <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb167-7"><a href="#cb167-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : x ∉ B \ C := h1.right</span>
<span id="cb167-8"><a href="#cb167-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2; <span class="kw">demorgan</span> <span class="kw">at</span> h2</span>
<span id="cb167-9"><a href="#cb167-9" aria-hidden="true" tabindex="-1"></a>            <span class="co">--h2 : x ∉ B ∨ x ∈ C</span></span>
<span id="cb167-10"><a href="#cb167-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> <span class="kw">on</span> h2</span>
<span id="cb167-11"><a href="#cb167-11" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h2 : x ∉ B</span></span>
<span id="cb167-12"><a href="#cb167-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Or.inl</span>
<span id="cb167-13"><a href="#cb167-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> x ∈ A \ B <span class="kw">from</span> And.intro h1.left h2</span>
<span id="cb167-14"><a href="#cb167-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb167-15"><a href="#cb167-15" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h2 : x ∈ C</span></span>
<span id="cb167-16"><a href="#cb167-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Or.inr</span>
<span id="cb167-17"><a href="#cb167-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> x ∈ C <span class="kw">from</span> h2</span>
<span id="cb167-18"><a href="#cb167-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb167-19"><a href="#cb167-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb168"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a><span class="ss">No</span><span class="in"> </span><span class="ss">goals</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>There is a second strategy that is often useful to prove a goal of the form <code>P ∨ Q</code>. It is motivated by the fact that <code>P ∨ Q</code> is equivalent to both <code>¬P → Q</code> and <code>¬Q → P</code> (<em>HTPI</em> p.&nbsp;147).</p>
</section>
<section id="to-prove-a-goal-of-the-form-p-q-4" class="level4">
<h4 class="anchored" data-anchor-id="to-prove-a-goal-of-the-form-p-q-4">To prove a goal of the form <code>P ∨ Q</code>:</h4>
<div class="ind">
<p>Assume that <code>P</code> is false and prove <code>Q</code>, or assume that <code>Q</code> is false and prove <code>P</code>.</p>
</div>
<p>If your goal is <code>P ∨ Q</code>, then the Lean tactic <code>or_left with h</code> will add the new given <code>h : ¬Q</code> to the tactic state and set the goal to be <code>P</code>, and <code>or_right with h</code> will add <code>h : ¬P</code> to the tactic state and set the goal to be <code>Q</code>. For example, here is the effect of the tactic <code>or_left with h</code>:</p>
<div class="lftrt">
<div class="bef">
<div class="sourceCode" id="cb169"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span> ⋮</span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a>⊢ P ∨ Q</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="aft">
<div class="sourceCode" id="cb170"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span> ⋮</span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a><span class="in">h </span>: ¬Q</span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true" tabindex="-1"></a>⊢ P</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Notice that <code>or_left</code> and <code>or_right</code> have the same effect as <code>apply Or.inl</code> and <code>apply Or.inr</code>, except that each adds a new given to the tactic state. Sometimes you can tell in advance that you won’t need the extra given, and in that case the tactics <code>apply Or.inl</code> and <code>apply Or.inr</code> can be useful. For example, that was the case in the example above. But if you think the extra given might be useful, you are better off using <code>or_left</code> or <code>or_right</code>. Here’s an example illustrating this.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb171"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (A B C : Set U)</span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a>    (h1 : A \ B ⊆ C) : A ⊆ B ∪ C := <span class="kw">by</span></span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb171-4"><a href="#cb171-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb172"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A \ B ⊆ C</span>
<span id="cb172-4"><a href="#cb172-4" aria-hidden="true" tabindex="-1"></a>⊢ A ⊆ B ∪ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Of course, we begin by letting <code>x</code> be an arbitrary element of <code>A</code>. Writing out the meaning of the new goal shows that it is a disjunction.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb173"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (A B C : Set U)</span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a>    (h1 : A \ B ⊆ C) : A ⊆ B ∪ C := <span class="kw">by</span></span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb173-4"><a href="#cb173-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : x ∈ A</span>
<span id="cb173-5"><a href="#cb173-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb173-6"><a href="#cb173-6" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb174"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A \ B ⊆ C</span>
<span id="cb174-4"><a href="#cb174-4" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb174-5"><a href="#cb174-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: x ∈ A</span>
<span id="cb174-6"><a href="#cb174-6" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ B ∨ x ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Looking at the givens <code>h1</code> and <code>h2</code>, we see that if we assume <code>x ∉ B</code>, then we should be able to prove <code>x ∈ C</code>. This suggests that we should use the <code>or_right</code> tactic.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb175"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (A B C : Set U)</span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a>    (h1 : A \ B ⊆ C) : A ⊆ B ∪ C := <span class="kw">by</span></span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : x ∈ A</span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb175-6"><a href="#cb175-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">or_right</span> <span class="kw">with</span> h3</span>
<span id="cb175-7"><a href="#cb175-7" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb176"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A \ B ⊆ C</span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb176-5"><a href="#cb176-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: x ∈ A</span>
<span id="cb176-6"><a href="#cb176-6" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: x ∉ B</span>
<span id="cb176-7"><a href="#cb176-7" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>We can now complete the proof. Notice that <code>h1 _</code> will be a proof of the goal <code>x ∈ C</code>, if we can fill in the blank with a proof of <code>x ∈ A \ B</code>. Since <code>x ∈ A \ B</code> means <code>x ∈ A ∧ x ∉ B</code>, we can prove it with the expression <code>And.intro h2 h3</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb177"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U : <span class="kw">Type</span>) (A B C : Set U)</span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a>    (h1 : A \ B ⊆ C) : A ⊆ B ∪ C := <span class="kw">by</span></span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : x ∈ A</span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb177-6"><a href="#cb177-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">or_right</span> <span class="kw">with</span> h3</span>
<span id="cb177-7"><a href="#cb177-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> x ∈ C <span class="kw">from</span> h1 (And.intro h2 h3)</span>
<span id="cb177-8"><a href="#cb177-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb178"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a><span class="ss">No</span><span class="in"> </span><span class="ss">goals</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The fact that <code>P ∨ Q</code> is equivalent to both <code>¬P → Q</code> and <code>¬Q → P</code> also suggests another strategy for using a given that is a disjunction (<em>HTPI</em> p.&nbsp;149).</p>
</section>
<section id="to-use-a-given-of-the-form-p-q-4" class="level4">
<h4 class="anchored" data-anchor-id="to-use-a-given-of-the-form-p-q-4">To use a given of the form <code>P ∨ Q</code>:</h4>
<div class="ind">
<p>If you are also given <code>¬P</code>, or you can prove that <code>P</code> is false, then you can use this given to conclude that <code>Q</code> is true. Similarly, if you are given <code>¬Q</code> or can prove that <code>Q</code> is false, then you can conclude that <code>P</code> is true.</p>
</div>
<p>This strategy is a rule of inference called <em>disjunctive syllogism</em>, and the tactic for using this strategy in Lean is called <code>disj_syll</code>. If you have <code>h1 : P ∨ Q</code> and <code>h2 : ¬P</code>, then the tactic <code>disj_syll h1 h2</code> will change <code>h1</code> to <code>h1 : Q</code>; if instead you have <code>h2 : ¬Q</code>, then <code>disj_syll h1 h2</code> will change <code>h1</code> to <code>h1 : P</code>. Notice that, as with the <code>by_cases</code> tactic, the given <code>h1</code> gets <em>replaced</em> with the conclusion of the rule. The tactic <code>disj_syll h1 h2 with h3</code> will preserve the original <code>h1</code> and introduce the conclusion as a new given with the identifier <code>h3</code>. Also, as with the <code>by_cases</code> tactic, either <code>h1</code> or <code>h2</code> can be a complex proof rather than simply an identifier (although in that case it must be enclosed in parentheses, so that Lean can tell where <code>h1</code> ends and <code>h2</code> begins). The only requirement is that <code>h1</code> must be a proof of a disjunction, and <code>h2</code> must be a proof of the negation of one side of the disjunction. If <code>h1</code> is not simply an identifier, then you will want to use <code>with</code> to specify the identifier to be used for the conclusion of the rule.</p>
<p>Here’s an example illustrating the use of the disjunctive syllogism rule.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb179"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span></span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a>    (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ¬∃ (x : U), x ∈ A ∩ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb179-4"><a href="#cb179-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-5"><a href="#cb179-5" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb180"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B ∪ C</span>
<span id="cb180-4"><a href="#cb180-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬∃ (x : U),</span>
<span id="cb180-5"><a href="#cb180-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  x ∈ A ∩ B</span>
<span id="cb180-6"><a href="#cb180-6" aria-hidden="true" tabindex="-1"></a>⊢ A ⊆ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Of course, we begin by introducing an arbitrary element of <code>A</code>. We also rewrite <code>h2</code> as an equivalent positive statement.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb181"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span></span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a>    (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ¬∃ (x : U), x ∈ A ∩ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb181-4"><a href="#cb181-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : U</span>
<span id="cb181-5"><a href="#cb181-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : a ∈ A</span>
<span id="cb181-6"><a href="#cb181-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">quant_neg</span> <span class="kw">at</span> h2</span>
<span id="cb181-7"><a href="#cb181-7" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb182"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb182-3"><a href="#cb182-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B ∪ C</span>
<span id="cb182-4"><a href="#cb182-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ (x : U),</span>
<span id="cb182-5"><a href="#cb182-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  x ∉ A ∩ B</span>
<span id="cb182-6"><a href="#cb182-6" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb182-7"><a href="#cb182-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: a ∈ A</span>
<span id="cb182-8"><a href="#cb182-8" aria-hidden="true" tabindex="-1"></a>⊢ a ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>We can now make two inferences by combining <code>h1</code> with <code>h3</code> and by applying <code>h2</code> to <code>a</code>. To see how to use the inferred statements, we write out their definitions, and since one of them is a negative statement, we reexpress it as an equivalent positive statement.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb183"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span></span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a>    (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ¬∃ (x : U), x ∈ A ∩ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb183-4"><a href="#cb183-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : U</span>
<span id="cb183-5"><a href="#cb183-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : a ∈ A</span>
<span id="cb183-6"><a href="#cb183-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">quant_neg</span> <span class="kw">at</span> h2</span>
<span id="cb183-7"><a href="#cb183-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : a ∈ B ∪ C := h1 h3</span>
<span id="cb183-8"><a href="#cb183-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : a ∉ A ∩ B := h2 a</span>
<span id="cb183-9"><a href="#cb183-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h4</span>
<span id="cb183-10"><a href="#cb183-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h5; <span class="kw">demorgan</span> <span class="kw">at</span> h5</span>
<span id="cb183-11"><a href="#cb183-11" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb184"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B ∪ C</span>
<span id="cb184-4"><a href="#cb184-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ (x : U),</span>
<span id="cb184-5"><a href="#cb184-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  x ∉ A ∩ B</span>
<span id="cb184-6"><a href="#cb184-6" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb184-7"><a href="#cb184-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: a ∈ A</span>
<span id="cb184-8"><a href="#cb184-8" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: a ∈ B ∨ a ∈ C</span>
<span id="cb184-9"><a href="#cb184-9" aria-hidden="true" tabindex="-1"></a><span class="in">h5 </span>: a ∉ A ∨ a ∉ B</span>
<span id="cb184-10"><a href="#cb184-10" aria-hidden="true" tabindex="-1"></a>⊢ a ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Both <code>h4</code> and <code>h5</code> are disjunctions, and looking at <code>h3</code> we see that the disjunctive syllogism rule can be applied. From <code>h3</code> and <code>h5</code> we can draw the conclusion <code>a ∉ B</code>, and then combining that conclusion with <code>h4</code> we can infer <code>a ∈ C</code>. Since that is the goal, we are done.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb185"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span></span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a>    (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb185-3"><a href="#cb185-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ¬∃ (x : U), x ∈ A ∩ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb185-4"><a href="#cb185-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : U</span>
<span id="cb185-5"><a href="#cb185-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : a ∈ A</span>
<span id="cb185-6"><a href="#cb185-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">quant_neg</span> <span class="kw">at</span> h2</span>
<span id="cb185-7"><a href="#cb185-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : a ∈ B ∪ C := h1 h3</span>
<span id="cb185-8"><a href="#cb185-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : a ∉ A ∩ B := h2 a</span>
<span id="cb185-9"><a href="#cb185-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h4</span>
<span id="cb185-10"><a href="#cb185-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h5; <span class="kw">demorgan</span> <span class="kw">at</span> h5</span>
<span id="cb185-11"><a href="#cb185-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">disj_syll</span> h5 h3  <span class="co">--h5 : a ∉ B</span></span>
<span id="cb185-12"><a href="#cb185-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">disj_syll</span> h4 h5  <span class="co">--h4 : a ∈ C</span></span>
<span id="cb185-13"><a href="#cb185-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a ∈ C <span class="kw">from</span> h4</span>
<span id="cb185-14"><a href="#cb185-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb186"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a><span class="ss">No</span><span class="in"> </span><span class="ss">goals</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>We’re going to redo the last example, to illustrate another useful technique in Lean. We start with some of the same steps as before.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb187"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span></span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a>    (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ¬∃ (x : U), x ∈ A ∩ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb187-4"><a href="#cb187-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : U</span>
<span id="cb187-5"><a href="#cb187-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : a ∈ A</span>
<span id="cb187-6"><a href="#cb187-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : a ∈ B ∪ C := h1 h3</span>
<span id="cb187-7"><a href="#cb187-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h4</span>
<span id="cb187-8"><a href="#cb187-8" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb188"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb188-3"><a href="#cb188-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B ∪ C</span>
<span id="cb188-4"><a href="#cb188-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬∃ (x : U),</span>
<span id="cb188-5"><a href="#cb188-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  x ∈ A ∩ B</span>
<span id="cb188-6"><a href="#cb188-6" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb188-7"><a href="#cb188-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: a ∈ A</span>
<span id="cb188-8"><a href="#cb188-8" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: a ∈ B ∨ a ∈ C</span>
<span id="cb188-9"><a href="#cb188-9" aria-hidden="true" tabindex="-1"></a>⊢ a ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>At this point, you might see a possible route to the goal: from <code>h2</code> and <code>h3</code> we should be able to prove that <code>a ∉ B</code>, and then, combining that with <code>h4</code> by the disjunctive syllogism rule, we should be able to deduce the goal <code>a ∈ C</code>. Let’s try writing the proof that way.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb189"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a><span class="sc">??</span><span class="an">example</span><span class="sc">::</span></span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a>    (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ¬∃ (x : U), x ∈ A ∩ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb189-4"><a href="#cb189-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : U</span>
<span id="cb189-5"><a href="#cb189-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : a ∈ A</span>
<span id="cb189-6"><a href="#cb189-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : a ∈ B ∪ C := h1 h3</span>
<span id="cb189-7"><a href="#cb189-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h4</span>
<span id="cb189-8"><a href="#cb189-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : a ∉ B := <span class="cn">sorry</span></span>
<span id="cb189-9"><a href="#cb189-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">disj_syll</span> h4 h5  <span class="co">--h4 : a ∈ C</span></span>
<span id="cb189-10"><a href="#cb189-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a ∈ C <span class="kw">from</span> h4</span>
<span id="cb189-11"><a href="#cb189-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb190"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a><span class="ss">No</span><span class="in"> </span><span class="ss">goals</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>We have introduced a new idea in this proof. The justification we have given for introducing <code>h5 : a ∉ B</code> is <code>sorry</code>. You might think of this as meaning “Sorry, I’m not going to give a justification for this statement, but please accept it anyway.” Of course, this is cheating; in a complete proof, every step must be justified. Lean accepts <code>sorry</code> as a proof of any statement, but it displays it in red to warn you that you’re cheating. It also puts a brown squiggle under the keyword <code>example</code> and it puts the message <code>declaration uses 'sorry'</code> in the Infoview, to warn you that, although the proof has reached the goal, it is not fully justified.</p>
<p>Although writing the proof this way is cheating, it is a convenient way to see that our plan of attack for this proof is reasonable. Lean has accepted the proof, except for the warning that we have used <code>sorry</code>. So now we know that if we go back and replace <code>sorry</code> with a proof of <code>a ∉ B</code>, then we will have a complete proof.</p>
<p>The proof of <code>a ∉ B</code> is hard enough that it is easier to do it in tactic mode rather than term mode. So we will begin the proof as we always do for tactic-mode proofs: we replace <code>sorry</code> with <code>by</code>, leave a blank line, and then put <code>done</code>, indented further than the surrounding text. When we put the cursor on the blank line before <code>done</code>, we see the tactic state for our “proof within a proof.”</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb191"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span></span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a>    (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb191-3"><a href="#cb191-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ¬∃ (x : U), x ∈ A ∩ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb191-4"><a href="#cb191-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : U</span>
<span id="cb191-5"><a href="#cb191-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : a ∈ A</span>
<span id="cb191-6"><a href="#cb191-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : a ∈ B ∪ C := h1 h3</span>
<span id="cb191-7"><a href="#cb191-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h4</span>
<span id="cb191-8"><a href="#cb191-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : a ∉ B := <span class="kw">by</span></span>
<span id="cb191-9"><a href="#cb191-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-10"><a href="#cb191-10" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb191-11"><a href="#cb191-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">disj_syll</span> h4 h5  <span class="co">--h4 : a ∈ C</span></span>
<span id="cb191-12"><a href="#cb191-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a ∈ C <span class="kw">from</span> h4</span>
<span id="cb191-13"><a href="#cb191-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb192"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B ∪ C</span>
<span id="cb192-4"><a href="#cb192-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬∃ (x : U),</span>
<span id="cb192-5"><a href="#cb192-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  x ∈ A ∩ B</span>
<span id="cb192-6"><a href="#cb192-6" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb192-7"><a href="#cb192-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: a ∈ A</span>
<span id="cb192-8"><a href="#cb192-8" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: a ∈ B ∨ a ∈ C</span>
<span id="cb192-9"><a href="#cb192-9" aria-hidden="true" tabindex="-1"></a>⊢ a ∉ B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Note that <code>h5 : a ∉ B</code> is not a given in the tactic state, because we have not yet justified it; in fact, <code>a ∉ B</code> is the goal. This goal is a negative statement, and <code>h2</code> is also negative. This suggests that we could try using proof by contradiction, achieving the contradiction by contradicting <code>h2</code>. So we use the tactic <code>contradict h2 with h6</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb193"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span></span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a>    (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ¬∃ (x : U), x ∈ A ∩ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : U</span>
<span id="cb193-5"><a href="#cb193-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : a ∈ A</span>
<span id="cb193-6"><a href="#cb193-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : a ∈ B ∪ C := h1 h3</span>
<span id="cb193-7"><a href="#cb193-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h4</span>
<span id="cb193-8"><a href="#cb193-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : a ∉ B := <span class="kw">by</span></span>
<span id="cb193-9"><a href="#cb193-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">contradict</span> h2 <span class="kw">with</span> h6</span>
<span id="cb193-10"><a href="#cb193-10" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb193-11"><a href="#cb193-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">disj_syll</span> h4 h5  <span class="co">--h4 : a ∈ C</span></span>
<span id="cb193-12"><a href="#cb193-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a ∈ C <span class="kw">from</span> h4</span>
<span id="cb193-13"><a href="#cb193-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb194"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: A ⊆ B ∪ C</span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ¬∃ (x : U),</span>
<span id="cb194-5"><a href="#cb194-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  x ∈ A ∩ B</span>
<span id="cb194-6"><a href="#cb194-6" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb194-7"><a href="#cb194-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: a ∈ A</span>
<span id="cb194-8"><a href="#cb194-8" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: a ∈ B ∨ a ∈ C</span>
<span id="cb194-9"><a href="#cb194-9" aria-hidden="true" tabindex="-1"></a><span class="in">h6 </span>: a ∈ B</span>
<span id="cb194-10"><a href="#cb194-10" aria-hidden="true" tabindex="-1"></a>⊢ ∃ (x : U), x ∈ A ∩ B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Looking at <code>h3</code> and <code>h6</code>, we see that the right value to plug in for <code>x</code> in the goal is <code>a</code>. In fact, <code>Exists.intro a _</code> will prove the goal, if we can fill in the blank with a proof of <code>a ∈ A ∩ B</code>. Since this means <code>a ∈ A ∧ a ∈ B</code>, we can prove it with <code>And.intro h3 h6</code>. Thus, we can complete the proof in one more step:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb195"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span></span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a>    (U : <span class="kw">Type</span>) (A B C : Set U) (h1 : A ⊆ B ∪ C)</span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ¬∃ (x : U), x ∈ A ∩ B) : A ⊆ C := <span class="kw">by</span></span>
<span id="cb195-4"><a href="#cb195-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : U</span>
<span id="cb195-5"><a href="#cb195-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : a ∈ A</span>
<span id="cb195-6"><a href="#cb195-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : a ∈ B ∪ C := h1 h3</span>
<span id="cb195-7"><a href="#cb195-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h4</span>
<span id="cb195-8"><a href="#cb195-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : a ∉ B := <span class="kw">by</span></span>
<span id="cb195-9"><a href="#cb195-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">contradict</span> h2 <span class="kw">with</span> h6</span>
<span id="cb195-10"><a href="#cb195-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ∃ (x : U), x ∈ A ∩ B <span class="kw">from</span></span>
<span id="cb195-11"><a href="#cb195-11" aria-hidden="true" tabindex="-1"></a>      Exists.intro a (And.intro h3 h6)</span>
<span id="cb195-12"><a href="#cb195-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb195-13"><a href="#cb195-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">disj_syll</span> h4 h5  <span class="co">--h4 : a ∈ C</span></span>
<span id="cb195-14"><a href="#cb195-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a ∈ C <span class="kw">from</span> h4</span>
<span id="cb195-15"><a href="#cb195-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb196"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a><span class="ss">No</span><span class="in"> </span><span class="ss">goals</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The red squiggle has disappeared from the word <code>done</code>, indicating that the proof is complete.</p>
<p>It was not really necessary for us to use <code>sorry</code> when writing this proof. We could have simply written the steps in order, exactly as they appear above. Any time you use the <code>have</code> tactic with a conclusion that is difficult to justify, you have a choice. You can establish the <code>have</code> with <code>sorry</code>, complete the proof, and then return and fill in a justification for the <code>have</code>, as we did in the example above. Or, you can justify the <code>have</code> right away by typing <code>by</code> after <code>:=</code> and then plunging into the “proof within in a proof.” Once you complete the inner proof, you can continue with the original proof.</p>
<p>And in case you were wondering: yes, if the inner proof uses the <code>have</code> tactic with a statement that is hard to justify, then you can write a “proof within a proof within a proof”!</p>
</section>
<section id="exercises-3" class="level3">
<h3 class="anchored" data-anchor-id="exercises-3">Exercises</h3>
<p>In each case, replace <code>sorry</code> with a proof.</p>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb197"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_5_2 (U : <span class="kw">Type</span>) (A B C : Set U) :</span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a>    (A ∪ B) \ C ⊆ A ∪ (B \ C) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb198"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_5_5 (U : <span class="kw">Type</span>) (A B C : Set U)</span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true" tabindex="-1"></a>    (h1 : A ∩ C ⊆ B ∩ C) (h2 : A ∪ C ⊆ B ∪ C) : A ⊆ B := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb199"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_5_7 (U : <span class="kw">Type</span>) (A B C : Set U) :</span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true" tabindex="-1"></a>    A ∪ C ⊆ B ∪ C ↔ A \ C ⊆ B \ C := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb200"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_5_8 (U : <span class="kw">Type</span>) (A B : Set U) :</span>
<span id="cb200-2"><a href="#cb200-2" aria-hidden="true" tabindex="-1"></a>    𝒫 A ∪ 𝒫 B ⊆ 𝒫 (A ∪ B) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb201"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_5_17b (U : <span class="kw">Type</span>) (F : Set (Set U)) (B : Set U) :</span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a>    B ∪ (⋂₀ F) = { x : U | ∀ (A : Set U), A ∈ F → x ∈ B ∪ A } := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="6">
<div class="sourceCode" id="cb202"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_5_18 (U : <span class="kw">Type</span>) (F G H : Set (Set U))</span>
<span id="cb202-2"><a href="#cb202-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (A : Set U), A ∈ F → ∀ (B : Set U), B ∈ G → A ∪ B ∈ H) :</span>
<span id="cb202-3"><a href="#cb202-3" aria-hidden="true" tabindex="-1"></a>    ⋂₀ H ⊆ (⋂₀ F) ∪ (⋂₀ G) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="7">
<div class="sourceCode" id="cb203"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_5_24a (U : <span class="kw">Type</span>) (A B C : Set U) :</span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true" tabindex="-1"></a>    (A ∪ B) △ C ⊆ (A △ C) ∪ (B △ C) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="existence-and-uniqueness-proofs" class="level2">
<h2 class="anchored" data-anchor-id="existence-and-uniqueness-proofs">3.6. Existence and Uniqueness Proofs</h2>
<p>Recall that <code>∃! (x : U), P x</code> means that there is exactly one <code>x</code> of type <code>U</code> such that <code>P x</code> is true. One way to deal with a given or goal of this form is to use the <code>define</code> tactic to rewrite it as the equivalent statement <code>∃ (x : U), P x ∧ ∀ (x_1 : U), P x_1 → x_1 = x</code>. You can then apply techniques discussed previously in this chapter. However, there are also proof techniques, and corresponding Lean tactics, for working directly with givens and goals of this form.</p>
<p>Often a goal of the form <code>∃! (x : U), P x</code> is proven by using the following strategy. This is a slight rephrasing of the strategy presented in <em>HTPI</em>. The rephrasing is based on the fact that for any propositions <code>A</code>, <code>B</code>, and <code>C</code>, <code>A ∧ B → C</code> is equivalent to <code>A → B → C</code> (you can check this equivalence by making a truth table). The second of these statements is usually easier to work with in Lean than the first one, so we will often rephrase statements that have the form <code>A ∧ B → C</code> as <code>A → B → C</code>. To see why the second statement is easier to use, suppose that you have givens <code>hA : A</code> and <code>hB : B</code>. If you also have <code>h : A → B → C</code>, then <code>h hA</code> is a proof of <code>B → C</code>, and therefore <code>h hA hB</code> is a proof of <code>C</code>. If instead you had <code>h' : (A ∧ B) → C</code>, then to prove <code>C</code> you would have to write <code>h' (And.intro hA hB)</code>, which is a bit less convenient.</p>
<p>With that preparation, here is our strategy for proving statements of the form <code>∃! (x : U), P x</code> (<em>HTPI</em> pp.&nbsp;156–157).</p>
<section id="to-prove-a-goal-of-the-form-x-u-p-x-2" class="level4">
<h4 class="anchored" data-anchor-id="to-prove-a-goal-of-the-form-x-u-p-x-2">To prove a goal of the form <code>∃! (x : U), P x</code>:</h4>
<div class="ind">
<p>Prove <code>∃ (x : U), P x</code> and <code>∀ (x_1 x_2 : U), P x_1 → P x_2 → x_1 = x_2</code>. The first of these goals says that there exists an <code>x</code> such that <code>P x</code> is true, and the second says that it is unique. The two parts of the proof are therefore sometimes labeled <em>existence</em> and <em>uniqueness</em>.</p>
</div>
<p>To apply this strategy in a Lean proof, we use the tactic <code>exists_unique</code>. We’ll illustrate this with the theorem from Example 3.6.2 in <em>HTPI</em>. Here’s how that theorem and its proof are presented in <em>HTPI</em> (<em>HTPI</em> pp.&nbsp;157–158):</p>
<div class="thm">
<p>There is a unique set <span class="math inline">\(A\)</span> such that for every set <span class="math inline">\(B\)</span>, <span class="math inline">\(A \cup B = B\)</span>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Existence: Clearly <span class="math inline">\(\forall B(\varnothing \cup B = B)\)</span>, so <span class="math inline">\(\varnothing\)</span> has the required property.</p>
<p>Uniqueness: Suppose <span class="math inline">\(\forall B(C \cup B = B)\)</span> and <span class="math inline">\(\forall B(D \cup B = B)\)</span>. Applying the first of these assumptions to <span class="math inline">\(D\)</span> we see that <span class="math inline">\(C \cup D = D\)</span>, and applying the second to <span class="math inline">\(C\)</span> we get <span class="math inline">\(D \cup C = C\)</span>. But clearly <span class="math inline">\(C \cup D = D \cup C\)</span>, so <span class="math inline">\(C = D\)</span>. <span class="excl">&nbsp;□</span></p>
</div>
<p>You will notice that there are two statements in this proof that are described as “clearly” true. This brings up one of the difficulties with proving theorems in Lean: things that are clear to <em>us</em> are not necessarily clear to <em>Lean</em>! There are two ways to deal with such “clear” statements. The first is to see if the statement is in the library of theorems that Lean knows. The second is to prove the statement as a preliminary theorem that can then be used in the proof of our main theorem. We’ll take the second approach here, since proving these “clear” facts will give us more practice with Lean proofs, but later we’ll have more to say about searching for statements in Lean’s theorem library.</p>
<p>The first theorem we need says that for every set <code>B</code>, <code>∅ ∪ B = B</code>, and it brings up a subtle issue: in Lean, the symbol <code>∅</code> is ambiguous! The reason for this is Lean’s strict typing rules. For each type <code>U</code>, there is an empty set of type <code>Set U</code>. There is, for example, the set of type <code>Set Nat</code> that contains no natural numbers, and also the set of type <code>Set Real</code> that contains no real numbers. To Lean, these are different sets, because they have different types. Which one does the symbol <code>∅</code> denote? The answer will be different in different contexts. Lean can often figure out from context which empty set you have in mind, but if it can’t, then you have to tell it explicitly by writing <code>(∅ : Set U)</code> rather than <code>∅</code>. Fortunately, in our theorems Lean is able to figure out which empty set we have in mind.</p>
<p>With that preparation, we are ready to prove our first preliminary theorem. Since the goal is an equation between sets, our first step is to use the tactic <code>apply Set.ext</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb204"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> empty_union {U : <span class="kw">Type</span>} (B : Set U) :</span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true" tabindex="-1"></a>    ∅ ∪ B = B := <span class="kw">by</span></span>
<span id="cb204-3"><a href="#cb204-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb204-4"><a href="#cb204-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb205"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> h</span>
<span id="cb205-2"><a href="#cb205-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb205-3"><a href="#cb205-3" aria-hidden="true" tabindex="-1"></a><span class="in">B </span>: Set U</span>
<span id="cb205-4"><a href="#cb205-4" aria-hidden="true" tabindex="-1"></a>⊢ ∀ (x : U),</span>
<span id="cb205-5"><a href="#cb205-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  x ∈ ∅ ∪ B ↔ x ∈ B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Based on the form of the goal, our next two tactics should be <code>fix x : U</code> and <code>apply Iff.intro</code>. This leaves us with two goals, corresponding to the two directions of the biconditional, but we’ll focus first on just the left-to-right direction.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb206"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> empty_union {U : <span class="kw">Type</span>} (B : Set U) :</span>
<span id="cb206-2"><a href="#cb206-2" aria-hidden="true" tabindex="-1"></a>    ∅ ∪ B = B := <span class="kw">by</span></span>
<span id="cb206-3"><a href="#cb206-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb206-4"><a href="#cb206-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb206-5"><a href="#cb206-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb206-6"><a href="#cb206-6" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb206-7"><a href="#cb206-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-8"><a href="#cb206-8" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb206-9"><a href="#cb206-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb206-10"><a href="#cb206-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-11"><a href="#cb206-11" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb206-12"><a href="#cb206-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb207"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> h.mp</span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb207-3"><a href="#cb207-3" aria-hidden="true" tabindex="-1"></a><span class="in">B </span>: Set U</span>
<span id="cb207-4"><a href="#cb207-4" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb207-5"><a href="#cb207-5" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ ∅ ∪ B → x ∈ B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Of course, our next step is to assume <code>x ∈ ∅ ∪ B</code>. To help us see how to move forward, we also write out the definition of this assumption.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb208"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> empty_union {U : <span class="kw">Type</span>} (B : Set U) :</span>
<span id="cb208-2"><a href="#cb208-2" aria-hidden="true" tabindex="-1"></a>    ∅ ∪ B = B := <span class="kw">by</span></span>
<span id="cb208-3"><a href="#cb208-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb208-4"><a href="#cb208-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb208-5"><a href="#cb208-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb208-6"><a href="#cb208-6" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb208-7"><a href="#cb208-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : x ∈ ∅ ∪ B</span>
<span id="cb208-8"><a href="#cb208-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb208-9"><a href="#cb208-9" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb208-10"><a href="#cb208-10" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb208-11"><a href="#cb208-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-12"><a href="#cb208-12" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb208-13"><a href="#cb208-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb209"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> h.mp</span>
<span id="cb209-2"><a href="#cb209-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb209-3"><a href="#cb209-3" aria-hidden="true" tabindex="-1"></a><span class="in">B </span>: Set U</span>
<span id="cb209-4"><a href="#cb209-4" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb209-5"><a href="#cb209-5" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: x ∈ ∅ ∨ x ∈ B</span>
<span id="cb209-6"><a href="#cb209-6" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now you should see a way to complete the proof: the statement <code>x ∈ ∅</code> is false, so we should be able to apply the disjunctive syllogism rule to <code>h1</code> to infer the goal <code>x ∈ B</code>. To carry out this plan, we’ll first have to prove <code>x ∉ ∅</code>. We’ll use the <code>have</code> tactic, and since there’s no obvious term-mode proof to justify it, we’ll try a tactic-mode proof.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb210"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> empty_union {U : <span class="kw">Type</span>} (B : Set U) :</span>
<span id="cb210-2"><a href="#cb210-2" aria-hidden="true" tabindex="-1"></a>    ∅ ∪ B = B := <span class="kw">by</span></span>
<span id="cb210-3"><a href="#cb210-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb210-4"><a href="#cb210-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb210-5"><a href="#cb210-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb210-6"><a href="#cb210-6" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb210-7"><a href="#cb210-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : x ∈ ∅ ∪ B</span>
<span id="cb210-8"><a href="#cb210-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb210-9"><a href="#cb210-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : x ∉ ∅ := <span class="kw">by</span></span>
<span id="cb210-10"><a href="#cb210-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-11"><a href="#cb210-11" aria-hidden="true" tabindex="-1"></a>      <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb210-12"><a href="#cb210-12" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb210-13"><a href="#cb210-13" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb210-14"><a href="#cb210-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-15"><a href="#cb210-15" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb210-16"><a href="#cb210-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb211"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb211-2"><a href="#cb211-2" aria-hidden="true" tabindex="-1"></a><span class="in">B </span>: Set U</span>
<span id="cb211-3"><a href="#cb211-3" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb211-4"><a href="#cb211-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: x ∈ ∅ ∨ x ∈ B</span>
<span id="cb211-5"><a href="#cb211-5" aria-hidden="true" tabindex="-1"></a>⊢ x ∉ ∅</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The goal for our “proof within a proof” is a negative statement, so proof by contradiction seems like a good start.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb212"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> empty_union {U : <span class="kw">Type</span>} (B : Set U) :</span>
<span id="cb212-2"><a href="#cb212-2" aria-hidden="true" tabindex="-1"></a>    ∅ ∪ B = B := <span class="kw">by</span></span>
<span id="cb212-3"><a href="#cb212-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb212-4"><a href="#cb212-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb212-5"><a href="#cb212-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb212-6"><a href="#cb212-6" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb212-7"><a href="#cb212-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : x ∈ ∅ ∪ B</span>
<span id="cb212-8"><a href="#cb212-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb212-9"><a href="#cb212-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : x ∉ ∅ := <span class="kw">by</span></span>
<span id="cb212-10"><a href="#cb212-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">by_contra</span> h3</span>
<span id="cb212-11"><a href="#cb212-11" aria-hidden="true" tabindex="-1"></a>      <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb212-12"><a href="#cb212-12" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb212-13"><a href="#cb212-13" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb212-14"><a href="#cb212-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb212-15"><a href="#cb212-15" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb212-16"><a href="#cb212-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb213"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb213-2"><a href="#cb213-2" aria-hidden="true" tabindex="-1"></a><span class="in">B </span>: Set U</span>
<span id="cb213-3"><a href="#cb213-3" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb213-4"><a href="#cb213-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: x ∈ ∅ ∨ x ∈ B</span>
<span id="cb213-5"><a href="#cb213-5" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: x ∈ ∅</span>
<span id="cb213-6"><a href="#cb213-6" aria-hidden="true" tabindex="-1"></a>⊢ False</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>To see how to use the new assumption <code>h3</code>, we use the tactic <code>define at h3</code>. The definition Lean gives for the statement <code>x ∈ ∅</code> is <code>False</code>. In other words, Lean knows that, by the definition of <code>∅</code>, the statement <code>x ∈ ∅</code> is false. Since <code>False</code> is our goal, this completes the inner proof, and we can return to the main proof.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb214"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> empty_union {U : <span class="kw">Type</span>} (B : Set U) :</span>
<span id="cb214-2"><a href="#cb214-2" aria-hidden="true" tabindex="-1"></a>    ∅ ∪ B = B := <span class="kw">by</span></span>
<span id="cb214-3"><a href="#cb214-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb214-4"><a href="#cb214-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb214-5"><a href="#cb214-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb214-6"><a href="#cb214-6" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb214-7"><a href="#cb214-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : x ∈ ∅ ∪ B</span>
<span id="cb214-8"><a href="#cb214-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb214-9"><a href="#cb214-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : x ∉ ∅ := <span class="kw">by</span></span>
<span id="cb214-10"><a href="#cb214-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">by_contra</span> h3</span>
<span id="cb214-11"><a href="#cb214-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span> <span class="kw">at</span> h3  <span class="co">--h3 : False</span></span>
<span id="cb214-12"><a href="#cb214-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> False <span class="kw">from</span> h3</span>
<span id="cb214-13"><a href="#cb214-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb214-14"><a href="#cb214-14" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb214-15"><a href="#cb214-15" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb214-16"><a href="#cb214-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-17"><a href="#cb214-17" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb214-18"><a href="#cb214-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb215"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> h.mp</span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb215-3"><a href="#cb215-3" aria-hidden="true" tabindex="-1"></a><span class="in">B </span>: Set U</span>
<span id="cb215-4"><a href="#cb215-4" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb215-5"><a href="#cb215-5" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: x ∈ ∅ ∨ x ∈ B</span>
<span id="cb215-6"><a href="#cb215-6" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: x ∉ ∅</span>
<span id="cb215-7"><a href="#cb215-7" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now that we have established the claim <code>h2 : x ∉ ∅</code>, we can apply the disjunctive syllogism rule to <code>h1</code> and <code>h2</code> to reach the goal. This completes the left-to-right direction of the biconditional proof, so we move on to the right-to-left direction.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb216"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> empty_union {U : <span class="kw">Type</span>} (B : Set U) :</span>
<span id="cb216-2"><a href="#cb216-2" aria-hidden="true" tabindex="-1"></a>    ∅ ∪ B = B := <span class="kw">by</span></span>
<span id="cb216-3"><a href="#cb216-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb216-4"><a href="#cb216-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb216-5"><a href="#cb216-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb216-6"><a href="#cb216-6" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb216-7"><a href="#cb216-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : x ∈ ∅ ∪ B</span>
<span id="cb216-8"><a href="#cb216-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb216-9"><a href="#cb216-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : x ∉ ∅ := <span class="kw">by</span></span>
<span id="cb216-10"><a href="#cb216-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">by_contra</span> h3</span>
<span id="cb216-11"><a href="#cb216-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span> <span class="kw">at</span> h3  <span class="co">--h3 : False</span></span>
<span id="cb216-12"><a href="#cb216-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> False <span class="kw">from</span> h3</span>
<span id="cb216-13"><a href="#cb216-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb216-14"><a href="#cb216-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">disj_syll</span> h1 h2  <span class="co">--h1 : x ∈ B</span></span>
<span id="cb216-15"><a href="#cb216-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> x ∈ B <span class="kw">from</span> h1</span>
<span id="cb216-16"><a href="#cb216-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb216-17"><a href="#cb216-17" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb216-18"><a href="#cb216-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-19"><a href="#cb216-19" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb216-20"><a href="#cb216-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb217"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> h.mpr</span>
<span id="cb217-2"><a href="#cb217-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb217-3"><a href="#cb217-3" aria-hidden="true" tabindex="-1"></a><span class="in">B </span>: Set U</span>
<span id="cb217-4"><a href="#cb217-4" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb217-5"><a href="#cb217-5" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ B → x ∈ ∅ ∪ B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>This direction of the biconditional proof is easier: once we introduce the assumption <code>h1 : x ∈ B</code>, our goal will be <code>x ∈ ∅ ∪ B</code>, which means <code>x ∈ ∅ ∨ x ∈ B</code>, and we can prove it with the proof <code>Or.inr h1</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb218"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> empty_union {U : <span class="kw">Type</span>} (B : Set U) :</span>
<span id="cb218-2"><a href="#cb218-2" aria-hidden="true" tabindex="-1"></a>    ∅ ∪ B = B := <span class="kw">by</span></span>
<span id="cb218-3"><a href="#cb218-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb218-4"><a href="#cb218-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb218-5"><a href="#cb218-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb218-6"><a href="#cb218-6" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb218-7"><a href="#cb218-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : x ∈ ∅ ∪ B</span>
<span id="cb218-8"><a href="#cb218-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb218-9"><a href="#cb218-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : x ∉ ∅ := <span class="kw">by</span></span>
<span id="cb218-10"><a href="#cb218-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">by_contra</span> h3</span>
<span id="cb218-11"><a href="#cb218-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span> <span class="kw">at</span> h3  <span class="co">--h3 : False</span></span>
<span id="cb218-12"><a href="#cb218-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> False <span class="kw">from</span> h3</span>
<span id="cb218-13"><a href="#cb218-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb218-14"><a href="#cb218-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">disj_syll</span> h1 h2  <span class="co">--h1 : x ∈ B</span></span>
<span id="cb218-15"><a href="#cb218-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> x ∈ B <span class="kw">from</span> h1</span>
<span id="cb218-16"><a href="#cb218-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb218-17"><a href="#cb218-17" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb218-18"><a href="#cb218-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : x ∈ B</span>
<span id="cb218-19"><a href="#cb218-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> x ∈ ∅ ∪ B <span class="kw">from</span> Or.inr h1</span>
<span id="cb218-20"><a href="#cb218-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb218-21"><a href="#cb218-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb219"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a><span class="ss">No</span><span class="in"> </span><span class="ss">goals</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The second fact that was called “clear” in the proof from Example 3.6.2 was the equation <code>C ∪ D = D ∪ C</code>. This looks like an instance of the commutativity of the union operator. Let’s prove that union is commutative.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb220"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb220-1"><a href="#cb220-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> union_comm {U : <span class="kw">Type</span>} (X Y : Set U) :</span>
<span id="cb220-2"><a href="#cb220-2" aria-hidden="true" tabindex="-1"></a>    X ∪ Y = Y ∪ X := <span class="kw">by</span></span>
<span id="cb220-3"><a href="#cb220-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb220-4"><a href="#cb220-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb221"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb221-1"><a href="#cb221-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb221-2"><a href="#cb221-2" aria-hidden="true" tabindex="-1"></a><span class="in">X Y </span>: Set U</span>
<span id="cb221-3"><a href="#cb221-3" aria-hidden="true" tabindex="-1"></a>⊢ X ∪ Y = Y ∪ X</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Once again, we begin with <code>apply Set.ext</code>, which converts the goal to <code>∀ (x : U), x ∈ X ∪ Y ↔︎ x ∈ Y ∪ X</code>, and then <code>fix x : U</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb222"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> union_comm {U : <span class="kw">Type</span>} (X Y : Set U) :</span>
<span id="cb222-2"><a href="#cb222-2" aria-hidden="true" tabindex="-1"></a>    X ∪ Y = Y ∪ X := <span class="kw">by</span></span>
<span id="cb222-3"><a href="#cb222-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb222-4"><a href="#cb222-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb222-5"><a href="#cb222-5" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb223"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb223-1"><a href="#cb223-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> h</span>
<span id="cb223-2"><a href="#cb223-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb223-3"><a href="#cb223-3" aria-hidden="true" tabindex="-1"></a><span class="in">X Y </span>: Set U</span>
<span id="cb223-4"><a href="#cb223-4" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb223-5"><a href="#cb223-5" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ X ∪ Y ↔ x ∈ Y ∪ X</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>To understand the goal better, we’ll write out the definitions of the two sides of the biconditional. We use an extension of the <code>define</code> tactic that allows us to write out the definition of just a part of a given or the goal. The tactic <code>define : x ∈ X ∪ Y</code> will replace <code>x ∈ X ∪ Y</code> with its definition wherever it appears in the goal, and then <code>define : x ∈ Y ∪ X</code> will replace <code>x ∈ Y ∪ X</code> with its definition. (Note that <code>define : X ∪ Y</code> produces a result that is not as useful. It is usually best to define a complete statement rather than just a part of a statement. As usual, you can add <code>at</code> to do the replacements in a given rather than the goal.)</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb224"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> union_comm {U : <span class="kw">Type</span>} (X Y : Set U) :</span>
<span id="cb224-2"><a href="#cb224-2" aria-hidden="true" tabindex="-1"></a>    X ∪ Y = Y ∪ X := <span class="kw">by</span></span>
<span id="cb224-3"><a href="#cb224-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb224-4"><a href="#cb224-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb224-5"><a href="#cb224-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> : x ∈ X ∪ Y</span>
<span id="cb224-6"><a href="#cb224-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> : x ∈ Y ∪ X</span>
<span id="cb224-7"><a href="#cb224-7" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb225"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb225-1"><a href="#cb225-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> h</span>
<span id="cb225-2"><a href="#cb225-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb225-3"><a href="#cb225-3" aria-hidden="true" tabindex="-1"></a><span class="in">X Y </span>: Set U</span>
<span id="cb225-4"><a href="#cb225-4" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb225-5"><a href="#cb225-5" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ X ∨ x ∈ Y ↔</span>
<span id="cb225-6"><a href="#cb225-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  x ∈ Y ∨ x ∈ X</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>By the way, there are similar extensions of all of the tactics <code>contrapos</code>, <code>demorgan</code>, <code>conditional</code>, <code>double_neg</code>, <code>bicond_neg</code>, and <code>quant_neg</code> that allow you to use a logical equivalence to rewrite just a part of a formula. For example, if your goal is <code>P ∧ (¬Q → R)</code>, then the tactic <code>contrapos : ¬Q → R</code> will change the goal to <code>P ∧ (¬R → Q)</code>. If you have a given <code>h : P → ¬∀ (x : U), Q x</code>, then the tactic <code>quant_neg : ¬∀ (x : U), Q x at h</code> will change <code>h</code> to <code>h : P → ∃ (x : U), ¬Q x</code>.</p>
<p>Returning to our proof of <code>union_comm</code>: the goal is now <code>x ∈ X ∨ x ∈ Y ↔︎ x ∈ Y ∨ x ∈ X</code>. You could prove this by a somewhat tedious application of the rules for biconditionals and disjunctions that were discussed in the last two sections, and we invite you to try it. But there is another possibility. The goal now has the form <code>P ∨ Q ↔︎ Q ∨ P</code>, which is the commutative law for “or” (see Section 1.2 of <em>HTPI</em>). We saw in a previous example that Lean has, in its library, the associative law for “and”; it is called <code>and_assoc</code>. Does Lean also know the commutative law for “or”?</p>
<p>Try typing <code>#check @or_</code> in VS Code. After a few seconds, a pop-up window appears with possible completions of this command. You will see <code>or_assoc</code> on the list, as well as <code>or_comm</code>. Select <code>or_comm</code>, and you’ll get this response: <code>@or_comm : ∀ {a b : Prop}, a ∨ b ↔︎ b ∨ a</code>. Since <code>a</code> and <code>b</code> are implicit arguments in this theorem, you can use <code>or_comm</code> to prove any statement of the form <code>a ∨ b ↔︎ b ∨ a</code>, where Lean will figure out for itself what <code>a</code> and <code>b</code> stand for. In particular, <code>or_comm</code> will prove our current goal.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb226"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb226-1"><a href="#cb226-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> union_comm {U : <span class="kw">Type</span>} (X Y : Set U) :</span>
<span id="cb226-2"><a href="#cb226-2" aria-hidden="true" tabindex="-1"></a>    X ∪ Y = Y ∪ X := <span class="kw">by</span></span>
<span id="cb226-3"><a href="#cb226-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb226-4"><a href="#cb226-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb226-5"><a href="#cb226-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> : x ∈ X ∪ Y</span>
<span id="cb226-6"><a href="#cb226-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> : x ∈ Y ∪ X</span>
<span id="cb226-7"><a href="#cb226-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> x ∈ X ∨ x ∈ Y ↔ x ∈ Y ∨ x ∈ X <span class="kw">from</span> or_comm</span>
<span id="cb226-8"><a href="#cb226-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb227"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb227-1"><a href="#cb227-1" aria-hidden="true" tabindex="-1"></a><span class="ss">No</span><span class="in"> </span><span class="ss">goals</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>We have now proven the two statements that were said to be “clearly” true in the proof in Example 3.6.2 of <em>HTPI</em>, and we have given them names. And that means that we can now use these theorems, in the file containing these proofs, to prove other theorems. As with any theorem in Lean’s library, you can use the <code>#check</code> command to confirm what these theorems say. If you type <code>#check @empty_union</code> and <code>#check @union_comm</code>, you will get these results:</p>
<div class="ind">
<pre><code>@empty_union : ∀ {U : Type} (B : Set U), ∅ ∪ B = B

@union_comm : ∀ {U : Type} (X Y : Set U), X ∪ Y = Y ∪ X</code></pre>
</div>
<p>Notice that in both theorems we used curly braces when we introduced the type <code>U</code>, so it is an implicit argument and will not need to be specified when we apply the theorems. (Why did we decide to make <code>U</code> an implicit argument? Well, when we apply the theorem <code>empty_union</code> we will be specifying the set <code>B</code>, and when we apply <code>union_comm</code> we will be specifying the sets <code>X</code> and <code>Y</code>. Lean can figure out what <code>U</code> is by examining the types of these sets, so there is no need to specify it separately.)</p>
<p>We are finally ready to prove the theorem from Example 3.6.2. Here is the theorem:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb229"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb229-1"><a href="#cb229-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_6_2 (U : <span class="kw">Type</span>) :</span>
<span id="cb229-2"><a href="#cb229-2" aria-hidden="true" tabindex="-1"></a>    ∃! (A : Set U), ∀ (B : Set U),</span>
<span id="cb229-3"><a href="#cb229-3" aria-hidden="true" tabindex="-1"></a>    A ∪ B = B := <span class="kw">by</span></span>
<span id="cb229-4"><a href="#cb229-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-5"><a href="#cb229-5" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb230"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb230-1"><a href="#cb230-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb230-2"><a href="#cb230-2" aria-hidden="true" tabindex="-1"></a>⊢ ∃! (A : Set U),</span>
<span id="cb230-3"><a href="#cb230-3" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  ∀ (B : Set U),</span>
<span id="cb230-4"><a href="#cb230-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>    A ∪ B = B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The goal starts with <code>∃!</code>, so we use our new tactic, <code>exists_unique</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb231"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb231-1"><a href="#cb231-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_6_2 (U : <span class="kw">Type</span>) :</span>
<span id="cb231-2"><a href="#cb231-2" aria-hidden="true" tabindex="-1"></a>    ∃! (A : Set U), ∀ (B : Set U),</span>
<span id="cb231-3"><a href="#cb231-3" aria-hidden="true" tabindex="-1"></a>    A ∪ B = B := <span class="kw">by</span></span>
<span id="cb231-4"><a href="#cb231-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">exists_unique</span></span>
<span id="cb231-5"><a href="#cb231-5" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb232"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb232-1"><a href="#cb232-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> Existence</span>
<span id="cb232-2"><a href="#cb232-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb232-3"><a href="#cb232-3" aria-hidden="true" tabindex="-1"></a>⊢ ∃ (A : Set U),</span>
<span id="cb232-4"><a href="#cb232-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  ∀ (B : Set U),</span>
<span id="cb232-5"><a href="#cb232-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>    A ∪ B = B</span>
<span id="cb232-6"><a href="#cb232-6" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> Uniqueness</span>
<span id="cb232-7"><a href="#cb232-7" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb232-8"><a href="#cb232-8" aria-hidden="true" tabindex="-1"></a>⊢ ∀ (A_1 A_2 : Set U),</span>
<span id="cb232-9"><a href="#cb232-9" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  (∀ (B : Set U),</span>
<span id="cb232-10"><a href="#cb232-10" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>      A_1 ∪ B = B) →</span>
<span id="cb232-11"><a href="#cb232-11" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  (∀ (B : Set U),</span>
<span id="cb232-12"><a href="#cb232-12" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>      A_2 ∪ B = B) →</span>
<span id="cb232-13"><a href="#cb232-13" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  A_1 = A_2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>We have two goals, labeled <code>Existence</code> and <code>Uniqueness</code>. Imitating the proof from <em>HTPI</em>, we prove existence by using the value <code>∅</code> for <code>A</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb233"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb233-1"><a href="#cb233-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_6_2 (U : <span class="kw">Type</span>) :</span>
<span id="cb233-2"><a href="#cb233-2" aria-hidden="true" tabindex="-1"></a>    ∃! (A : Set U), ∀ (B : Set U),</span>
<span id="cb233-3"><a href="#cb233-3" aria-hidden="true" tabindex="-1"></a>    A ∪ B = B := <span class="kw">by</span></span>
<span id="cb233-4"><a href="#cb233-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">exists_unique</span></span>
<span id="cb233-5"><a href="#cb233-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Existence</span></span>
<span id="cb233-6"><a href="#cb233-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro ∅</span>
<span id="cb233-7"><a href="#cb233-7" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb233-8"><a href="#cb233-8" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Uniqueness</span></span>
<span id="cb233-9"><a href="#cb233-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb233-10"><a href="#cb233-10" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb233-11"><a href="#cb233-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb234"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> Existence</span>
<span id="cb234-2"><a href="#cb234-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb234-3"><a href="#cb234-3" aria-hidden="true" tabindex="-1"></a>⊢ ∀ (B : Set U),</span>
<span id="cb234-4"><a href="#cb234-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  ∅ ∪ B = B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The goal is now precisely the statement of the theorem <code>empty_union</code>, so we can prove it by simply citing that theorem.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb235"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb235-1"><a href="#cb235-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_6_2 (U : <span class="kw">Type</span>) :</span>
<span id="cb235-2"><a href="#cb235-2" aria-hidden="true" tabindex="-1"></a>    ∃! (A : Set U), ∀ (B : Set U),</span>
<span id="cb235-3"><a href="#cb235-3" aria-hidden="true" tabindex="-1"></a>    A ∪ B = B := <span class="kw">by</span></span>
<span id="cb235-4"><a href="#cb235-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">exists_unique</span></span>
<span id="cb235-5"><a href="#cb235-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Existence</span></span>
<span id="cb235-6"><a href="#cb235-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro ∅</span>
<span id="cb235-7"><a href="#cb235-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ∀ (B : Set U), ∅ ∪ B = B <span class="kw">from</span> empty_union</span>
<span id="cb235-8"><a href="#cb235-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb235-9"><a href="#cb235-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Uniqueness</span></span>
<span id="cb235-10"><a href="#cb235-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-11"><a href="#cb235-11" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb235-12"><a href="#cb235-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb236"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb236-1"><a href="#cb236-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> Uniqueness</span>
<span id="cb236-2"><a href="#cb236-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb236-3"><a href="#cb236-3" aria-hidden="true" tabindex="-1"></a>⊢ ∀ (A_1 A_2 : Set U),</span>
<span id="cb236-4"><a href="#cb236-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  (∀ (B : Set U),</span>
<span id="cb236-5"><a href="#cb236-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>      A_1 ∪ B = B) →</span>
<span id="cb236-6"><a href="#cb236-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  (∀ (B : Set U),</span>
<span id="cb236-7"><a href="#cb236-7" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>      A_2 ∪ B = B) →</span>
<span id="cb236-8"><a href="#cb236-8" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  A_1 = A_2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>For the uniqueness proof, we begin by introducing arbitrary sets <code>C</code> and <code>D</code> and assuming <code>∀ (B : Set U), C ∪ B = B</code> and <code>∀ (B : Set U), D ∪ B = B</code>, exactly as in the <em>HTPI</em> proof.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb237"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb237-1"><a href="#cb237-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_6_2 (U : <span class="kw">Type</span>) :</span>
<span id="cb237-2"><a href="#cb237-2" aria-hidden="true" tabindex="-1"></a>    ∃! (A : Set U), ∀ (B : Set U),</span>
<span id="cb237-3"><a href="#cb237-3" aria-hidden="true" tabindex="-1"></a>    A ∪ B = B := <span class="kw">by</span></span>
<span id="cb237-4"><a href="#cb237-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">exists_unique</span></span>
<span id="cb237-5"><a href="#cb237-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Existence</span></span>
<span id="cb237-6"><a href="#cb237-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro ∅</span>
<span id="cb237-7"><a href="#cb237-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ∀ (B : Set U), ∅ ∪ B = B <span class="kw">from</span> empty_union</span>
<span id="cb237-8"><a href="#cb237-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb237-9"><a href="#cb237-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Uniqueness</span></span>
<span id="cb237-10"><a href="#cb237-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> C : Set U; <span class="kw">fix</span> D : Set U</span>
<span id="cb237-11"><a href="#cb237-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : ∀ (B : Set U), C ∪ B = B</span>
<span id="cb237-12"><a href="#cb237-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : ∀ (B : Set U), D ∪ B = B</span>
<span id="cb237-13"><a href="#cb237-13" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb237-14"><a href="#cb237-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb238"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb238-1"><a href="#cb238-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> Uniqueness</span>
<span id="cb238-2"><a href="#cb238-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb238-3"><a href="#cb238-3" aria-hidden="true" tabindex="-1"></a><span class="in">C D </span>: Set U</span>
<span id="cb238-4"><a href="#cb238-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (B : Set U),</span>
<span id="cb238-5"><a href="#cb238-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  C ∪ B = B</span>
<span id="cb238-6"><a href="#cb238-6" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ (B : Set U),</span>
<span id="cb238-7"><a href="#cb238-7" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  D ∪ B = B</span>
<span id="cb238-8"><a href="#cb238-8" aria-hidden="true" tabindex="-1"></a>⊢ C = D</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The next step in <em>HTPI</em> was to apply <code>h1</code> to <code>D</code>, and <code>h2</code> to <code>C</code>. We do the same thing in Lean.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb239"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb239-1"><a href="#cb239-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_6_2 (U : <span class="kw">Type</span>) :</span>
<span id="cb239-2"><a href="#cb239-2" aria-hidden="true" tabindex="-1"></a>    ∃! (A : Set U), ∀ (B : Set U),</span>
<span id="cb239-3"><a href="#cb239-3" aria-hidden="true" tabindex="-1"></a>    A ∪ B = B := <span class="kw">by</span></span>
<span id="cb239-4"><a href="#cb239-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">exists_unique</span></span>
<span id="cb239-5"><a href="#cb239-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Existence</span></span>
<span id="cb239-6"><a href="#cb239-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro ∅</span>
<span id="cb239-7"><a href="#cb239-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ∀ (B : Set U), ∅ ∪ B = B <span class="kw">from</span> empty_union</span>
<span id="cb239-8"><a href="#cb239-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb239-9"><a href="#cb239-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Uniqueness</span></span>
<span id="cb239-10"><a href="#cb239-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> C : Set U; <span class="kw">fix</span> D : Set U</span>
<span id="cb239-11"><a href="#cb239-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : ∀ (B : Set U), C ∪ B = B</span>
<span id="cb239-12"><a href="#cb239-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : ∀ (B : Set U), D ∪ B = B</span>
<span id="cb239-13"><a href="#cb239-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : C ∪ D = D := h1 D</span>
<span id="cb239-14"><a href="#cb239-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : D ∪ C = C := h2 C </span>
<span id="cb239-15"><a href="#cb239-15" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb239-16"><a href="#cb239-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb240"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb240-1"><a href="#cb240-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> Uniqueness</span>
<span id="cb240-2"><a href="#cb240-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb240-3"><a href="#cb240-3" aria-hidden="true" tabindex="-1"></a><span class="in">C D </span>: Set U</span>
<span id="cb240-4"><a href="#cb240-4" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∀ (B : Set U),</span>
<span id="cb240-5"><a href="#cb240-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  C ∪ B = B</span>
<span id="cb240-6"><a href="#cb240-6" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∀ (B : Set U),</span>
<span id="cb240-7"><a href="#cb240-7" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  D ∪ B = B</span>
<span id="cb240-8"><a href="#cb240-8" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: C ∪ D = D</span>
<span id="cb240-9"><a href="#cb240-9" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: D ∪ C = C</span>
<span id="cb240-10"><a href="#cb240-10" aria-hidden="true" tabindex="-1"></a>⊢ C = D</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The goal can now be achieved by stringing together a sequence of equations: <code>C = D ∪ C = C ∪ D = D</code>. The first of these equations is <code>h4.symm</code>—that is, <code>h4</code> read backwards; the second follows from the commutative law for union; and the third is <code>h3</code>. We saw in Section 3.4 that you can prove a biconditional statement in Lean by stringing together a sequence of biconditionals in a calculational proof. Exactly the same method applies to equations. Here is the complete proof of the theorem:</p>
<div class="sourceCode" id="cb241"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb241-1"><a href="#cb241-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_6_2 (U : <span class="kw">Type</span>) :</span>
<span id="cb241-2"><a href="#cb241-2" aria-hidden="true" tabindex="-1"></a>    ∃! (A : Set U), ∀ (B : Set U),</span>
<span id="cb241-3"><a href="#cb241-3" aria-hidden="true" tabindex="-1"></a>    A ∪ B = B := <span class="kw">by</span></span>
<span id="cb241-4"><a href="#cb241-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">exists_unique</span></span>
<span id="cb241-5"><a href="#cb241-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Existence</span></span>
<span id="cb241-6"><a href="#cb241-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro ∅</span>
<span id="cb241-7"><a href="#cb241-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ∀ (B : Set U), ∅ ∪ B = B <span class="kw">from</span> empty_union</span>
<span id="cb241-8"><a href="#cb241-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb241-9"><a href="#cb241-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Uniqueness</span></span>
<span id="cb241-10"><a href="#cb241-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> C : Set U; <span class="kw">fix</span> D : Set U</span>
<span id="cb241-11"><a href="#cb241-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : ∀ (B : Set U), C ∪ B = B</span>
<span id="cb241-12"><a href="#cb241-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : ∀ (B : Set U), D ∪ B = B</span>
<span id="cb241-13"><a href="#cb241-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : C ∪ D = D := h1 D</span>
<span id="cb241-14"><a href="#cb241-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : D ∪ C = C := h2 C </span>
<span id="cb241-15"><a href="#cb241-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> C = D <span class="kw">from</span></span>
<span id="cb241-16"><a href="#cb241-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> C</span>
<span id="cb241-17"><a href="#cb241-17" aria-hidden="true" tabindex="-1"></a>        _ = D ∪ C := h4.symm</span>
<span id="cb241-18"><a href="#cb241-18" aria-hidden="true" tabindex="-1"></a>        _ = C ∪ D := union_comm D C</span>
<span id="cb241-19"><a href="#cb241-19" aria-hidden="true" tabindex="-1"></a>        _ = D := h3</span>
<span id="cb241-20"><a href="#cb241-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb241-21"><a href="#cb241-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Since the statement <code>∃! (x : U), P x</code> asserts both the existence and the uniqueness of an object satisfying the predicate <code>P</code>, we have the following strategy for using a given of this form (<em>HTPI</em> p.&nbsp;159):</p>
</section>
<section id="to-use-a-given-of-the-form-x-u-p-x-2" class="level4">
<h4 class="anchored" data-anchor-id="to-use-a-given-of-the-form-x-u-p-x-2">To use a given of the form <code>∃! (x : U), P x</code>:</h4>
<div class="ind">
<p>Introduce a new variable, say <code>a</code>, into the proof to stand for an object of type <code>U</code> for which <code>P a</code> is true. You may also assert that <code>∀ (x_1 x_2 : U), P x_1 → P x_2 → x_1 = x2</code>.</p>
</div>
<p>If you have a given <code>h : ∃! (x : U), P x</code>, then the tactic <code>obtain (a : U) (h1 : P a)</code> <br><code>(h2 : ∀ (x_1 x_2 : U), P x_1 → P x_2 → x_1 = x_2) from h</code> will introduce into the tactic state a new variable <code>a</code> of type <code>U</code> and new givens <code>(h1 : P a)</code> and <code>(h2 : ∀ (x_1 x_2 : U), P x_1 → P x_2 → x_1 = x_2)</code>. To illustrate the use of this tactic, let’s prove the theorem in Example 3.6.4 of <em>HTPI</em>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb242"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb242-1"><a href="#cb242-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_6_4 (U : <span class="kw">Type</span>) (A B C : Set U)</span>
<span id="cb242-2"><a href="#cb242-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∃ (x : U), x ∈ A ∩ B)</span>
<span id="cb242-3"><a href="#cb242-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ∃ (x : U), x ∈ A ∩ C)</span>
<span id="cb242-4"><a href="#cb242-4" aria-hidden="true" tabindex="-1"></a>    (h3 : ∃! (x : U), x ∈ A) :</span>
<span id="cb242-5"><a href="#cb242-5" aria-hidden="true" tabindex="-1"></a>    ∃ (x : U), x ∈ B ∩ C := <span class="kw">by</span></span>
<span id="cb242-6"><a href="#cb242-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb242-7"><a href="#cb242-7" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb243"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb243-1"><a href="#cb243-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb243-2"><a href="#cb243-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb243-3"><a href="#cb243-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∃ (x : U),</span>
<span id="cb243-4"><a href="#cb243-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  x ∈ A ∩ B</span>
<span id="cb243-5"><a href="#cb243-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (x : U),</span>
<span id="cb243-6"><a href="#cb243-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  x ∈ A ∩ C</span>
<span id="cb243-7"><a href="#cb243-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: ∃! (x : U), x ∈ A</span>
<span id="cb243-8"><a href="#cb243-8" aria-hidden="true" tabindex="-1"></a>⊢ ∃ (x : U), x ∈ B ∩ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>We begin by applying the <code>obtain</code> tactic to <code>h1</code>, <code>h2</code>, and <code>h3</code>. In the case of <code>h3</code>, we get an extra given asserting the uniqueness of the element of <code>A</code>. We also write out the definitions of two of the new givens we obtain.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb244"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb244-1"><a href="#cb244-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_6_4 (U : <span class="kw">Type</span>) (A B C : Set U)</span>
<span id="cb244-2"><a href="#cb244-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∃ (x : U), x ∈ A ∩ B)</span>
<span id="cb244-3"><a href="#cb244-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ∃ (x : U), x ∈ A ∩ C)</span>
<span id="cb244-4"><a href="#cb244-4" aria-hidden="true" tabindex="-1"></a>    (h3 : ∃! (x : U), x ∈ A) :</span>
<span id="cb244-5"><a href="#cb244-5" aria-hidden="true" tabindex="-1"></a>    ∃ (x : U), x ∈ B ∩ C := <span class="kw">by</span></span>
<span id="cb244-6"><a href="#cb244-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (b : U) (h4 : b ∈ A ∩ B) <span class="kw">from</span> h1</span>
<span id="cb244-7"><a href="#cb244-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (c : U) (h5 : c ∈ A ∩ C) <span class="kw">from</span> h2</span>
<span id="cb244-8"><a href="#cb244-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : U) (h6 : a ∈ A) (h7 : ∀ (y z : U),</span>
<span id="cb244-9"><a href="#cb244-9" aria-hidden="true" tabindex="-1"></a>    y ∈ A → z ∈ A → y = z)  <span class="kw">from</span> h3</span>
<span id="cb244-10"><a href="#cb244-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h4; <span class="kw">define</span> <span class="kw">at</span> h5</span>
<span id="cb244-11"><a href="#cb244-11" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb245"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb245-1"><a href="#cb245-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb245-2"><a href="#cb245-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb245-3"><a href="#cb245-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∃ (x : U),</span>
<span id="cb245-4"><a href="#cb245-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  x ∈ A ∩ B</span>
<span id="cb245-5"><a href="#cb245-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (x : U),</span>
<span id="cb245-6"><a href="#cb245-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  x ∈ A ∩ C</span>
<span id="cb245-7"><a href="#cb245-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: ∃! (x : U), x ∈ A</span>
<span id="cb245-8"><a href="#cb245-8" aria-hidden="true" tabindex="-1"></a><span class="in">b </span>: U</span>
<span id="cb245-9"><a href="#cb245-9" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: b ∈ A ∧ b ∈ B</span>
<span id="cb245-10"><a href="#cb245-10" aria-hidden="true" tabindex="-1"></a><span class="in">c </span>: U</span>
<span id="cb245-11"><a href="#cb245-11" aria-hidden="true" tabindex="-1"></a><span class="in">h5 </span>: c ∈ A ∧ c ∈ C</span>
<span id="cb245-12"><a href="#cb245-12" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb245-13"><a href="#cb245-13" aria-hidden="true" tabindex="-1"></a><span class="in">h6 </span>: a ∈ A</span>
<span id="cb245-14"><a href="#cb245-14" aria-hidden="true" tabindex="-1"></a><span class="in">h7 </span>: ∀ (y z : U),</span>
<span id="cb245-15"><a href="#cb245-15" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  y ∈ A → z ∈ A → y = z</span>
<span id="cb245-16"><a href="#cb245-16" aria-hidden="true" tabindex="-1"></a>⊢ ∃ (x : U), x ∈ B ∩ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The key to the rest of the proof is the observation that, by the uniqueness of the element of <code>A</code>, <code>b</code> must be equal to <code>c</code>. To justify this conclusion, note that by two applications of universal instantiation, <code>h7 b c</code> is a proof of <code>b ∈ A → c ∈ A → b = c</code>, and therefore by two applications of modus ponens, <code>h7 b c h4.left h5.left</code> is a proof of <code>b = c</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb246"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb246-1"><a href="#cb246-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_6_4 (U : <span class="kw">Type</span>) (A B C : Set U)</span>
<span id="cb246-2"><a href="#cb246-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∃ (x : U), x ∈ A ∩ B)</span>
<span id="cb246-3"><a href="#cb246-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ∃ (x : U), x ∈ A ∩ C)</span>
<span id="cb246-4"><a href="#cb246-4" aria-hidden="true" tabindex="-1"></a>    (h3 : ∃! (x : U), x ∈ A) :</span>
<span id="cb246-5"><a href="#cb246-5" aria-hidden="true" tabindex="-1"></a>    ∃ (x : U), x ∈ B ∩ C := <span class="kw">by</span></span>
<span id="cb246-6"><a href="#cb246-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (b : U) (h4 : b ∈ A ∩ B) <span class="kw">from</span> h1</span>
<span id="cb246-7"><a href="#cb246-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (c : U) (h5 : c ∈ A ∩ C) <span class="kw">from</span> h2</span>
<span id="cb246-8"><a href="#cb246-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : U) (h6 : a ∈ A) (h7 : ∀ (y z : U),</span>
<span id="cb246-9"><a href="#cb246-9" aria-hidden="true" tabindex="-1"></a>    y ∈ A → z ∈ A → y = z)  <span class="kw">from</span> h3</span>
<span id="cb246-10"><a href="#cb246-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h4; <span class="kw">define</span> <span class="kw">at</span> h5</span>
<span id="cb246-11"><a href="#cb246-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h8 : b = c := h7 b c h4.left h5.left</span>
<span id="cb246-12"><a href="#cb246-12" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb247"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb247-1"><a href="#cb247-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb247-2"><a href="#cb247-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb247-3"><a href="#cb247-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∃ (x : U),</span>
<span id="cb247-4"><a href="#cb247-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  x ∈ A ∩ B</span>
<span id="cb247-5"><a href="#cb247-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (x : U),</span>
<span id="cb247-6"><a href="#cb247-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  x ∈ A ∩ C</span>
<span id="cb247-7"><a href="#cb247-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: ∃! (x : U), x ∈ A</span>
<span id="cb247-8"><a href="#cb247-8" aria-hidden="true" tabindex="-1"></a><span class="in">b </span>: U</span>
<span id="cb247-9"><a href="#cb247-9" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: b ∈ A ∧ b ∈ B</span>
<span id="cb247-10"><a href="#cb247-10" aria-hidden="true" tabindex="-1"></a><span class="in">c </span>: U</span>
<span id="cb247-11"><a href="#cb247-11" aria-hidden="true" tabindex="-1"></a><span class="in">h5 </span>: c ∈ A ∧ c ∈ C</span>
<span id="cb247-12"><a href="#cb247-12" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb247-13"><a href="#cb247-13" aria-hidden="true" tabindex="-1"></a><span class="in">h6 </span>: a ∈ A</span>
<span id="cb247-14"><a href="#cb247-14" aria-hidden="true" tabindex="-1"></a><span class="in">h7 </span>: ∀ (y z : U),</span>
<span id="cb247-15"><a href="#cb247-15" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  y ∈ A → z ∈ A → y = z</span>
<span id="cb247-16"><a href="#cb247-16" aria-hidden="true" tabindex="-1"></a><span class="in">h8 </span>: b = c</span>
<span id="cb247-17"><a href="#cb247-17" aria-hidden="true" tabindex="-1"></a>⊢ ∃ (x : U), x ∈ B ∩ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>For our next step, we will need a new tactic. Since we have <code>h8 : b = c</code>, we should be able to replace <code>b</code> with <code>c</code> anywhere it appears. The tactic that allows us to do this called <code>rewrite</code>. If <code>h</code> is a proof of any equation <code>s = t</code>, then <code>rewrite [h]</code> will replace all occurrences of <code>s</code> in the goal with <code>t</code>. Notice that it is the left side of the equation that is replaced with the right side; if you want the replacement to go in the other direction, so that <code>t</code> is replaced with <code>s</code>, you can use <code>rewrite [←h]</code>. (Alternatively, since <code>h.symm</code> is a proof of <code>t = s</code>, you can use <code>rewrite [h.symm]</code>.) You can also apply the <code>rewrite</code> tactic to biconditional statements. If you have <code>h : P ↔︎ Q</code>, then <code>rewrite [h]</code> will cause all occurrences of <code>P</code> in the goal to be replaced with <code>Q</code> (and <code>rewrite [←h]</code> will replace <code>Q</code> with <code>P</code>).</p>
<p>As with many other tactics, you can add <code>at h'</code> to specify that the replacement should be done in the given <code>h'</code> rather than the goal. In our case, <code>rewrite [h8] at h4</code> will change both occurrences of <code>b</code> in <code>h4</code> to <code>c</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb248"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb248-1"><a href="#cb248-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_6_4 (U : <span class="kw">Type</span>) (A B C : Set U)</span>
<span id="cb248-2"><a href="#cb248-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∃ (x : U), x ∈ A ∩ B)</span>
<span id="cb248-3"><a href="#cb248-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ∃ (x : U), x ∈ A ∩ C)</span>
<span id="cb248-4"><a href="#cb248-4" aria-hidden="true" tabindex="-1"></a>    (h3 : ∃! (x : U), x ∈ A) :</span>
<span id="cb248-5"><a href="#cb248-5" aria-hidden="true" tabindex="-1"></a>    ∃ (x : U), x ∈ B ∩ C := <span class="kw">by</span></span>
<span id="cb248-6"><a href="#cb248-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (b : U) (h4 : b ∈ A ∩ B) <span class="kw">from</span> h1</span>
<span id="cb248-7"><a href="#cb248-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (c : U) (h5 : c ∈ A ∩ C) <span class="kw">from</span> h2</span>
<span id="cb248-8"><a href="#cb248-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : U) (h6 : a ∈ A) (h7 : ∀ (y z : U),</span>
<span id="cb248-9"><a href="#cb248-9" aria-hidden="true" tabindex="-1"></a>    y ∈ A → z ∈ A → y = z)  <span class="kw">from</span> h3</span>
<span id="cb248-10"><a href="#cb248-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h4; <span class="kw">define</span> <span class="kw">at</span> h5</span>
<span id="cb248-11"><a href="#cb248-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h8 : b = c := h7 b c h4.left h5.left</span>
<span id="cb248-12"><a href="#cb248-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h8] <span class="kw">at</span> h4</span>
<span id="cb248-13"><a href="#cb248-13" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb249"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb249-1"><a href="#cb249-1" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb249-2"><a href="#cb249-2" aria-hidden="true" tabindex="-1"></a><span class="in">A B C </span>: Set U</span>
<span id="cb249-3"><a href="#cb249-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∃ (x : U),</span>
<span id="cb249-4"><a href="#cb249-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  x ∈ A ∩ B</span>
<span id="cb249-5"><a href="#cb249-5" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (x : U),</span>
<span id="cb249-6"><a href="#cb249-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  x ∈ A ∩ C</span>
<span id="cb249-7"><a href="#cb249-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: ∃! (x : U), x ∈ A</span>
<span id="cb249-8"><a href="#cb249-8" aria-hidden="true" tabindex="-1"></a><span class="in">b c </span>: U</span>
<span id="cb249-9"><a href="#cb249-9" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: c ∈ A ∧ c ∈ B</span>
<span id="cb249-10"><a href="#cb249-10" aria-hidden="true" tabindex="-1"></a><span class="in">h5 </span>: c ∈ A ∧ c ∈ C</span>
<span id="cb249-11"><a href="#cb249-11" aria-hidden="true" tabindex="-1"></a><span class="in">a </span>: U</span>
<span id="cb249-12"><a href="#cb249-12" aria-hidden="true" tabindex="-1"></a><span class="in">h6 </span>: a ∈ A</span>
<span id="cb249-13"><a href="#cb249-13" aria-hidden="true" tabindex="-1"></a><span class="in">h7 </span>: ∀ (y z : U),</span>
<span id="cb249-14"><a href="#cb249-14" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  y ∈ A → z ∈ A → y = z</span>
<span id="cb249-15"><a href="#cb249-15" aria-hidden="true" tabindex="-1"></a><span class="in">h8 </span>: b = c</span>
<span id="cb249-16"><a href="#cb249-16" aria-hidden="true" tabindex="-1"></a>⊢ ∃ (x : U), x ∈ B ∩ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now the right sides of <code>h4</code> and <code>h5</code> tell us that we can prove the goal by plugging in <code>c</code> for <code>x</code>. Here is the complete proof:</p>
<div class="sourceCode" id="cb250"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb250-1"><a href="#cb250-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_6_4 (U : <span class="kw">Type</span>) (A B C : Set U)</span>
<span id="cb250-2"><a href="#cb250-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∃ (x : U), x ∈ A ∩ B)</span>
<span id="cb250-3"><a href="#cb250-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ∃ (x : U), x ∈ A ∩ C)</span>
<span id="cb250-4"><a href="#cb250-4" aria-hidden="true" tabindex="-1"></a>    (h3 : ∃! (x : U), x ∈ A) :</span>
<span id="cb250-5"><a href="#cb250-5" aria-hidden="true" tabindex="-1"></a>    ∃ (x : U), x ∈ B ∩ C := <span class="kw">by</span></span>
<span id="cb250-6"><a href="#cb250-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (b : U) (h4 : b ∈ A ∩ B) <span class="kw">from</span> h1</span>
<span id="cb250-7"><a href="#cb250-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (c : U) (h5 : c ∈ A ∩ C) <span class="kw">from</span> h2</span>
<span id="cb250-8"><a href="#cb250-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : U) (h6 : a ∈ A) (h7 : ∀ (y z : U),</span>
<span id="cb250-9"><a href="#cb250-9" aria-hidden="true" tabindex="-1"></a>    y ∈ A → z ∈ A → y = z)  <span class="kw">from</span> h3</span>
<span id="cb250-10"><a href="#cb250-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h4; <span class="kw">define</span> <span class="kw">at</span> h5</span>
<span id="cb250-11"><a href="#cb250-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h8 : b = c := h7 b c h4.left h5.left</span>
<span id="cb250-12"><a href="#cb250-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h8] <span class="kw">at</span> h4</span>
<span id="cb250-13"><a href="#cb250-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ∃ (x : U), x ∈ B ∩ C <span class="kw">from</span></span>
<span id="cb250-14"><a href="#cb250-14" aria-hidden="true" tabindex="-1"></a>    Exists.intro c (And.intro h4.right h5.right)</span>
<span id="cb250-15"><a href="#cb250-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You might want to compare the Lean proof above to the proof of this theorem as it appears in <em>HTPI</em> (<em>HTPI</em> p.&nbsp;160):</p>
<div class="thm">
<p>Suppose <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, and <span class="math inline">\(C\)</span> are sets, <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are not disjoint, <span class="math inline">\(A\)</span> and <span class="math inline">\(C\)</span> are not disjoint, and <span class="math inline">\(A\)</span> has exactly one element. Then <span class="math inline">\(B\)</span> and <span class="math inline">\(C\)</span> are not disjoint</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Since <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are not disjoint, we can let <span class="math inline">\(b\)</span> be something such that <span class="math inline">\(b \in A\)</span> and <span class="math inline">\(b \in B\)</span>. Similarly, since <span class="math inline">\(A\)</span> and <span class="math inline">\(C\)</span> are not disjoint, there is some object <span class="math inline">\(c\)</span> such that <span class="math inline">\(c \in A\)</span> and <span class="math inline">\(c \in C\)</span>. Since <span class="math inline">\(A\)</span> has only one element, we must have <span class="math inline">\(b = c\)</span>. Thus <span class="math inline">\(b = c \in B \cap C\)</span> and therefore <span class="math inline">\(B\)</span> and <span class="math inline">\(C\)</span> are not disjoint. <span class="excl">&nbsp;□</span></p>
</div>
<p>Before ending this section, we return to the question of how you can tell if a theorem you want to use is in Lean’s library. In an earlier example, we guessed that the commutative law for “or” might be in Lean’s library, and we were then able to use the <code>#check</code> command to confirm it. But there is another technique that we could have used: the tactic <code>apply?</code>, which asks Lean to search through its library of theorems to see if there is one that could be applied to prove the goal. Let’s return to our proof of the theorem <code>union_comm</code>, which started like this:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb251"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb251-1"><a href="#cb251-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> union_comm {U : <span class="kw">Type</span>} (X Y : Set U) :</span>
<span id="cb251-2"><a href="#cb251-2" aria-hidden="true" tabindex="-1"></a>    X ∪ Y = Y ∪ X := <span class="kw">by</span></span>
<span id="cb251-3"><a href="#cb251-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb251-4"><a href="#cb251-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb251-5"><a href="#cb251-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> : x ∈ X ∪ Y</span>
<span id="cb251-6"><a href="#cb251-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> : x ∈ Y ∪ X</span>
<span id="cb251-7"><a href="#cb251-7" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb252"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb252-1"><a href="#cb252-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> h</span>
<span id="cb252-2"><a href="#cb252-2" aria-hidden="true" tabindex="-1"></a><span class="in">U </span>: Type</span>
<span id="cb252-3"><a href="#cb252-3" aria-hidden="true" tabindex="-1"></a><span class="in">X Y </span>: Set U</span>
<span id="cb252-4"><a href="#cb252-4" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: U</span>
<span id="cb252-5"><a href="#cb252-5" aria-hidden="true" tabindex="-1"></a>⊢ x ∈ X ∨ x ∈ Y ↔</span>
<span id="cb252-6"><a href="#cb252-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  x ∈ Y ∨ x ∈ X</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now let’s give the <code>apply?</code> tactic a try.</p>
<div class="sourceCode" id="cb253"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb253-1"><a href="#cb253-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> union_comm {U : <span class="kw">Type</span>} (X Y : Set U) :</span>
<span id="cb253-2"><a href="#cb253-2" aria-hidden="true" tabindex="-1"></a>    X ∪ Y = Y ∪ X := <span class="kw">by</span></span>
<span id="cb253-3"><a href="#cb253-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb253-4"><a href="#cb253-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb253-5"><a href="#cb253-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> : x ∈ X ∪ Y</span>
<span id="cb253-6"><a href="#cb253-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> : x ∈ Y ∪ X</span>
<span id="cb253-7"><a href="#cb253-7" aria-hidden="true" tabindex="-1"></a>  <span class="sc">++</span><span class="do">apply?</span><span class="sc">::</span></span>
<span id="cb253-8"><a href="#cb253-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It takes a few seconds for Lean to search its library of theorems, but eventually a blue squiggle appears under <code>apply?</code>, indicating that the tactic has produced an answer. You will find the answer in the Infoview pane: <code>Try this: exact or_comm</code>. The word <code>exact</code> is the name of a tactic that we have not discussed; it is a shorthand for <code>show _ from</code>, where the blank gets filled in with the goal. Thus, you can think of <code>apply?</code>’s answer as a shortened form of the tactic</p>
<div class="ind">
<pre><code>show x ∈ X ∨ x ∈ Y ↔ x ∈ Y ∨ x ∈ X from or_comm</code></pre>
</div>
<p>Of course, this is precisely the step we used earlier to complete the proof.</p>
<p>Usually your proof will be more readable if you use the <code>show</code> tactic to state explicitly the goal that is being proven. This also gives Lean a chance to correct you if you have become confused about what goal you are proving. But sometimes—for example, if the goal is very long—it is convenient to use the <code>exact</code> tactic instead. You might think of <code>exact</code> as meaning “the following is a term-mode proof that is exactly what is needed to prove the goal.”</p>
<p>The <code>apply?</code> tactic has not only come up with a suggested tactic, it has applied that tactic, and the proof is now complete. You can confirm that the tactic completes the proof by replacing the line <code>apply?</code> in the proof with <code>apply?</code>’s suggested <code>exact</code> tactic.</p>
<p>The <code>apply?</code> tactic is somewhat unpredictable; sometimes it is able to find the right theorem in the library, and sometimes it isn’t. But it is always worth a try. Another way to try to find theorems is to visit the documentation page for Lean’s mathematics library, which can be found at <a href="https://leanprover-community.github.io/mathlib4_docs/">https://leanprover-community.github.io/mathlib4_docs/</a>.</p>
</section>
<section id="exercises-4" class="level3">
<h3 class="anchored" data-anchor-id="exercises-4">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb255"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb255-1"><a href="#cb255-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_4_15 (U : <span class="kw">Type</span>) (B : Set U) (F : Set (Set U)) :</span>
<span id="cb255-2"><a href="#cb255-2" aria-hidden="true" tabindex="-1"></a>    ⋃₀ { X : Set U | ∃ (A : Set U), A ∈ F ∧ X = A \ B }</span>
<span id="cb255-3"><a href="#cb255-3" aria-hidden="true" tabindex="-1"></a>      ⊆ ⋃₀ (F \ 𝒫 B) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb256"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb256-1"><a href="#cb256-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_5_9 (U : <span class="kw">Type</span>) (A B : Set U)</span>
<span id="cb256-2"><a href="#cb256-2" aria-hidden="true" tabindex="-1"></a>    (h1 : 𝒫 (A ∪ B) = 𝒫 A ∪ 𝒫 B) : A ⊆ B ∨ B ⊆ A := <span class="kw">by</span></span>
<span id="cb256-3"><a href="#cb256-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">--Hint:  Start like this:</span></span>
<span id="cb256-4"><a href="#cb256-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : A ∪ B ∈ 𝒫 (A ∪ B) := <span class="cn">sorry</span></span>
<span id="cb256-5"><a href="#cb256-5" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb257"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb257-1"><a href="#cb257-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_6_6b (U : <span class="kw">Type</span>) :</span>
<span id="cb257-2"><a href="#cb257-2" aria-hidden="true" tabindex="-1"></a>    ∃! (A : Set U), ∀ (B : Set U), A ∪ B = A := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb258"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb258-1"><a href="#cb258-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_6_7b (U : <span class="kw">Type</span>) :</span>
<span id="cb258-2"><a href="#cb258-2" aria-hidden="true" tabindex="-1"></a>    ∃! (A : Set U), ∀ (B : Set U), A ∩ B = A := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb259"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb259-1"><a href="#cb259-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_6_8a (U : <span class="kw">Type</span>) : ∀ (A : Set U),</span>
<span id="cb259-2"><a href="#cb259-2" aria-hidden="true" tabindex="-1"></a>    ∃! (B : Set U), ∀ (C : Set U), C \ A = C ∩ B := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="6">
<div class="sourceCode" id="cb260"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb260-1"><a href="#cb260-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_6_10 (U : <span class="kw">Type</span>) (A : Set U)</span>
<span id="cb260-2"><a href="#cb260-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (F : Set (Set U)), ⋃₀ F = A → A ∈ F) :</span>
<span id="cb260-3"><a href="#cb260-3" aria-hidden="true" tabindex="-1"></a>    ∃! (x : U), x ∈ A := <span class="kw">by</span></span>
<span id="cb260-4"><a href="#cb260-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">--Hint:  Start like this:</span></span>
<span id="cb260-5"><a href="#cb260-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> F0 : Set (Set U) := { X : Set U | X ⊆ A ∧ ∃! (x : U), x ∈ X }</span>
<span id="cb260-6"><a href="#cb260-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">--Now F0 is in the tactic state, with the definition above</span></span>
<span id="cb260-7"><a href="#cb260-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : ⋃₀ F0 = A := <span class="cn">sorry</span></span>
<span id="cb260-8"><a href="#cb260-8" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb260-9"><a href="#cb260-9" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="more-examples-of-proofs" class="level2">
<h2 class="anchored" data-anchor-id="more-examples-of-proofs">3.7. More Examples of Proofs</h2>
<p>It is finally time to discuss proofs involving algebraic reasoning. Lean has types for several different kinds of numbers. <code>Nat</code> is the type of natural numbers—that is, the numbers 0, 1, 2, …. <code>Int</code> is the type of integers, <code>Rat</code> is the type of rational numbers, <code>Real</code> is the type of real numbers, and <code>Complex</code> is the type of complex numbers. Lean also uses the notation <code>ℕ</code>, <code>ℤ</code>, <code>ℚ</code>, <code>ℝ</code>, and <code>ℂ</code> for these types. (If you want to use those names for the number types, you can enter them by typing <code>\N</code>, <code>\Z</code>, <code>\Q</code>, <code>\R</code>, and <code>\C</code>.) To write formulas involving arithmetic operations, you should use the symbols <code>+</code> for addition, <code>-</code> for subtraction, <code>*</code> for multiplication, <code>/</code> for division, and <code>^</code> for exponentiation. You can enter the symbols <code>≤</code>, <code>≥</code>, and <code>≠</code> by typing <code>\le</code>, <code>\ge</code>, and <code>\ne</code>, respectively. We will discuss some of the more subtle points of algebraic reasoning in Chapter 6. For the moment, you are best off avoiding subtraction and division when working with natural numbers and avoiding division when working with integers.</p>
<p>To see what’s involved in proving theorems about numbers in Lean, we’ll turn to a few examples from earlier in Chapter 3 of <em>HTPI</em>. We begin with Theorem 3.3.7, which concerns divisibility of integers. As in <em>HTPI</em>, for integers <code>x</code> and <code>y</code>, we will write <code>x ∣ y</code> to mean that <code>x</code> divides <code>y</code>, or <code>y</code> is divisible by <code>x</code>. The formal definition is that <code>x ∣ y</code> means that there is an integer <code>k</code> such that <code>y = x * k</code>. For example, <code>3 ∣ 12</code>, since <code>12 = 3 * 4</code>. Lean knows this notation, but there is an important warning: to type the vertical line that means “divides,” you must type <code>\|</code>, not simply <code>|</code>. (There are two slightly different vertical line symbols, and you have to look closely to see that they are different: <code>|</code> and <code>∣</code>. It is the second one that means “divides” in Lean, and to enter it you must type <code>\|</code>.) Here is Theorem 3.3.7, written using our usual rephrasing of a statement of the form <code>A ∧ B → C</code> as <code>A → B → C</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb261"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb261-1"><a href="#cb261-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_3_3_7 :</span>
<span id="cb261-2"><a href="#cb261-2" aria-hidden="true" tabindex="-1"></a>    ∀ (a b c : Int), a ∣ b → b ∣ c → a ∣ c := <span class="kw">by</span></span>
<span id="cb261-3"><a href="#cb261-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb261-4"><a href="#cb261-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb262"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb262-1"><a href="#cb262-1" aria-hidden="true" tabindex="-1"></a>⊢ ∀ (a b c : ℤ),</span>
<span id="cb262-2"><a href="#cb262-2" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  a ∣ b → b ∣ c → a ∣ c</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Of course, we begin the proof by introducing arbitrary integers <code>a</code>, <code>b</code>, and <code>c</code>, and assuming <code>a ∣ b</code> and <code>b ∣ c</code>. We also write out the definitions of our assumptions and the goal.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb263"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb263-1"><a href="#cb263-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_3_3_7 :</span>
<span id="cb263-2"><a href="#cb263-2" aria-hidden="true" tabindex="-1"></a>    ∀ (a b c : Int), a ∣ b → b ∣ c → a ∣ c := <span class="kw">by</span></span>
<span id="cb263-3"><a href="#cb263-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : Int; <span class="kw">fix</span> b : Int; <span class="kw">fix</span> c : Int</span>
<span id="cb263-4"><a href="#cb263-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : a ∣ b; <span class="kw">assume</span> h2 : b ∣ c</span>
<span id="cb263-5"><a href="#cb263-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1; <span class="kw">define</span> <span class="kw">at</span> h2; <span class="kw">define</span></span>
<span id="cb263-6"><a href="#cb263-6" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb264"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb264-1"><a href="#cb264-1" aria-hidden="true" tabindex="-1"></a><span class="in">a b c </span>: ℤ</span>
<span id="cb264-2"><a href="#cb264-2" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∃ (c : ℤ),</span>
<span id="cb264-3"><a href="#cb264-3" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  b = a * c</span>
<span id="cb264-4"><a href="#cb264-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (c_1 : ℤ),</span>
<span id="cb264-5"><a href="#cb264-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  c = b * c_1</span>
<span id="cb264-6"><a href="#cb264-6" aria-hidden="true" tabindex="-1"></a>⊢ ∃ (c_1 : ℤ),</span>
<span id="cb264-7"><a href="#cb264-7" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  c = a * c_1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>We always use existential givens right away, so we use <code>h1</code> and <code>h2</code> to introduce two new variables, <code>m</code> and <code>n</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb265"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb265-1"><a href="#cb265-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_3_3_7 :</span>
<span id="cb265-2"><a href="#cb265-2" aria-hidden="true" tabindex="-1"></a>    ∀ (a b c : Int), a ∣ b → b ∣ c → a ∣ c := <span class="kw">by</span></span>
<span id="cb265-3"><a href="#cb265-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : Int; <span class="kw">fix</span> b : Int; <span class="kw">fix</span> c : Int</span>
<span id="cb265-4"><a href="#cb265-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : a ∣ b; <span class="kw">assume</span> h2 : b ∣ c</span>
<span id="cb265-5"><a href="#cb265-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1; <span class="kw">define</span> <span class="kw">at</span> h2; <span class="kw">define</span></span>
<span id="cb265-6"><a href="#cb265-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (m : Int) (h3 : b = a * m) <span class="kw">from</span> h1</span>
<span id="cb265-7"><a href="#cb265-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (n : Int) (h4 : c = b * n) <span class="kw">from</span> h2</span>
<span id="cb265-8"><a href="#cb265-8" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb266"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb266-1"><a href="#cb266-1" aria-hidden="true" tabindex="-1"></a><span class="in">a b c </span>: ℤ</span>
<span id="cb266-2"><a href="#cb266-2" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∃ (c : ℤ),</span>
<span id="cb266-3"><a href="#cb266-3" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  b = a * c</span>
<span id="cb266-4"><a href="#cb266-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (c_1 : ℤ),</span>
<span id="cb266-5"><a href="#cb266-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  c = b * c_1</span>
<span id="cb266-6"><a href="#cb266-6" aria-hidden="true" tabindex="-1"></a><span class="in">m </span>: ℤ</span>
<span id="cb266-7"><a href="#cb266-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: b = a * m</span>
<span id="cb266-8"><a href="#cb266-8" aria-hidden="true" tabindex="-1"></a><span class="in">n </span>: ℤ</span>
<span id="cb266-9"><a href="#cb266-9" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: c = b * n</span>
<span id="cb266-10"><a href="#cb266-10" aria-hidden="true" tabindex="-1"></a>⊢ ∃ (c_1 : ℤ),</span>
<span id="cb266-11"><a href="#cb266-11" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  c = a * c_1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>If we substitute the value for <code>b</code> given in <code>h3</code> into <code>h4</code>, we will see how to reach the goal. Of course, the <code>rewrite</code> tactic is what we need for this.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb267"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb267-1"><a href="#cb267-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_3_3_7 :</span>
<span id="cb267-2"><a href="#cb267-2" aria-hidden="true" tabindex="-1"></a>    ∀ (a b c : Int), a ∣ b → b ∣ c → a ∣ c := <span class="kw">by</span></span>
<span id="cb267-3"><a href="#cb267-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : Int; <span class="kw">fix</span> b : Int; <span class="kw">fix</span> c : Int</span>
<span id="cb267-4"><a href="#cb267-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : a ∣ b; <span class="kw">assume</span> h2 : b ∣ c</span>
<span id="cb267-5"><a href="#cb267-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1; <span class="kw">define</span> <span class="kw">at</span> h2; <span class="kw">define</span></span>
<span id="cb267-6"><a href="#cb267-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (m : Int) (h3 : b = a * m) <span class="kw">from</span> h1</span>
<span id="cb267-7"><a href="#cb267-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (n : Int) (h4 : c = b * n) <span class="kw">from</span> h2</span>
<span id="cb267-8"><a href="#cb267-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h3] <span class="kw">at</span> h4   <span class="co">--h4 : c = a * m * n</span></span>
<span id="cb267-9"><a href="#cb267-9" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb268"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb268-1"><a href="#cb268-1" aria-hidden="true" tabindex="-1"></a><span class="in">a b c </span>: ℤ</span>
<span id="cb268-2"><a href="#cb268-2" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∃ (c : ℤ),</span>
<span id="cb268-3"><a href="#cb268-3" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  b = a * c</span>
<span id="cb268-4"><a href="#cb268-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (c_1 : ℤ),</span>
<span id="cb268-5"><a href="#cb268-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  c = b * c_1</span>
<span id="cb268-6"><a href="#cb268-6" aria-hidden="true" tabindex="-1"></a><span class="in">m </span>: ℤ</span>
<span id="cb268-7"><a href="#cb268-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: b = a * m</span>
<span id="cb268-8"><a href="#cb268-8" aria-hidden="true" tabindex="-1"></a><span class="in">n </span>: ℤ</span>
<span id="cb268-9"><a href="#cb268-9" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: c = a * m * n</span>
<span id="cb268-10"><a href="#cb268-10" aria-hidden="true" tabindex="-1"></a>⊢ ∃ (c_1 : ℤ),</span>
<span id="cb268-11"><a href="#cb268-11" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  c = a * c_1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Looking at <code>h4</code>, we see that the value we should use for <code>c_1</code> in the goal is <code>m * n</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb269"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb269-1"><a href="#cb269-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_3_3_7 :</span>
<span id="cb269-2"><a href="#cb269-2" aria-hidden="true" tabindex="-1"></a>    ∀ (a b c : Int), a ∣ b → b ∣ c → a ∣ c := <span class="kw">by</span></span>
<span id="cb269-3"><a href="#cb269-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : Int; <span class="kw">fix</span> b : Int; <span class="kw">fix</span> c : Int</span>
<span id="cb269-4"><a href="#cb269-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : a ∣ b; <span class="kw">assume</span> h2 : b ∣ c</span>
<span id="cb269-5"><a href="#cb269-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1; <span class="kw">define</span> <span class="kw">at</span> h2; <span class="kw">define</span></span>
<span id="cb269-6"><a href="#cb269-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (m : Int) (h3 : b = a * m) <span class="kw">from</span> h1</span>
<span id="cb269-7"><a href="#cb269-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (n : Int) (h4 : c = b * n) <span class="kw">from</span> h2</span>
<span id="cb269-8"><a href="#cb269-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h3] <span class="kw">at</span> h4   <span class="co">--h4 : c = a * m * n</span></span>
<span id="cb269-9"><a href="#cb269-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (m * n)</span>
<span id="cb269-10"><a href="#cb269-10" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb270"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb270-1"><a href="#cb270-1" aria-hidden="true" tabindex="-1"></a><span class="in">a b c </span>: ℤ</span>
<span id="cb270-2"><a href="#cb270-2" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∃ (c : ℤ),</span>
<span id="cb270-3"><a href="#cb270-3" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  b = a * c</span>
<span id="cb270-4"><a href="#cb270-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (c_1 : ℤ),</span>
<span id="cb270-5"><a href="#cb270-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  c = b * c_1</span>
<span id="cb270-6"><a href="#cb270-6" aria-hidden="true" tabindex="-1"></a><span class="in">m </span>: ℤ</span>
<span id="cb270-7"><a href="#cb270-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: b = a * m</span>
<span id="cb270-8"><a href="#cb270-8" aria-hidden="true" tabindex="-1"></a><span class="in">n </span>: ℤ</span>
<span id="cb270-9"><a href="#cb270-9" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: c = a * m * n</span>
<span id="cb270-10"><a href="#cb270-10" aria-hidden="true" tabindex="-1"></a>⊢ c = a * (m * n)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Note that in the application of <code>Exists.intro</code>, the parentheses around <code>m * n</code> are necessary to help Lean parse the line correctly. Comparing <code>h4</code> to the goal, you might think that we can finish the proof with <code>show c = a * (m * n) from h4</code>. But if you try it, you will get an error message. What’s the problem? The difference in the parentheses is the clue. Lean groups the arithmetic operations <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code> to the left, so <code>h4</code> means <code>h4 : c = (a * m) * n</code>, which is not quite the same as the goal. To prove the goal, we will need to apply the associative law for multiplication.</p>
<p>We have already seen that <code>and_assoc</code> is Lean’s name for the associative law for “and”. Perhaps you can guess that the name for the associative law for multiplication is <code>mul_assoc</code>. If you type <code>#check @mul_assoc</code>, Lean’s response will be:</p>
<div class="ind">
<pre><code>@mul_assoc : ∀ {G : Type u_1} [inst : Semigroup G] (a b c : G),
              a * b * c = a * (b * c)</code></pre>
</div>
<p>The implicit arguments in this cases are a little complicated (the expression <code>[inst : Semigroup G]</code> represents yet another kind of implicit argument). But what they mean is that <code>mul_assoc</code> can be used to prove any statement of the form <code>∀ (a b c : G), a * b * c = a * (b * c)</code>, as long as <code>G</code> is a type that has an associative multiplication operation. In particular, <code>mul_assoc</code> can be used as a proof of <code>∀ (a b c : Int), a * b * c = a * (b * c)</code>. (There are also versions of this theorem for particular number types. You can use the <code>#check</code> command to verify the theorems <code>Nat.mul_assoc : ∀ (a b c : ℕ), a * b * c = a * (b * c)</code>, <code>Int.mul_assoc : ∀ (a b c : ℤ), a * b * c = a * (b * c)</code>, and so on.)</p>
<p>Returning to our proof of Theorem 3.3.7, by three applications of universal instantiation, <code>mul_assoc a m n</code> is a proof of <code>a * m * n = a * (m * n)</code>, and that is exactly what we need to finish the proof. The tactic <code>rewrite [mul_assoc a m n] at h4</code> will replace <code>a * m * n</code> in <code>h4</code> with <code>a * (m * n)</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb272"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb272-1"><a href="#cb272-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_3_3_7 :</span>
<span id="cb272-2"><a href="#cb272-2" aria-hidden="true" tabindex="-1"></a>    ∀ (a b c : Int), a ∣ b → b ∣ c → a ∣ c := <span class="kw">by</span></span>
<span id="cb272-3"><a href="#cb272-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : Int; <span class="kw">fix</span> b : Int; <span class="kw">fix</span> c : Int</span>
<span id="cb272-4"><a href="#cb272-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : a ∣ b; <span class="kw">assume</span> h2 : b ∣ c</span>
<span id="cb272-5"><a href="#cb272-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1; <span class="kw">define</span> <span class="kw">at</span> h2; <span class="kw">define</span></span>
<span id="cb272-6"><a href="#cb272-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (m : Int) (h3 : b = a * m) <span class="kw">from</span> h1</span>
<span id="cb272-7"><a href="#cb272-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (n : Int) (h4 : c = b * n) <span class="kw">from</span> h2</span>
<span id="cb272-8"><a href="#cb272-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h3] <span class="kw">at</span> h4   <span class="co">--h4 : c = a * m * n</span></span>
<span id="cb272-9"><a href="#cb272-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (m * n)</span>
<span id="cb272-10"><a href="#cb272-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [mul_assoc a m n] <span class="kw">at</span> h4</span>
<span id="cb272-11"><a href="#cb272-11" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb273"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb273-1"><a href="#cb273-1" aria-hidden="true" tabindex="-1"></a><span class="in">a b c </span>: ℤ</span>
<span id="cb273-2"><a href="#cb273-2" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∃ (c : ℤ),</span>
<span id="cb273-3"><a href="#cb273-3" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  b = a * c</span>
<span id="cb273-4"><a href="#cb273-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (c_1 : ℤ),</span>
<span id="cb273-5"><a href="#cb273-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  c = b * c_1</span>
<span id="cb273-6"><a href="#cb273-6" aria-hidden="true" tabindex="-1"></a><span class="in">m </span>: ℤ</span>
<span id="cb273-7"><a href="#cb273-7" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: b = a * m</span>
<span id="cb273-8"><a href="#cb273-8" aria-hidden="true" tabindex="-1"></a><span class="in">n </span>: ℤ</span>
<span id="cb273-9"><a href="#cb273-9" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: c = a * (m * n)</span>
<span id="cb273-10"><a href="#cb273-10" aria-hidden="true" tabindex="-1"></a>⊢ c = a * (m * n)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>By the way, this is a case in which Lean could have figured out some details on its own. If we had used <code>rewrite [mul_assoc _ _ _] at h4</code>, then Lean would have figured out that the blanks had to be filled in with <code>a</code>, <code>m</code>, and <code>n</code>. And as with the <code>apply</code> tactic, blanks at the end of <code>rewrite</code> rules can be left out, so even <code>rewrite [mul_assoc] at h4</code> would have worked.</p>
<p>Of course, now <code>h4</code> really does match the goal exactly, so we can use it to complete the proof.</p>
<div class="sourceCode" id="cb274"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb274-1"><a href="#cb274-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_3_3_7 :</span>
<span id="cb274-2"><a href="#cb274-2" aria-hidden="true" tabindex="-1"></a>    ∀ (a b c : Int), a ∣ b → b ∣ c → a ∣ c := <span class="kw">by</span></span>
<span id="cb274-3"><a href="#cb274-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : Int; <span class="kw">fix</span> b : Int; <span class="kw">fix</span> c : Int</span>
<span id="cb274-4"><a href="#cb274-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : a ∣ b; <span class="kw">assume</span> h2 : b ∣ c</span>
<span id="cb274-5"><a href="#cb274-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1; <span class="kw">define</span> <span class="kw">at</span> h2; <span class="kw">define</span></span>
<span id="cb274-6"><a href="#cb274-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (m : Int) (h3 : b = a * m) <span class="kw">from</span> h1</span>
<span id="cb274-7"><a href="#cb274-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (n : Int) (h4 : c = b * n) <span class="kw">from</span> h2</span>
<span id="cb274-8"><a href="#cb274-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h3] <span class="kw">at</span> h4   <span class="co">--h4 : c = a * m * n</span></span>
<span id="cb274-9"><a href="#cb274-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (m * n)</span>
<span id="cb274-10"><a href="#cb274-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [mul_assoc a m n] <span class="kw">at</span> h4</span>
<span id="cb274-11"><a href="#cb274-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> c = a * (m * n) <span class="kw">from</span> h4</span>
<span id="cb274-12"><a href="#cb274-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>As usual, you might find it instructive to compare the Lean proof above to the proof of this theorem in <em>HTPI</em>.</p>
<p>For our next example, we’ll do a somewhat more complex proof concerning divisibility. Here is the proof from <em>HTPI</em> (<em>HTPI</em> p.&nbsp;139).</p>
<div class="nthm" data-arguments="Theorem 3.4.7">
<p>For every integer <span class="math inline">\(n\)</span>, <span class="math inline">\(6 \mid n\)</span> iff <span class="math inline">\(2 \mid n\)</span> and <span class="math inline">\(3 \mid n\)</span>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Let <span class="math inline">\(n\)</span> be an arbitrary integer.</p>
<p>(<span class="math inline">\(\to\)</span>) Suppose <span class="math inline">\(6 \mid n\)</span>. Then we can choose an integer <span class="math inline">\(k\)</span> such that <span class="math inline">\(6k=n\)</span>. Therefore <span class="math inline">\(n = 6k = 2(3k)\)</span>, so <span class="math inline">\(2 \mid n\)</span>, and similarly <span class="math inline">\(n = 6k = 3(2k)\)</span>, so <span class="math inline">\(3 \mid n\)</span>.</p>
<p>(<span class="math inline">\(\leftarrow\)</span>) Suppose <span class="math inline">\(2 \mid n\)</span> and <span class="math inline">\(3 \mid n\)</span>. Then we can choose integers <span class="math inline">\(j\)</span> and <span class="math inline">\(k\)</span> such that <span class="math inline">\(n = 2j\)</span> and <span class="math inline">\(n = 3k\)</span>. Therefore <span class="math inline">\(6(j-k) = 6j - 6k = 3(2j) - 2(3k) = 3n - 2n = n\)</span>, so <span class="math inline">\(6 \mid n\)</span>. <span class="excl">&nbsp;□</span></p>
</div>
<p>Let’s try writing the proof in Lean. We use exactly the same strategy as in the <em>HTPI</em> proof: we begin by fixing an arbitrary integer <code>n</code>, and then we prove the two directions of the biconditional separately.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb275"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb275-1"><a href="#cb275-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_3_4_7 :</span>
<span id="cb275-2"><a href="#cb275-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Int), 6 ∣ n ↔ 2 ∣ n ∧ 3 ∣ n := <span class="kw">by</span></span>
<span id="cb275-3"><a href="#cb275-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> n : Int</span>
<span id="cb275-4"><a href="#cb275-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb275-5"><a href="#cb275-5" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb276"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb276-1"><a href="#cb276-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mp</span>
<span id="cb276-2"><a href="#cb276-2" aria-hidden="true" tabindex="-1"></a><span class="in">n </span>: ℤ</span>
<span id="cb276-3"><a href="#cb276-3" aria-hidden="true" tabindex="-1"></a>⊢ 6 ∣ n → 2 ∣ n ∧ 3 ∣ n</span>
<span id="cb276-4"><a href="#cb276-4" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mpr</span>
<span id="cb276-5"><a href="#cb276-5" aria-hidden="true" tabindex="-1"></a><span class="in">n </span>: ℤ</span>
<span id="cb276-6"><a href="#cb276-6" aria-hidden="true" tabindex="-1"></a>⊢ 2 ∣ n ∧ 3 ∣ n → 6 ∣ n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>For the left-to-right direction, we assume <code>6 ∣ n</code>, and since the definition of this assumption is an existential statement, we immediately apply existential instantiation.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb277"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb277-1"><a href="#cb277-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_3_4_7 :</span>
<span id="cb277-2"><a href="#cb277-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Int), 6 ∣ n ↔ 2 ∣ n ∧ 3 ∣ n := <span class="kw">by</span></span>
<span id="cb277-3"><a href="#cb277-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> n : Int</span>
<span id="cb277-4"><a href="#cb277-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb277-5"><a href="#cb277-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb277-6"><a href="#cb277-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : 6 ∣ n; <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb277-7"><a href="#cb277-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (k : Int) (h2 : n = 6 * k) <span class="kw">from</span> h1</span>
<span id="cb277-8"><a href="#cb277-8" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb277-9"><a href="#cb277-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb277-10"><a href="#cb277-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb277-11"><a href="#cb277-11" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb277-12"><a href="#cb277-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb278"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb278-1"><a href="#cb278-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mp</span>
<span id="cb278-2"><a href="#cb278-2" aria-hidden="true" tabindex="-1"></a><span class="in">n </span>: ℤ</span>
<span id="cb278-3"><a href="#cb278-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∃ (c : ℤ),</span>
<span id="cb278-4"><a href="#cb278-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  n = 6 * c</span>
<span id="cb278-5"><a href="#cb278-5" aria-hidden="true" tabindex="-1"></a><span class="in">k </span>: ℤ</span>
<span id="cb278-6"><a href="#cb278-6" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: n = 6 * k</span>
<span id="cb278-7"><a href="#cb278-7" aria-hidden="true" tabindex="-1"></a>⊢ 2 ∣ n ∧ 3 ∣ n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Our goal is now a conjunction, so we prove the two conjuncts separately. Focusing just on the first one, <code>2 ∣ n</code>, we write out the definition to decide how to proceed.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb279"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb279-1"><a href="#cb279-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_3_4_7 :</span>
<span id="cb279-2"><a href="#cb279-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Int), 6 ∣ n ↔ 2 ∣ n ∧ 3 ∣ n := <span class="kw">by</span></span>
<span id="cb279-3"><a href="#cb279-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> n : Int</span>
<span id="cb279-4"><a href="#cb279-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb279-5"><a href="#cb279-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb279-6"><a href="#cb279-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : 6 ∣ n; <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb279-7"><a href="#cb279-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (k : Int) (h2 : n = 6 * k) <span class="kw">from</span> h1</span>
<span id="cb279-8"><a href="#cb279-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro</span>
<span id="cb279-9"><a href="#cb279-9" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that 2 ∣ n</span></span>
<span id="cb279-10"><a href="#cb279-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span></span>
<span id="cb279-11"><a href="#cb279-11" aria-hidden="true" tabindex="-1"></a>      <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb279-12"><a href="#cb279-12" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that 3 ∣ n</span></span>
<span id="cb279-13"><a href="#cb279-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-14"><a href="#cb279-14" aria-hidden="true" tabindex="-1"></a>      <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb279-15"><a href="#cb279-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb279-16"><a href="#cb279-16" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb279-17"><a href="#cb279-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-18"><a href="#cb279-18" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb279-19"><a href="#cb279-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb280"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb280-1"><a href="#cb280-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mp.left</span>
<span id="cb280-2"><a href="#cb280-2" aria-hidden="true" tabindex="-1"></a><span class="in">n </span>: ℤ</span>
<span id="cb280-3"><a href="#cb280-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∃ (c : ℤ),</span>
<span id="cb280-4"><a href="#cb280-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  n = 6 * c</span>
<span id="cb280-5"><a href="#cb280-5" aria-hidden="true" tabindex="-1"></a><span class="in">k </span>: ℤ</span>
<span id="cb280-6"><a href="#cb280-6" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: n = 6 * k</span>
<span id="cb280-7"><a href="#cb280-7" aria-hidden="true" tabindex="-1"></a>⊢ ∃ (c : ℤ), n = 2 * c</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Since we have <code>n = 6 * k = 2 * 3 * k</code>, it looks like <code>3 * k</code> is the value we should use for <code>c</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb281"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb281-1"><a href="#cb281-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_3_4_7 :</span>
<span id="cb281-2"><a href="#cb281-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Int), 6 ∣ n ↔ 2 ∣ n ∧ 3 ∣ n := <span class="kw">by</span></span>
<span id="cb281-3"><a href="#cb281-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> n : Int</span>
<span id="cb281-4"><a href="#cb281-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb281-5"><a href="#cb281-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb281-6"><a href="#cb281-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : 6 ∣ n; <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb281-7"><a href="#cb281-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (k : Int) (h2 : n = 6 * k) <span class="kw">from</span> h1</span>
<span id="cb281-8"><a href="#cb281-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro</span>
<span id="cb281-9"><a href="#cb281-9" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that 2 ∣ n</span></span>
<span id="cb281-10"><a href="#cb281-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span></span>
<span id="cb281-11"><a href="#cb281-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro (3 * k)</span>
<span id="cb281-12"><a href="#cb281-12" aria-hidden="true" tabindex="-1"></a>      <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb281-13"><a href="#cb281-13" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that 3 ∣ n</span></span>
<span id="cb281-14"><a href="#cb281-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb281-15"><a href="#cb281-15" aria-hidden="true" tabindex="-1"></a>      <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb281-16"><a href="#cb281-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb281-17"><a href="#cb281-17" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb281-18"><a href="#cb281-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb281-19"><a href="#cb281-19" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb281-20"><a href="#cb281-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb282"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb282-1"><a href="#cb282-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mp.left</span>
<span id="cb282-2"><a href="#cb282-2" aria-hidden="true" tabindex="-1"></a><span class="in">n </span>: ℤ</span>
<span id="cb282-3"><a href="#cb282-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∃ (c : ℤ),</span>
<span id="cb282-4"><a href="#cb282-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  n = 6 * c</span>
<span id="cb282-5"><a href="#cb282-5" aria-hidden="true" tabindex="-1"></a><span class="in">k </span>: ℤ</span>
<span id="cb282-6"><a href="#cb282-6" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: n = 6 * k</span>
<span id="cb282-7"><a href="#cb282-7" aria-hidden="true" tabindex="-1"></a>⊢ n = 2 * (3 * k)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Once again, if you think carefully about it, you will see that in order to deduce the goal from <code>h2</code>, we will need to use the associativity of multiplication to rewrite the goal as <code>n = 2 * 3 * k</code>. As we have already seen, <code>mul_assoc 2 3 k</code> is a proof of <code>2 * 3 * k = 2 * (3 * k)</code>. Since we want to replace the right side of this equation with the left in the goal, we’ll use the tactic <code>rewrite [←mul_assoc 2 3 k]</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb283"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb283-1"><a href="#cb283-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_3_4_7 :</span>
<span id="cb283-2"><a href="#cb283-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Int), 6 ∣ n ↔ 2 ∣ n ∧ 3 ∣ n := <span class="kw">by</span></span>
<span id="cb283-3"><a href="#cb283-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> n : Int</span>
<span id="cb283-4"><a href="#cb283-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb283-5"><a href="#cb283-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb283-6"><a href="#cb283-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : 6 ∣ n; <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb283-7"><a href="#cb283-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (k : Int) (h2 : n = 6 * k) <span class="kw">from</span> h1</span>
<span id="cb283-8"><a href="#cb283-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro</span>
<span id="cb283-9"><a href="#cb283-9" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that 2 ∣ n</span></span>
<span id="cb283-10"><a href="#cb283-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span></span>
<span id="cb283-11"><a href="#cb283-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro (3 * k)</span>
<span id="cb283-12"><a href="#cb283-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [←mul_assoc 2 3 k]</span>
<span id="cb283-13"><a href="#cb283-13" aria-hidden="true" tabindex="-1"></a>      <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb283-14"><a href="#cb283-14" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that 3 ∣ n</span></span>
<span id="cb283-15"><a href="#cb283-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb283-16"><a href="#cb283-16" aria-hidden="true" tabindex="-1"></a>      <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb283-17"><a href="#cb283-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb283-18"><a href="#cb283-18" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb283-19"><a href="#cb283-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb283-20"><a href="#cb283-20" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb283-21"><a href="#cb283-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb284"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb284-1"><a href="#cb284-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mp.left</span>
<span id="cb284-2"><a href="#cb284-2" aria-hidden="true" tabindex="-1"></a><span class="in">n </span>: ℤ</span>
<span id="cb284-3"><a href="#cb284-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∃ (c : ℤ),</span>
<span id="cb284-4"><a href="#cb284-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  n = 6 * c</span>
<span id="cb284-5"><a href="#cb284-5" aria-hidden="true" tabindex="-1"></a><span class="in">k </span>: ℤ</span>
<span id="cb284-6"><a href="#cb284-6" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: n = 6 * k</span>
<span id="cb284-7"><a href="#cb284-7" aria-hidden="true" tabindex="-1"></a>⊢ n = 2 * 3 * k</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Do we have to convince Lean that <code>2 * 3 = 6</code>? No, remember that Lean works out definitions on its own. Lean knows the definition of multiplication, and it knows that, according to that definition, <code>2 * 3</code> is equal to <code>6</code>. So it regards <code>n = 6 * k</code> and <code>n = 2 * 3 * k</code> as definitionally equal, and therefore it will recognize <code>h2</code> as a proof of the goal.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb285"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb285-1"><a href="#cb285-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_3_4_7 :</span>
<span id="cb285-2"><a href="#cb285-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Int), 6 ∣ n ↔ 2 ∣ n ∧ 3 ∣ n := <span class="kw">by</span></span>
<span id="cb285-3"><a href="#cb285-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> n : Int</span>
<span id="cb285-4"><a href="#cb285-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb285-5"><a href="#cb285-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb285-6"><a href="#cb285-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : 6 ∣ n; <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb285-7"><a href="#cb285-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (k : Int) (h2 : n = 6 * k) <span class="kw">from</span> h1</span>
<span id="cb285-8"><a href="#cb285-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro</span>
<span id="cb285-9"><a href="#cb285-9" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that 2 ∣ n</span></span>
<span id="cb285-10"><a href="#cb285-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span></span>
<span id="cb285-11"><a href="#cb285-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro (3 * k)</span>
<span id="cb285-12"><a href="#cb285-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [←mul_assoc 2 3 k]</span>
<span id="cb285-13"><a href="#cb285-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> n = 2 * 3 * k <span class="kw">from</span> h2</span>
<span id="cb285-14"><a href="#cb285-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb285-15"><a href="#cb285-15" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that 3 ∣ n</span></span>
<span id="cb285-16"><a href="#cb285-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb285-17"><a href="#cb285-17" aria-hidden="true" tabindex="-1"></a>      <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb285-18"><a href="#cb285-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb285-19"><a href="#cb285-19" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb285-20"><a href="#cb285-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb285-21"><a href="#cb285-21" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb285-22"><a href="#cb285-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb286"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb286-1"><a href="#cb286-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mp.right</span>
<span id="cb286-2"><a href="#cb286-2" aria-hidden="true" tabindex="-1"></a><span class="in">n </span>: ℤ</span>
<span id="cb286-3"><a href="#cb286-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: ∃ (c : ℤ),</span>
<span id="cb286-4"><a href="#cb286-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  n = 6 * c</span>
<span id="cb286-5"><a href="#cb286-5" aria-hidden="true" tabindex="-1"></a><span class="in">k </span>: ℤ</span>
<span id="cb286-6"><a href="#cb286-6" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: n = 6 * k</span>
<span id="cb286-7"><a href="#cb286-7" aria-hidden="true" tabindex="-1"></a>⊢ 3 ∣ n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The proof of the next goal, <code>3 ∣ n</code>, is similar, and it completes the left-to-right direction of the biconditional.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb287"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb287-1"><a href="#cb287-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_3_4_7 :</span>
<span id="cb287-2"><a href="#cb287-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Int), 6 ∣ n ↔ 2 ∣ n ∧ 3 ∣ n := <span class="kw">by</span></span>
<span id="cb287-3"><a href="#cb287-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> n : Int</span>
<span id="cb287-4"><a href="#cb287-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb287-5"><a href="#cb287-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb287-6"><a href="#cb287-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : 6 ∣ n; <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb287-7"><a href="#cb287-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (k : Int) (h2 : n = 6 * k) <span class="kw">from</span> h1</span>
<span id="cb287-8"><a href="#cb287-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro</span>
<span id="cb287-9"><a href="#cb287-9" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that 2 ∣ n</span></span>
<span id="cb287-10"><a href="#cb287-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span></span>
<span id="cb287-11"><a href="#cb287-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro (3 * k)</span>
<span id="cb287-12"><a href="#cb287-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [←mul_assoc 2 3 k]</span>
<span id="cb287-13"><a href="#cb287-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> n = 2 * 3 * k <span class="kw">from</span> h2</span>
<span id="cb287-14"><a href="#cb287-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb287-15"><a href="#cb287-15" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that 3 ∣ n</span></span>
<span id="cb287-16"><a href="#cb287-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span></span>
<span id="cb287-17"><a href="#cb287-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro (2 * k)</span>
<span id="cb287-18"><a href="#cb287-18" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [←mul_assoc 3 2 k]</span>
<span id="cb287-19"><a href="#cb287-19" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> n = 3 * 2 * k <span class="kw">from</span> h2</span>
<span id="cb287-20"><a href="#cb287-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb287-21"><a href="#cb287-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb287-22"><a href="#cb287-22" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb287-23"><a href="#cb287-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb287-24"><a href="#cb287-24" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb287-25"><a href="#cb287-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb288"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb288-1"><a href="#cb288-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mpr</span>
<span id="cb288-2"><a href="#cb288-2" aria-hidden="true" tabindex="-1"></a><span class="in">n </span>: ℤ</span>
<span id="cb288-3"><a href="#cb288-3" aria-hidden="true" tabindex="-1"></a>⊢ 2 ∣ n ∧ 3 ∣ n → 6 ∣ n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>For the right-to-left direction, we begin by assuming <code>2 ∣ n ∧ 3 ∣ n</code>. We write out the definitions of <code>2 ∣ n</code> and <code>3 ∣ n</code>, and since this gives us two existential givens, we apply existential instantiation twice. To save space, we won’t repeat the proof of the first half of the proof in the displays below.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb289"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb289-1"><a href="#cb289-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_3_4_7 :</span>
<span id="cb289-2"><a href="#cb289-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Int), 6 ∣ n ↔ 2 ∣ n ∧ 3 ∣ n := <span class="kw">by</span></span>
<span id="cb289-3"><a href="#cb289-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> n : Int</span>
<span id="cb289-4"><a href="#cb289-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb289-5"><a href="#cb289-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb289-6"><a href="#cb289-6" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb289-7"><a href="#cb289-7" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb289-8"><a href="#cb289-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : 2 ∣ n ∧ 3 ∣ n</span>
<span id="cb289-9"><a href="#cb289-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : 2 ∣ n := h1.left</span>
<span id="cb289-10"><a href="#cb289-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : 3 ∣ n := h1.right</span>
<span id="cb289-11"><a href="#cb289-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h2; <span class="kw">define</span> <span class="kw">at</span> h3; <span class="kw">define</span></span>
<span id="cb289-12"><a href="#cb289-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (j : Int) (h4 : n = 2 * j) <span class="kw">from</span> h2</span>
<span id="cb289-13"><a href="#cb289-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (k : Int) (h5 : n = 3 * k) <span class="kw">from</span> h3</span>
<span id="cb289-14"><a href="#cb289-14" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb289-15"><a href="#cb289-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb290"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb290-1"><a href="#cb290-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> mpr</span>
<span id="cb290-2"><a href="#cb290-2" aria-hidden="true" tabindex="-1"></a><span class="in">n </span>: ℤ</span>
<span id="cb290-3"><a href="#cb290-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: 2 ∣ n ∧ 3 ∣ n</span>
<span id="cb290-4"><a href="#cb290-4" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (c : ℤ),</span>
<span id="cb290-5"><a href="#cb290-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  n = 2 * c</span>
<span id="cb290-6"><a href="#cb290-6" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: ∃ (c : ℤ),</span>
<span id="cb290-7"><a href="#cb290-7" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  n = 3 * c</span>
<span id="cb290-8"><a href="#cb290-8" aria-hidden="true" tabindex="-1"></a><span class="in">j </span>: ℤ</span>
<span id="cb290-9"><a href="#cb290-9" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: n = 2 * j</span>
<span id="cb290-10"><a href="#cb290-10" aria-hidden="true" tabindex="-1"></a><span class="in">k </span>: ℤ</span>
<span id="cb290-11"><a href="#cb290-11" aria-hidden="true" tabindex="-1"></a><span class="in">h5 </span>: n = 3 * k</span>
<span id="cb290-12"><a href="#cb290-12" aria-hidden="true" tabindex="-1"></a>⊢ ∃ (c : ℤ),</span>
<span id="cb290-13"><a href="#cb290-13" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  n = 6 * c</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The next step in the <em>HTPI</em> proof is a string of equations that proves <span class="math inline">\(6(j - k) = n\)</span>, which establishes that <span class="math inline">\(6 \mid n\)</span>. Let’s try to do the same thing in Lean, using a calculational proof:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb291"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb291-1"><a href="#cb291-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> <span class="sc">??</span><span class="an">Theorem_3_4_7</span><span class="sc">::</span> :</span>
<span id="cb291-2"><a href="#cb291-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Int), 6 ∣ n ↔ 2 ∣ n ∧ 3 ∣ n := <span class="kw">by</span></span>
<span id="cb291-3"><a href="#cb291-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> n : Int</span>
<span id="cb291-4"><a href="#cb291-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb291-5"><a href="#cb291-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb291-6"><a href="#cb291-6" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb291-7"><a href="#cb291-7" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb291-8"><a href="#cb291-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : 2 ∣ n ∧ 3 ∣ n</span>
<span id="cb291-9"><a href="#cb291-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : 2 ∣ n := h1.left</span>
<span id="cb291-10"><a href="#cb291-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : 3 ∣ n := h1.right</span>
<span id="cb291-11"><a href="#cb291-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h2; <span class="kw">define</span> <span class="kw">at</span> h3; <span class="kw">define</span></span>
<span id="cb291-12"><a href="#cb291-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (j : Int) (h4 : n = 2 * j) <span class="kw">from</span> h2</span>
<span id="cb291-13"><a href="#cb291-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (k : Int) (h5 : n = 3 * k) <span class="kw">from</span> h3</span>
<span id="cb291-14"><a href="#cb291-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h6 : 6 * (j - k) = n :=</span>
<span id="cb291-15"><a href="#cb291-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> 6 * (j - k)</span>
<span id="cb291-16"><a href="#cb291-16" aria-hidden="true" tabindex="-1"></a>        _ = 6 * j - 6 * k := <span class="cn">sorry</span></span>
<span id="cb291-17"><a href="#cb291-17" aria-hidden="true" tabindex="-1"></a>        _ = 3 * (2 * j) - 2 * (3 * k) := <span class="cn">sorry</span></span>
<span id="cb291-18"><a href="#cb291-18" aria-hidden="true" tabindex="-1"></a>        _ = 3 * n - 2 * n := <span class="cn">sorry</span></span>
<span id="cb291-19"><a href="#cb291-19" aria-hidden="true" tabindex="-1"></a>        _ = (3 - 2) * n := <span class="cn">sorry</span></span>
<span id="cb291-20"><a href="#cb291-20" aria-hidden="true" tabindex="-1"></a>        _ = n := <span class="cn">sorry</span></span>
<span id="cb291-21"><a href="#cb291-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ∃ (c : Int), n = 6 * c <span class="kw">from</span></span>
<span id="cb291-22"><a href="#cb291-22" aria-hidden="true" tabindex="-1"></a>      Exists.intro (j - k) h6.symm</span>
<span id="cb291-23"><a href="#cb291-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb291-24"><a href="#cb291-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb292"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb292-1"><a href="#cb292-1" aria-hidden="true" tabindex="-1"></a><span class="ss">No</span><span class="in"> </span><span class="ss">goals</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Sometimes the easiest way to write a calculational proof is to justify each line with <code>sorry</code> and then go back and fill in real justifications. Lean has accepted the proof above, so we know that we’ll have a complete proof if we can replace each <code>sorry</code> with a justification.</p>
<p>To justify the first line of the calculational proof, try replacing <code>sorry</code> with <code>by apply?</code>. Lean comes up with a justification: <code>Int.mul_sub 6 j k</code>. The command <code>#check @Int.mul_sub</code> tells us that the theorem <code>Int.mul_sub</code> means</p>
<div class="ind">
<pre><code>Int.mul_sub : ∀ (a b c : ℤ), a * (b - c) = a * b - a * c</code></pre>
</div>
<p>Thus, we can fill in <code>Int.mul_sub 6 j k</code> as a proof of the first equation.</p>
<p>It looks like we’ll have to use the associativity of multiplication again to prove the second equation, but it will take more than one step. Let’s try writing a tactic-mode proof. In the display below, we’ll just focus on the calculational proof.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb294"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb294-1"><a href="#cb294-1" aria-hidden="true" tabindex="-1"></a><span class="kw">have</span> h6 : 6 * (j - k) = n :=</span>
<span id="cb294-2"><a href="#cb294-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">calc</span> 6 * (j - k)</span>
<span id="cb294-3"><a href="#cb294-3" aria-hidden="true" tabindex="-1"></a>    _ = 6 * j - 6 * k := Int.mul_sub 6 j k</span>
<span id="cb294-4"><a href="#cb294-4" aria-hidden="true" tabindex="-1"></a>    _ = 3 * (2 * j) - 2 * (3 * k) := <span class="kw">by</span></span>
<span id="cb294-5"><a href="#cb294-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb294-6"><a href="#cb294-6" aria-hidden="true" tabindex="-1"></a>          <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb294-7"><a href="#cb294-7" aria-hidden="true" tabindex="-1"></a>    _ = 3 * n - 2 * n := <span class="cn">sorry</span></span>
<span id="cb294-8"><a href="#cb294-8" aria-hidden="true" tabindex="-1"></a>    _ = (3 - 2) * n := <span class="cn">sorry</span></span>
<span id="cb294-9"><a href="#cb294-9" aria-hidden="true" tabindex="-1"></a>    _ = n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb295"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb295-1"><a href="#cb295-1" aria-hidden="true" tabindex="-1"></a><span class="in">n </span>: ℤ</span>
<span id="cb295-2"><a href="#cb295-2" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: 2 ∣ n ∧ 3 ∣ n</span>
<span id="cb295-3"><a href="#cb295-3" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (c : ℤ),</span>
<span id="cb295-4"><a href="#cb295-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  n = 2 * c</span>
<span id="cb295-5"><a href="#cb295-5" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: ∃ (c : ℤ),</span>
<span id="cb295-6"><a href="#cb295-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  n = 3 * c</span>
<span id="cb295-7"><a href="#cb295-7" aria-hidden="true" tabindex="-1"></a><span class="in">j </span>: ℤ</span>
<span id="cb295-8"><a href="#cb295-8" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: n = 2 * j</span>
<span id="cb295-9"><a href="#cb295-9" aria-hidden="true" tabindex="-1"></a><span class="in">k </span>: ℤ</span>
<span id="cb295-10"><a href="#cb295-10" aria-hidden="true" tabindex="-1"></a><span class="in">h5 </span>: n = 3 * k</span>
<span id="cb295-11"><a href="#cb295-11" aria-hidden="true" tabindex="-1"></a>⊢ 6 * j - 6 * k =</span>
<span id="cb295-12"><a href="#cb295-12" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  3 * (2 * j) -</span>
<span id="cb295-13"><a href="#cb295-13" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>    2 * (3 * k)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>To justify the second equation, we’ll have to use associativity to rewrite both <code>3 * (2 * j)</code> as <code>3 * 2 * j</code> and also <code>2 * (3 * k)</code> as <code>2 * 3 * k</code>. So we apply the <code>rewrite</code> tactic to both of the proofs <code>mul_assoc 3 2 j : 3 * 2 * j = 3 * (2 * j)</code> and <code>mul_assoc 2 3 k : 2 * 3 * k = 2 * (3 * k)</code>:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb296"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb296-1"><a href="#cb296-1" aria-hidden="true" tabindex="-1"></a><span class="kw">have</span> h6 : 6 * (j - k) = n :=</span>
<span id="cb296-2"><a href="#cb296-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">calc</span> 6 * (j - k)</span>
<span id="cb296-3"><a href="#cb296-3" aria-hidden="true" tabindex="-1"></a>    _ = 6 * j - 6 * k := Int.mul_sub 6 j k</span>
<span id="cb296-4"><a href="#cb296-4" aria-hidden="true" tabindex="-1"></a>    _ = 3 * (2 * j) - 2 * (3 * k) := <span class="kw">by</span></span>
<span id="cb296-5"><a href="#cb296-5" aria-hidden="true" tabindex="-1"></a>          <span class="kw">rewrite</span> [←mul_assoc 3 2 j]</span>
<span id="cb296-6"><a href="#cb296-6" aria-hidden="true" tabindex="-1"></a>          <span class="kw">rewrite</span> [←mul_assoc 2 3 k]</span>
<span id="cb296-7"><a href="#cb296-7" aria-hidden="true" tabindex="-1"></a>          <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb296-8"><a href="#cb296-8" aria-hidden="true" tabindex="-1"></a>    _ = 3 * n - 2 * n := <span class="cn">sorry</span></span>
<span id="cb296-9"><a href="#cb296-9" aria-hidden="true" tabindex="-1"></a>    _ = (3 - 2) * n := <span class="cn">sorry</span></span>
<span id="cb296-10"><a href="#cb296-10" aria-hidden="true" tabindex="-1"></a>    _ = n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb297"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb297-1"><a href="#cb297-1" aria-hidden="true" tabindex="-1"></a><span class="in">n </span>: ℤ</span>
<span id="cb297-2"><a href="#cb297-2" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: 2 ∣ n ∧ 3 ∣ n</span>
<span id="cb297-3"><a href="#cb297-3" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (c : ℤ),</span>
<span id="cb297-4"><a href="#cb297-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  n = 2 * c</span>
<span id="cb297-5"><a href="#cb297-5" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: ∃ (c : ℤ),</span>
<span id="cb297-6"><a href="#cb297-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  n = 3 * c</span>
<span id="cb297-7"><a href="#cb297-7" aria-hidden="true" tabindex="-1"></a><span class="in">j </span>: ℤ</span>
<span id="cb297-8"><a href="#cb297-8" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: n = 2 * j</span>
<span id="cb297-9"><a href="#cb297-9" aria-hidden="true" tabindex="-1"></a><span class="in">k </span>: ℤ</span>
<span id="cb297-10"><a href="#cb297-10" aria-hidden="true" tabindex="-1"></a><span class="in">h5 </span>: n = 3 * k</span>
<span id="cb297-11"><a href="#cb297-11" aria-hidden="true" tabindex="-1"></a>⊢ 6 * j - 6 * k =</span>
<span id="cb297-12"><a href="#cb297-12" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  3 * 2 * j - </span>
<span id="cb297-13"><a href="#cb297-13" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>    2 * 3 * k</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>To finish off the justification of the second equation, we’ll use the theorem <code>Eq.refl</code>. The command <code>#check @Eq.refl</code> gives the result</p>
<div class="ind">
<pre><code>@Eq.refl : ∀ {α : Sort u_1} (a : α), a = a</code></pre>
</div>
<p>Ignoring the implicit argument <code>α</code>, this should remind you of the theorem <code>Iff.refl : ∀ (a : Prop), a ↔︎ a</code>. Recall that we were able to use <code>Iff.refl _</code> to prove not only any statement of the form <code>a ↔︎ a</code>, but also statements of the form <code>a ↔︎ a'</code>, where <code>a</code> and <code>a'</code> are definitionally equal. Similarly, <code>Eq.refl _</code> will prove any equation of the form <code>a = a'</code>, where <code>a</code> and <code>a'</code> are definitionally equal. Since Lean knows that, by definition, <code>3 * 2 = 6</code> and <code>2 * 3 = 6</code>, the goal has this form. Thus we can complete the proof with the tactic <code>show 6 * j - 6 * k = 3 * 2 * j - 2 * 3 * k from Eq.refl _</code>. As we saw earlier, a shorter version of this would be <code>exact Eq.refl _</code>. But this situation comes up often enough that there is an even shorter version: the tactic <code>rfl</code> can be used as a shorthand for either <code>exact Eq.refl _</code> or <code>exact Iff.refl _</code>. In other words, in a tactic-mode proof, if the goal has one of the forms <code>a = a'</code> or <code>a ↔︎ a'</code>, where <code>a</code> and <code>a'</code> are definitionally equal, then the tactic <code>rfl</code> will prove the goal. So <code>rfl</code> will finish off the justification of the second equation, and we can move on to the third.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb299"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb299-1"><a href="#cb299-1" aria-hidden="true" tabindex="-1"></a><span class="kw">have</span> h6 : 6 * (j - k) = n :=</span>
<span id="cb299-2"><a href="#cb299-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">calc</span> 6 * (j - k)</span>
<span id="cb299-3"><a href="#cb299-3" aria-hidden="true" tabindex="-1"></a>    _ = 6 * j - 6 * k := Int.mul_sub 6 j k</span>
<span id="cb299-4"><a href="#cb299-4" aria-hidden="true" tabindex="-1"></a>    _ = 3 * (2 * j) - 2 * (3 * k) := <span class="kw">by</span></span>
<span id="cb299-5"><a href="#cb299-5" aria-hidden="true" tabindex="-1"></a>          <span class="kw">rewrite</span> [←mul_assoc 3 2 j]</span>
<span id="cb299-6"><a href="#cb299-6" aria-hidden="true" tabindex="-1"></a>          <span class="kw">rewrite</span> [←mul_assoc 2 3 k]</span>
<span id="cb299-7"><a href="#cb299-7" aria-hidden="true" tabindex="-1"></a>          <span class="kw">rfl</span></span>
<span id="cb299-8"><a href="#cb299-8" aria-hidden="true" tabindex="-1"></a>          <span class="kw">done</span></span>
<span id="cb299-9"><a href="#cb299-9" aria-hidden="true" tabindex="-1"></a>    _ = 3 * n - 2 * n := <span class="kw">by</span></span>
<span id="cb299-10"><a href="#cb299-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb299-11"><a href="#cb299-11" aria-hidden="true" tabindex="-1"></a>          <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb299-12"><a href="#cb299-12" aria-hidden="true" tabindex="-1"></a>    _ = (3 - 2) * n := <span class="cn">sorry</span></span>
<span id="cb299-13"><a href="#cb299-13" aria-hidden="true" tabindex="-1"></a>    _ = n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb300"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb300-1"><a href="#cb300-1" aria-hidden="true" tabindex="-1"></a><span class="in">n </span>: ℤ</span>
<span id="cb300-2"><a href="#cb300-2" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: 2 ∣ n ∧ 3 ∣ n</span>
<span id="cb300-3"><a href="#cb300-3" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (c : ℤ),</span>
<span id="cb300-4"><a href="#cb300-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  n = 2 * c</span>
<span id="cb300-5"><a href="#cb300-5" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: ∃ (c : ℤ),</span>
<span id="cb300-6"><a href="#cb300-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  n = 3 * c</span>
<span id="cb300-7"><a href="#cb300-7" aria-hidden="true" tabindex="-1"></a><span class="in">j </span>: ℤ</span>
<span id="cb300-8"><a href="#cb300-8" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: n = 2 * j</span>
<span id="cb300-9"><a href="#cb300-9" aria-hidden="true" tabindex="-1"></a><span class="in">k </span>: ℤ</span>
<span id="cb300-10"><a href="#cb300-10" aria-hidden="true" tabindex="-1"></a><span class="in">h5 </span>: n = 3 * k</span>
<span id="cb300-11"><a href="#cb300-11" aria-hidden="true" tabindex="-1"></a>⊢ 3 * (2 * j) -</span>
<span id="cb300-12"><a href="#cb300-12" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  2 * (3 * k) =</span>
<span id="cb300-13"><a href="#cb300-13" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>    3 * n - 2 * n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>To justify the third equation we have to substitute <code>n</code> for both <code>2 * j</code> and <code>3 * k</code>. We can use <code>h4</code> and <code>h5</code> in the rewrite tactic to do this. In fact, we can do it in one step: you can put a list of proofs of equations or biconditionals inside the brackets, and the <code>rewrite</code> tactic will perform all of the replacements, one after another. In our case, the tactic <code>rewrite [←h4, ←h5]</code> will first replace <code>2 * j</code> in the goal with <code>n</code>, and then it will replace <code>3 * k</code> with <code>n</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb301"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb301-1"><a href="#cb301-1" aria-hidden="true" tabindex="-1"></a><span class="kw">have</span> h6 : 6 * (j - k) = n :=</span>
<span id="cb301-2"><a href="#cb301-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">calc</span> 6 * (j - k)</span>
<span id="cb301-3"><a href="#cb301-3" aria-hidden="true" tabindex="-1"></a>    _ = 6 * j - 6 * k := Int.mul_sub 6 j k</span>
<span id="cb301-4"><a href="#cb301-4" aria-hidden="true" tabindex="-1"></a>    _ = 3 * (2 * j) - 2 * (3 * k) := <span class="kw">by</span></span>
<span id="cb301-5"><a href="#cb301-5" aria-hidden="true" tabindex="-1"></a>          <span class="kw">rewrite</span> [←mul_assoc 3 2 j]</span>
<span id="cb301-6"><a href="#cb301-6" aria-hidden="true" tabindex="-1"></a>          <span class="kw">rewrite</span> [←mul_assoc 2 3 k]</span>
<span id="cb301-7"><a href="#cb301-7" aria-hidden="true" tabindex="-1"></a>          <span class="kw">rfl</span></span>
<span id="cb301-8"><a href="#cb301-8" aria-hidden="true" tabindex="-1"></a>          <span class="kw">done</span></span>
<span id="cb301-9"><a href="#cb301-9" aria-hidden="true" tabindex="-1"></a>    _ = 3 * n - 2 * n := <span class="kw">by</span></span>
<span id="cb301-10"><a href="#cb301-10" aria-hidden="true" tabindex="-1"></a>          <span class="kw">rewrite</span> [←h4, ←h5]</span>
<span id="cb301-11"><a href="#cb301-11" aria-hidden="true" tabindex="-1"></a>          <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb301-12"><a href="#cb301-12" aria-hidden="true" tabindex="-1"></a>    _ = (3 - 2) * n := <span class="cn">sorry</span></span>
<span id="cb301-13"><a href="#cb301-13" aria-hidden="true" tabindex="-1"></a>    _ = n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb302"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb302-1"><a href="#cb302-1" aria-hidden="true" tabindex="-1"></a><span class="in">n </span>: ℤ</span>
<span id="cb302-2"><a href="#cb302-2" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: 2 ∣ n ∧ 3 ∣ n</span>
<span id="cb302-3"><a href="#cb302-3" aria-hidden="true" tabindex="-1"></a><span class="in">h2 </span>: ∃ (c : ℤ),</span>
<span id="cb302-4"><a href="#cb302-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  n = 2 * c</span>
<span id="cb302-5"><a href="#cb302-5" aria-hidden="true" tabindex="-1"></a><span class="in">h3 </span>: ∃ (c : ℤ),</span>
<span id="cb302-6"><a href="#cb302-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  n = 3 * c</span>
<span id="cb302-7"><a href="#cb302-7" aria-hidden="true" tabindex="-1"></a><span class="in">j </span>: ℤ</span>
<span id="cb302-8"><a href="#cb302-8" aria-hidden="true" tabindex="-1"></a><span class="in">h4 </span>: n = 2 * j</span>
<span id="cb302-9"><a href="#cb302-9" aria-hidden="true" tabindex="-1"></a><span class="in">k </span>: ℤ</span>
<span id="cb302-10"><a href="#cb302-10" aria-hidden="true" tabindex="-1"></a><span class="in">h5 </span>: n = 3 * k</span>
<span id="cb302-11"><a href="#cb302-11" aria-hidden="true" tabindex="-1"></a>⊢ 3 * n - 2 * n =</span>
<span id="cb302-12"><a href="#cb302-12" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  3 * n - 2 * n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Of course, the <code>rfl</code> tactic will now finish off the justification of the third equation.</p>
<p>The fourth equation is <code>3 * n - 2 * n = (3 - 2) * n</code>. It looks like the algebraic law we need to justify this is a lot like the one that was used in the first equation, but with the multiplication to the right of the subtraction rather than to the left. It shouldn’t be surprising, therefore, that the name of the theorem we need is <code>Int.sub_mul</code>. The command <code>#check @Int.sub_mul</code> gives the response</p>
<div class="ind">
<pre><code>Int.sub_mul : ∀ (a b c : ℤ), (a - b) * c = a * c - b * c</code></pre>
</div>
<p>so <code>Int.sub_mul 3 2 n</code> is a proof of <code>(3 - 2) * n = 3 * n - 2 * n</code>. But the fourth equation has the sides of this equation reversed, so to justify it we need <code>(Int.sub_mul 3 2 n).symm</code>.</p>
<p>Finally, the fifth equation is <code>(3 - 2) * n = n</code>. Why is this true? Because it is definitionally equal to <code>1 * n = n</code>. Is there a theorem to justify this last equation? One way to find the answer is to type in this example:</p>
<div class="sourceCode" id="cb304"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb304-1"><a href="#cb304-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (n : Int) : 1 * n = n := <span class="kw">by</span> <span class="sc">++</span><span class="do">apply?</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Lean responds with <code>exact Int.one_mul n</code>, and <code>#check @Int.one_mul</code> yields</p>
<div class="ind">
<pre><code>Int.one_mul : ∀ (a : ℤ), 1 * a = a</code></pre>
</div>
<p>So <code>Int.one_mul n</code> should justify the last equation. Here’s the complete calculational proof, where we have shortened the second step a bit by doing both <code>rewrite</code>s in one step. When a tactic proof is short enough that it can be written on one line, we generally leave off <code>done</code>.</p>
<div class="sourceCode" id="cb306"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb306-1"><a href="#cb306-1" aria-hidden="true" tabindex="-1"></a><span class="kw">have</span> h6 : 6 * (j - k) = n :=</span>
<span id="cb306-2"><a href="#cb306-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">calc</span> 6 * (j - k)</span>
<span id="cb306-3"><a href="#cb306-3" aria-hidden="true" tabindex="-1"></a>    _ = 6 * j - 6 * k := Int.mul_sub 6 j k</span>
<span id="cb306-4"><a href="#cb306-4" aria-hidden="true" tabindex="-1"></a>    _ = 3 * (2 * j) - 2 * (3 * k) := <span class="kw">by</span></span>
<span id="cb306-5"><a href="#cb306-5" aria-hidden="true" tabindex="-1"></a>          <span class="kw">rewrite</span> [←mul_assoc 3 2 j, ←mul_assoc 2 3 k]; <span class="kw">rfl</span></span>
<span id="cb306-6"><a href="#cb306-6" aria-hidden="true" tabindex="-1"></a>    _ = 3 * n - 2 * n := <span class="kw">by</span> <span class="kw">rewrite</span> [←h4, ←h5]; <span class="kw">rfl</span></span>
<span id="cb306-7"><a href="#cb306-7" aria-hidden="true" tabindex="-1"></a>    _ = (3 - 2) * n := (Int.sub_mul 3 2 n).symm</span>
<span id="cb306-8"><a href="#cb306-8" aria-hidden="true" tabindex="-1"></a>    _ = n := Int.one_mul n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Whew! This example illustrates why algebraic reasoning in Lean can be difficult. But one reason why this proof was challenging is that we justified all of our steps from basic algebraic principles. Fortunately, there are more powerful tactics that can automate some algebraic reasoning. For example, the tactic <code>ring</code> can combine algebraic laws involving addition, subtraction, multiplication, and exponentiation with natural number exponents to prove many equations in one step. Also, the tactic <code>rw</code> is a variant of <code>rewrite</code> that automatically applies <code>rfl</code> after the rewriting if it can be used to finish the proof. Here’s a shortened version of our calculational proof that uses these tactics.</p>
<div class="sourceCode" id="cb307"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb307-1"><a href="#cb307-1" aria-hidden="true" tabindex="-1"></a><span class="kw">have</span> h6 : 6 * (j - k) = n :=</span>
<span id="cb307-2"><a href="#cb307-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">calc</span> 6 * (j - k)</span>
<span id="cb307-3"><a href="#cb307-3" aria-hidden="true" tabindex="-1"></a>    _ = 3 * (2 * j) - 2 * (3 * k) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb307-4"><a href="#cb307-4" aria-hidden="true" tabindex="-1"></a>    _ = 3 * n - 2 * n := <span class="kw">by</span> <span class="kw">rw</span> [←h4, ←h5]</span>
<span id="cb307-5"><a href="#cb307-5" aria-hidden="true" tabindex="-1"></a>    _ = n := <span class="kw">by</span> <span class="kw">ring</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>By the way, the theorems <code>Int.mul_sub</code>, <code>Int.sub_mul</code>, and <code>Int.one_mul</code> that we used earlier are the integer versions of more general theorems <code>mul_sub</code>, <code>sub_mul</code>, and <code>one_mul</code>. The <code>#check</code> command tells us what these general theorems say:</p>
<div class="ind">
<pre><code>@mul_sub : ∀ {α : Type u_1} [inst : NonUnitalNonAssocRing α]
            (a b c : α), a * (b - c) = a * b - a * c

@sub_mul : ∀ {α : Type u_1} [inst : NonUnitalNonAssocRing α]
            (a b c : α), (a - b) * c = a * c - b * c

@one_mul : ∀ {M : Type u_1} [inst : MulOneClass M]
            (a : M), 1 * a = a</code></pre>
</div>
<p>The implicit arguments say that these theorems apply in any number system with the appropriate algebraic properties. We’ll use the third theorem in our next example, which involves algebraic reasoning about real numbers. You can use the <code>#check</code> command to find the meanings of the other theorems we use in this proof.</p>
<div class="sourceCode" id="cb309"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb309-1"><a href="#cb309-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_3_5_4 (x : Real) (h1 : x ≤ x ^ 2) : x ≤ 0 ∨ 1 ≤ x := <span class="kw">by</span></span>
<span id="cb309-2"><a href="#cb309-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">or_right</span> <span class="kw">with</span> h2     <span class="co">--h2 : ¬x ≤ 0;  Goal : 1 ≤ x</span></span>
<span id="cb309-3"><a href="#cb309-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : 0 &lt; x := lt_of_not_le h2</span>
<span id="cb309-4"><a href="#cb309-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : 1 * x ≤ x * x :=</span>
<span id="cb309-5"><a href="#cb309-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> 1 * x</span>
<span id="cb309-6"><a href="#cb309-6" aria-hidden="true" tabindex="-1"></a>      _ = x := one_mul x</span>
<span id="cb309-7"><a href="#cb309-7" aria-hidden="true" tabindex="-1"></a>      _ ≤ x ^ 2 := h1</span>
<span id="cb309-8"><a href="#cb309-8" aria-hidden="true" tabindex="-1"></a>      _ = x * x := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb309-9"><a href="#cb309-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> 1 ≤ x <span class="kw">from</span> le_of_mul_le_mul_right h4 h3</span>
<span id="cb309-10"><a href="#cb309-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="exercises-5" class="level3">
<h3 class="anchored" data-anchor-id="exercises-5">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb310"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb310-1"><a href="#cb310-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_3_18a (a b c : Int)</span>
<span id="cb310-2"><a href="#cb310-2" aria-hidden="true" tabindex="-1"></a>    (h1 : a ∣ b) (h2 : a ∣ c) : a ∣ (b + c) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>2. Complete the following proof by justifying the steps in the calculational proof. Remember that you can use the tactic <code>demorgan : ...</code> to apply one of De Morgan’s laws to just a part of the goal. You may also find the theorem <code>and_or_left</code> useful. (Use <code>#check</code> to see what the theorem says.)</p>
<div class="sourceCode" id="cb311"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb311-1"><a href="#cb311-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_4_6 (U : <span class="kw">Type</span>) (A B C : Set U) :</span>
<span id="cb311-2"><a href="#cb311-2" aria-hidden="true" tabindex="-1"></a>    A \ (B ∩ C) = (A \ B) ∪ (A \ C) := <span class="kw">by</span></span>
<span id="cb311-3"><a href="#cb311-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb311-4"><a href="#cb311-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb311-5"><a href="#cb311-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> x ∈ A \ (B ∩ C) ↔ x ∈ A \ B ∪ A \ C <span class="kw">from</span></span>
<span id="cb311-6"><a href="#cb311-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> x ∈ A \ (B ∩ C)</span>
<span id="cb311-7"><a href="#cb311-7" aria-hidden="true" tabindex="-1"></a>      _ ↔ x ∈ A ∧ ¬(x ∈ B ∧ x ∈ C) := <span class="cn">sorry</span></span>
<span id="cb311-8"><a href="#cb311-8" aria-hidden="true" tabindex="-1"></a>      _ ↔ x ∈ A ∧ (x ∉ B ∨ x ∉ C) := <span class="cn">sorry</span>  </span>
<span id="cb311-9"><a href="#cb311-9" aria-hidden="true" tabindex="-1"></a>      _ ↔ (x ∈ A ∧ x ∉ B) ∨ (x ∈ A ∧ x ∉ C) := <span class="cn">sorry</span></span>
<span id="cb311-10"><a href="#cb311-10" aria-hidden="true" tabindex="-1"></a>      _ ↔ x ∈ (A \ B) ∪ (A \ C) := <span class="cn">sorry</span></span>
<span id="cb311-11"><a href="#cb311-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="mdsk">

</div>
<p>For the next exercise you will need the following definitions:</p>
<div class="sourceCode" id="cb312"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb312-1"><a href="#cb312-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> even (n : Int) : <span class="kw">Prop</span> := ∃ (k : Int), n = 2 * k</span>
<span id="cb312-2"><a href="#cb312-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb312-3"><a href="#cb312-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> odd (n : Int) : <span class="kw">Prop</span> := ∃ (k : Int), n = 2 * k + 1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>These definitions tell Lean that if <code>n</code> has type <code>Int</code>, then <code>even n</code> means <code>∃ (k : Int), n = 2 * k</code> and <code>odd n</code> means <code>∃ (k : Int), n = 2 * k + 1</code>.</p>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb313"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb313-1"><a href="#cb313-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_4_10 (x y : Int)</span>
<span id="cb313-2"><a href="#cb313-2" aria-hidden="true" tabindex="-1"></a>    (h1 : odd x) (h2 : odd y) : even (x - y) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb314"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb314-1"><a href="#cb314-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_3_4_27a :</span>
<span id="cb314-2"><a href="#cb314-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Int), 15 ∣ n ↔ 3 ∣ n ∧ 5 ∣ n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb315"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb315-1"><a href="#cb315-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Exercise_3_7_5 (U : <span class="kw">Type</span>) (F : Set (Set U))</span>
<span id="cb315-2"><a href="#cb315-2" aria-hidden="true" tabindex="-1"></a>    (h1 : 𝒫 (⋃₀ F) ⊆ ⋃₀ { 𝒫 A | A ∈ F }) :</span>
<span id="cb315-3"><a href="#cb315-3" aria-hidden="true" tabindex="-1"></a>    ∃ (A : Set U), A ∈ F ∧ ∀ (B : Set U), B ∈ F → B ⊆ A := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./IntroLean.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Introduction to Lean</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./Chap4.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Relations</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
      <div class="nav-footer-center">© 2023 Daniel J. Velleman.<br>Short excerpts from Daniel J. Velleman, <a href="https://doi.org/10.1017/9781108539890"><i>How To Prove It: A Structured Approach, 3rd Edition</i></a><br>© Daniel J. Velleman 2019, published by Cambridge University Press, reprinted with permission.</div>
  </div>
</footer>



</body></html>