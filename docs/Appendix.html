<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.189">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>How To Prove It With Lean - Appendix</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Chap8.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


<link rel="stylesheet" href="HTPIwLstyles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title">Appendix</h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">How To Prove It With Lean</a> 
        <div class="sidebar-tools-main">
    <a href="./How-To-Prove-It-With-Lean.pdf" title="Download PDF" class="sidebar-tool px-1"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Preface</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap1.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Sentential Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap2.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Quantificational Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./IntroLean.html" class="sidebar-item-text sidebar-link">Introduction to Lean</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap3.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Proofs</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap4.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Relations</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap5.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Functions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap6.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Mathematical Induction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap7.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Number Theory</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap8.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Infinite Sets</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Appendix.html" class="sidebar-item-text sidebar-link active">Appendix</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">In This Chapter</h2>
   
  <ul class="collapse">
  <li><a href="#tactics-used" id="toc-tactics-used" class="nav-link active" data-scroll-target="#tactics-used">Tactics Used</a></li>
  <li><a href="#transitioning-to-standard-lean" id="toc-transitioning-to-standard-lean" class="nav-link" data-scroll-target="#transitioning-to-standard-lean">Transitioning to Standard Lean</a></li>
  <li><a href="#typing-symbols" id="toc-typing-symbols" class="nav-link" data-scroll-target="#typing-symbols">Typing Symbols</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<div class="hidden">
$$
\newcommand{\setmin}{\mathbin{\backslash}}
\newcommand{\symmdiff}{\mathbin{∆}}
$$
</div>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block">Appendix</h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<section id="tactics-used" class="level2">
<h2 class="anchored" data-anchor-id="tactics-used">Tactics Used</h2>
<p>Tactics marked with an asterisk (*) are defined in the file <code>HTPIDefs.lean</code> in the HTPI Lean Package that accompanies this book. They will not work without that file. The others are standard Lean tactics or are defined in Lean’s mathematics library, <code>mathlib</code>.</p>
<div style="margin: 0% 10%">
<table class="table">
<thead>
<tr class="header">
<th style="text-align: left;">Tactic</th>
<th style="text-align: left;">Where Introduced</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>apply</code></td>
<td style="text-align: left;"><a href="Chap3.html#proofs-involving-negations-and-conditionals">Sections 3.1 &amp; 3.2</a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>apply?</code></td>
<td style="text-align: left;"><a href="Chap3.html#existence-and-uniqueness-proofs">Section 3.6</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>assume</code>*</td>
<td style="text-align: left;"><a href="IntroLean.html#a-first-example">Introduction to Lean: A First Example</a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>bicond_neg</code>*</td>
<td style="text-align: left;"><a href="IntroLean.html#tactic-mode">Introduction to Lean: Tactic Mode</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>by_cases</code></td>
<td style="text-align: left;"><a href="Chap3.html#proofs-involving-disjunctions">Section 3.5</a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>by_cases on</code>*</td>
<td style="text-align: left;"><a href="Chap3.html#proofs-involving-disjunctions">Section 3.5</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>by_contra</code></td>
<td style="text-align: left;"><a href="Chap3.html#proofs-involving-negations-and-conditionals">Sections 3.1 &amp; 3.2</a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>by_induc</code>*</td>
<td style="text-align: left;"><a href="Chap6.html#proof-by-mathematical-induction">Section 6.1</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>by_strong_induc</code>*</td>
<td style="text-align: left;"><a href="Chap6.html#strong-induction">Section 6.4</a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>conditional</code>*</td>
<td style="text-align: left;"><a href="IntroLean.html#tactic-mode">Introduction to Lean: Tactic Mode</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>contradict</code>*</td>
<td style="text-align: left;"><a href="Chap3.html#proofs-involving-negations-and-conditionals">Sections 3.1 &amp; 3.2</a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>contrapos</code>*</td>
<td style="text-align: left;"><a href="IntroLean.html#a-first-example">Introduction to Lean: A First Example</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>decide</code></td>
<td style="text-align: left;"><a href="Chap6.html#proof-by-mathematical-induction">Section 6.1</a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>define</code>*</td>
<td style="text-align: left;"><a href="IntroLean.html#types">Introduction to Lean: Types</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>demorgan</code>*</td>
<td style="text-align: left;"><a href="IntroLean.html#tactic-mode">Introduction to Lean: Tactic Mode</a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>disj_syll</code>*</td>
<td style="text-align: left;"><a href="Chap3.html#proofs-involving-disjunctions">Section 3.5</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>double_neg</code>*</td>
<td style="text-align: left;"><a href="IntroLean.html#tactic-mode">Introduction to Lean: Tactic Mode</a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>exact</code></td>
<td style="text-align: left;"><a href="Chap3.html#existence-and-uniqueness-proofs">Section 3.6</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>exists_unique</code>*</td>
<td style="text-align: left;"><a href="Chap3.html#existence-and-uniqueness-proofs">Section 3.6</a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>fix</code>*</td>
<td style="text-align: left;"><a href="Chap3.html#proofs-involving-quantifiers">Section 3.3</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>have</code></td>
<td style="text-align: left;"><a href="IntroLean.html#a-first-example">Introduction to Lean: A First Example</a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>linarith</code></td>
<td style="text-align: left;"><a href="Chap6.html#proof-by-mathematical-induction">Section 6.1</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>obtain</code>*</td>
<td style="text-align: left;"><a href="Chap3.html#proofs-involving-quantifiers">Section 3.3</a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>or_left</code>*</td>
<td style="text-align: left;"><a href="Chap3.html#proofs-involving-disjunctions">Section 3.5</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>or_right</code>*</td>
<td style="text-align: left;"><a href="Chap3.html#proofs-involving-disjunctions">Section 3.5</a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>push_neg</code></td>
<td style="text-align: left;"><a href="Chap8.html#equinumerous-sets">Section 8.1</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>quant_neg</code>*</td>
<td style="text-align: left;"><a href="Chap3.html#proofs-involving-quantifiers">Section 3.3</a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>rel</code></td>
<td style="text-align: left;"><a href="Chap6.html#recursion">Section 6.3</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>rewrite</code></td>
<td style="text-align: left;"><a href="Chap3.html#existence-and-uniqueness-proofs">Section 3.6</a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>rfl</code></td>
<td style="text-align: left;"><a href="Chap3.html#more-examples-of-proofs">Section 3.7</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>ring</code></td>
<td style="text-align: left;"><a href="Chap3.html#more-examples-of-proofs">Section 3.7</a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>rw</code></td>
<td style="text-align: left;"><a href="Chap3.html#more-examples-of-proofs">Section 3.7</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>set</code></td>
<td style="text-align: left;"><a href="Chap4.html#equivalence-relations">Section 4.5</a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>show</code>*</td>
<td style="text-align: left;"><a href="IntroLean.html#a-first-example">Introduction to Lean: A First Example</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>trivial</code></td>
<td style="text-align: left;"><a href="Chap7.html#prime-factorization">Section 7.2</a></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="transitioning-to-standard-lean" class="level2">
<h2 class="anchored" data-anchor-id="transitioning-to-standard-lean">Transitioning to Standard Lean</h2>
<p>If you want to continue to use Lean to write mathematical proofs, you may want to learn more about Lean. A good place to start is the <a href="https://leanprover-community.github.io/index.html">Lean Community website</a>. The resources there use “standard” Lean, which is somewhat different from the Lean in this book.</p>
<p>In a few cases we have used notation in this book that differs from standard Lean notation. For example, if <code>h</code> is a proof of <code>P ↔︎ Q</code>, then we have used <code>h.ltr</code> and <code>h.rtl</code> to denote proofs of the left-to-right and right-to-left directions of the biconditional. The standard Lean notation for these is <code>h.mp</code> and <code>h.mpr</code>, respectively (“mp” and “mpr” stand for “modus ponens” and “modus ponens reverse”). As explained at the end of <a href="Chap5.html#closures">Section 5.4</a>, the notations <code>Pred U</code> and <code>Rel A B</code> denote the types <code>U → Prop</code> and <code>A → B → Prop</code>, respectively. Although <code>Rel</code> is standard notation (defined in Lean’s math library <code>mathlib</code>), <code>Pred</code> is not; the notation <code>BinRel A</code> is also not standard Lean. In place of <code>Pred U</code> you should use <code>U → Prop</code>, and in place of <code>BinRel A</code> you should use <code>Rel A A</code>.</p>
<p>However, the biggest difference between the Lean in this book and standard Lean is that the tactics marked with an asterisk in the table above are not a part of standard Lean. If you want to learn to write proofs in standard Lean, you’ll need to learn replacements for those tactics. We discuss some such replacements below. Some of these replacements are built into Lean, and some are defined in <code>mathlib</code>.</p>
<ul>
<li><h4 id="assume-fix" class="anchored"><code>assume</code>, <code>fix</code></h4></li>
</ul>
<p>If you are proving <code>P → Q</code> and you want to begin by assuming <code>h : P</code>, in standard Lean you would begin your proof by writing <code>intro h</code>. You don’t need to specify that <code>h</code> is an identifier for the assumption <code>P</code>; Lean will figure that out on its own.</p>
<p>If you are proving <code>∀ (x : U), P x</code> and you want to begin by introducing the variable <code>x</code> to stand for an arbitrary object of type <code>U</code>, in standard Lean you would begin your proof by writing <code>intro x</code>. Again, you don’t need to specify the type of <code>x</code>, because Lean will figure it out.</p>
<p>Thus, the tactic <code>intro</code> does the job of both <code>assume</code> and <code>fix</code>. Furthermore, you can introduce multiple assumptions or objects with a single use of the <code>intro</code> tactic: <code>intro a b c</code> is equivalent to <code>intro a; intro b; intro c</code>.</p>
<ul>
<li><h4 id="bicond_neg-demorgan-double_neg-quant_neg" class="anchored"><code>bicond_neg</code>, <code>demorgan</code>, <code>double_neg</code>, <code>quant_neg</code></h4></li>
</ul>
<p>We have mostly used these tactics to reexpress negative statements as more useful positive statements. The tactic <code>push_neg</code> can be used for this purpose.</p>
<ul>
<li><h4 id="by_cases-on" class="anchored"><code>by_cases on</code></h4></li>
</ul>
<p>If you have <code>h : P ∨ Q</code>, then you can break your proof into cases by using the tactic <code>obtain hP | hQ := h</code>. In case 1, <code>h : P ∨ Q</code> will be replaced by <code>hP : P</code>, and in case 2 it will be replaced by <code>hQ : Q</code>. In both cases, you have to prove the original goal. You may also want to learn about the tactics <code>cases</code> and <code>rcases</code>.</p>
<ul>
<li><h4 id="by_induc-by_strong_induc" class="anchored"><code>by_induc</code>, <code>by_strong_induc</code></h4></li>
</ul>
<p>We saw in Section 7.2 that if you are proving a statement of the form <code>∀ (l : List U), ...</code>, then you can begin a proof by induction on the length of <code>l</code> by using the tactic <code>apply List.rec</code>. Similarly, if you are proving <code>∀ (n : Nat), ...</code>, you can begin a proof by induction by using the tactic <code>apply Nat.recAux</code>. For strong induction, you can use <code>apply Nat.strongRec</code>.</p>
<p>There are also tactics <code>induction</code> and <code>induction'</code> that you may want to learn about.</p>
<ul>
<li><h4 id="conditional" class="anchored"><code>conditional</code></h4></li>
</ul>
<p>The commands <code>#check @imp_iff_not_or</code> and <code>#check @not_imp</code> produce the results</p>
<div class="ind">
<pre><code>@imp_iff_not_or : ∀ {a b : Prop}, a → b ↔ ¬a ∨ b
@not_imp : ∀ {a b : Prop}, ¬(a → b) ↔ a ∧ ¬b</code></pre>
</div>
<p>Thus, <code>rewrite [imp_iff_not_or]</code> will convert a statement of the form <code>P → Q</code> into <code>¬P ∨ Q</code>, and <code>rewrite [←imp_iff_not_or]</code> will go in the other direction. Similarly, <code>rewrite [not_imp]</code> will convert a statement of the form <code>¬(P → Q)</code> into <code>P ∧ ¬Q</code>, and <code>rewrite [←not_imp]</code> will go in the other direction.</p>
<ul>
<li><h4 id="contradict" class="anchored"><code>contradict</code></h4></li>
</ul>
<p>Suppose your goal is <code>False</code> (as it would be if you are doing a proof by contradiction), and you have <code>h : ¬P</code>. Recall that Lean treats <code>¬P</code> as meaning the same thing as <code>P → False</code>, and therefore <code>h _</code> will prove the goal, if the blank is filled in which a proof of <code>P</code>. It follows that <code>apply h</code> will set <code>P</code> as the goal. In other words, in this situation <code>apply h</code> has the same effect as <code>contradict h</code>.</p>
<p>You could also get the same effect with the tactic <code>suffices hP : P from h hP</code>. Think of this as meaning “it would suffice now to prove <code>P</code>, because if <code>hP</code> were a proof of <code>P</code>, then <code>h hP</code> would prove the goal.” Lean therefore sets <code>P</code> to be the goal.</p>
<p>Similarly, in a proof by contradiction, if you have <code>h : P</code>, then <code>suffices hnP : ¬P from hnP h</code> will set <code>¬P</code> as the goal.</p>
<p>Yet another possibility is <code>contrapose! h</code>. (This is a variant on the <code>contrapose!</code> tactic, discussed in the next section.)</p>
<ul>
<li><h4 id="contrapos" class="anchored"><code>contrapos</code></h4></li>
</ul>
<p>If your goal is a conditional statement, then the tactics <code>contrapose</code> and <code>contrapose!</code> will replace the goal with its contrapositive (<code>contrapose!</code> also uses <code>push_neg</code> to try to simplify the negated statements that arise when forming a contrapositive). You may also find the theorem <code>not_imp_not</code> useful:</p>
<div class="ind">
<pre><code>@not_imp_not : ∀ {a b : Prop}, ¬a → ¬b ↔ b → a</code></pre>
</div>
<ul>
<li><h4 id="define" class="anchored"><code>define</code></h4></li>
</ul>
<p>The tactic <code>whnf</code> (which stands for “weak head normal form”) is similar to <code>define</code>, although it sometimes produces results that are a little confusing.</p>
<p>Another way to write out definitions is to prove a lemma stating the definition and then use that lemma as a rewriting rule in the <code>rewrite</code> tactic. See, for example, the use of the theorem <code>inv_def</code> in <a href="Chap4.html#relations">Section 4.2</a>.</p>
<ul>
<li><h4 id="disj_syll" class="anchored"><code>disj_syll</code></h4></li>
</ul>
<p>The following theorems can be useful:</p>
<div class="ind">
<pre><code>@Or.resolve_left : ∀ {a b : Prop}, a ∨ b → ¬a → b
@Or.resolve_right : ∀ {a b : Prop}, a ∨ b → ¬b → a
@Or.neg_resolve_left : ∀ {a b : Prop}, ¬a ∨ b → a → b
@Or.neg_resolve_right : ∀ {a b : Prop}, a ∨ ¬b → b → a</code></pre>
</div>
<p>For example, if you have <code>h1 : P ∨ Q</code> and <code>h2 : ¬P</code>, then <code>Or.resolve_left h1 h2</code> is a proof of <code>Q</code>.</p>
<ul>
<li><h4 id="exists_unique" class="anchored"><code>exists_unique</code></h4></li>
</ul>
<p>If your goal is <code>∃! (x : U), P x</code> and you think that <code>a</code> is the unique value of <code>x</code> that makes <code>P x</code> true, then you can use the tactic <code>apply ExistsUnique.intro a</code>. This will leave you with two goals to prove, <code>P a</code> and <code>∀ (y : U), P y → y = a</code>.</p>
<ul>
<li><h4 id="obtain" class="anchored"><code>obtain</code></h4></li>
</ul>
<p>If you have <code>h : ∃ (x : U), P x</code>, then the tactic <code>obtain ⟨u, h1⟩ := h</code> will introduce both <code>u : U</code> and <code>h1 : P u</code> into the tactic state. Note that <code>u</code> and <code>h1</code> must be enclosed in angle brackets, <code>⟨ ⟩</code>. To enter those brackets, type <code>\&lt;</code> and <code>\&gt;</code>.</p>
<p>If you have <code>h : ∃! (x : U), P x</code>, then <code>obtain ⟨u, h1, h2⟩ := h</code> will also introduce <code>u : U</code> and <code>h1 : P u</code> into the tactic state. In addition, it will introduce <code>h2</code> as an identifier for a statement that is equivalent to <code>∀ (y : U), P y → y = u</code>. (Unfortunately, the statement introduced is more complicated.)</p>
<p>You may also find the theorems <code>ExistsUnique.exists</code> and <code>ExistsUnique.unique</code> useful:</p>
<div class="ind">
<pre><code>@ExistsUnique.exists : ∀ {α : Sort u_1} {p : α → Prop},
              (∃! (x : α), p x) → ∃ (x : α), p x
@ExistsUnique.unique : ∀ {α : Sort u_1} {p : α → Prop},
              (∃! (x : α), p x) → ∀ {y₁ y₂ : α}, p y₁ → p y₂ → y₁ = y₂</code></pre>
</div>
<ul>
<li><h4 id="or_left-or_right" class="anchored"><code>or_left</code>, <code>or_right</code></h4></li>
</ul>
<p>If your goal is <code>P ∨ Q</code>, then the tactics <code>or_left</code> and <code>or_right</code> let you assume that one of <code>P</code> and <code>Q</code> is false and prove the other. Perhaps the easiest way to do that in standard Lean is to use proof by cases. For example, to assume <code>P</code> is false and prove <code>Q</code> you might proceed as follows:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Goal is P ∨ Q</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> hP : P</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. hP : P</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">exact</span> Or.inl hP</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. hP : ¬P</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Or.inr</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">--We now have hP : ¬P, and goal is Q</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><h4 id="show" class="anchored"><code>show</code></h4></li>
</ul>
<p>There is a <code>show</code> tactic in standard Lean, but it works a little differently from the <code>show</code> tactic we have used in this book. When our goal was a statement <code>P</code> and we had an expression <code>t</code> that was a proof of <code>P</code>, we usually completed the proof by writing <code>show P from t</code>. In standard Lean you can complete the proof by writing <code>exact t</code>, as explained near the end of <a href="Chap3.html#existence-and-uniqueness-proofs">Section 3.6</a>.</p>
</section>
<section id="typing-symbols" class="level2">
<h2 class="anchored" data-anchor-id="typing-symbols">Typing Symbols</h2>
<div style="margin: 0% 10%">
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">Symbol</th>
<th style="text-align: center;">How To Type It</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>¬</code></td>
<td style="text-align: center;"><code>\not</code> or <code>\n</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>∧</code></td>
<td style="text-align: center;"><code>\and</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>∨</code></td>
<td style="text-align: center;"><code>\or</code> or <code>\v</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>→</code></td>
<td style="text-align: center;"><code>\to</code> or <code>\r</code> or <code>\imp</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>↔︎</code></td>
<td style="text-align: center;"><code>\iff</code> or <code>\lr</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>∀</code></td>
<td style="text-align: center;"><code>\forall</code> or <code>\all</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>∃</code></td>
<td style="text-align: center;"><code>\exists</code> or <code>\ex</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>⦃</code></td>
<td style="text-align: center;"><code>\{{</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>⦄</code></td>
<td style="text-align: center;"><code>\}}</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>=</code></td>
<td style="text-align: center;"><code>=</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>≠</code></td>
<td style="text-align: center;"><code>\ne</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>∈</code></td>
<td style="text-align: center;"><code>\in</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>∉</code></td>
<td style="text-align: center;"><code>\notin</code> or <code>\inn</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>⊆</code></td>
<td style="text-align: center;"><code>\sub</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>⊈</code></td>
<td style="text-align: center;"><code>\subn</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>∪</code></td>
<td style="text-align: center;"><code>\union</code> or <code>\cup</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>∩</code></td>
<td style="text-align: center;"><code>\inter</code> or <code>\cap</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>⋃₀</code></td>
<td style="text-align: center;"><code>\U0</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>⋂₀</code></td>
<td style="text-align: center;"><code>\I0</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>\</code></td>
<td style="text-align: center;"><code>\\</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>∆</code></td>
<td style="text-align: center;"><code>\symmdiff</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>∅</code></td>
<td style="text-align: center;"><code>\emptyset</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>𝒫</code></td>
<td style="text-align: center;"><code>\powerset</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>·</code></td>
<td style="text-align: center;"><code>\.</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>←</code></td>
<td style="text-align: center;"><code>\leftarrow</code> or <code>\l</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>↑</code></td>
<td style="text-align: center;"><code>\uparrow</code> or <code>\u</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>ℕ</code></td>
<td style="text-align: center;"><code>\N</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>ℤ</code></td>
<td style="text-align: center;"><code>\Z</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>ℚ</code></td>
<td style="text-align: center;"><code>\Q</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>ℝ</code></td>
<td style="text-align: center;"><code>\R</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>ℂ</code></td>
<td style="text-align: center;"><code>\C</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>≤</code></td>
<td style="text-align: center;"><code>\le</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>≥</code></td>
<td style="text-align: center;"><code>\ge</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>∣</code></td>
<td style="text-align: center;"><code>\|</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>×</code></td>
<td style="text-align: center;"><code>\times</code> or <code>\x</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>∘</code></td>
<td style="text-align: center;"><code>\comp</code> or <code>\circ</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>≡</code></td>
<td style="text-align: center;"><code>\==</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>∼</code></td>
<td style="text-align: center;"><code>\sim</code> or <code>\~</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>ₛ</code></td>
<td style="text-align: center;"><code>\_s</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>ᵣ</code></td>
<td style="text-align: center;"><code>\_r</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>⟨</code></td>
<td style="text-align: center;"><code>\&lt;</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>⟩</code></td>
<td style="text-align: center;"><code>\&gt;</code></td>
</tr>
</tbody>
</table>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Chap8.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Infinite Sets</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
      <div class="nav-footer-center">© 2023 Daniel J. Velleman.<br>Short excerpts from Daniel J. Velleman, <a href="https://doi.org/10.1017/9781108539890"><i>How To Prove It: A Structured Approach, 3rd Edition</i></a><br>© Daniel J. Velleman 2019, published by Cambridge University Press, reprinted with permission.</div>
  </div>
</footer>



</body></html>