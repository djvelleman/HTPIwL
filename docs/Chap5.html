<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.189">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>How To Prove It With Lean - 5&nbsp; Functions</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Chap6.html" rel="next">
<link href="./Chap4.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="HTPIwLstyles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Functions</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">How To Prove It With Lean</a> 
        <div class="sidebar-tools-main">
    <a href="./How-To-Prove-It-With-Lean.pdf" title="Download PDF" class="sidebar-tool px-1"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Preface</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap1.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Sentential Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap2.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Quantificational Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./IntroLean.html" class="sidebar-item-text sidebar-link">Introduction to Lean</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap3.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Proofs</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap4.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Relations</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap5.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Functions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap6.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Mathematical Induction</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul class="collapse">
  <li><a href="#functions" id="toc-functions" class="nav-link active" data-scroll-target="#functions">5.1. Functions</a></li>
  <li><a href="#one-to-one-and-onto" id="toc-one-to-one-and-onto" class="nav-link" data-scroll-target="#one-to-one-and-onto">5.2. One-to-One and Onto</a></li>
  <li><a href="#inverses-of-functions" id="toc-inverses-of-functions" class="nav-link" data-scroll-target="#inverses-of-functions">5.3. Inverses of Functions</a></li>
  <li><a href="#closures" id="toc-closures" class="nav-link" data-scroll-target="#closures">5.4. Closures</a></li>
  <li><a href="#images-and-inverse-images-a-research-project" id="toc-images-and-inverse-images-a-research-project" class="nav-link" data-scroll-target="#images-and-inverse-images-a-research-project">5.5. Images and Inverse Images: A Research Project</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<div class="hidden">
$$
\newcommand{\setmin}{\mathbin{\backslash}}
\newcommand{\symmdiff}{\bigtriangleup}
$$
</div>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Functions</span></h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<section id="functions" class="level2">
<h2 class="anchored" data-anchor-id="functions">5.1. Functions</h2>
<p>The first definition in Chapter 5 of <em>HTPI</em> says that if <span class="math inline">\(F \subseteq A \times B\)</span>, then <span class="math inline">\(F\)</span> is called a <em>function</em> from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span> if for every <span class="math inline">\(a \in A\)</span> there is exactly one <span class="math inline">\(b \in B\)</span> such that <span class="math inline">\((a, b) \in F\)</span>. The notation <span class="math inline">\(F : A \to B\)</span> means that <span class="math inline">\(F\)</span> is a function from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span>. If <span class="math inline">\(F\)</span> is a function from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span> and <span class="math inline">\(a \in A\)</span>, then <em>HTPI</em> introduces the notation <span class="math inline">\(F(a)\)</span> for the unique <span class="math inline">\(b \in B\)</span> such that <span class="math inline">\((a, b) \in F\)</span>. Thus, if <span class="math inline">\(F : A \to B\)</span>, <span class="math inline">\(a \in A\)</span>, and <span class="math inline">\(b \in B\)</span>, then <span class="math inline">\(F(a) = b\)</span> means the same thing as <span class="math inline">\((a, b) \in F\)</span>. We sometimes think of <span class="math inline">\(F\)</span> as representing an operation that can be applied to an element <span class="math inline">\(a\)</span> of <span class="math inline">\(A\)</span> to produce a corresponding element <span class="math inline">\(F(a)\)</span> of <span class="math inline">\(B\)</span>, and we call <span class="math inline">\(F(a)\)</span> the <em>value of <span class="math inline">\(F\)</span> at <span class="math inline">\(a\)</span></em>, or the <em>result of applying <span class="math inline">\(F\)</span> to <span class="math inline">\(a\)</span></em>.</p>
<p>This might remind you of the situation we faced in Chapter 4. If <span class="math inline">\(R \subseteq A \times B\)</span>, <span class="math inline">\(a \in A\)</span>, and <span class="math inline">\(b \in B\)</span>, then Chapter 4 of <em>HTPI</em> uses the notation <span class="math inline">\(aRb\)</span> to mean the same thing as <span class="math inline">\((a, b) \in R\)</span>. But in Lean, we found it necessary to change this notation. Instead of using <em>HTPI</em>’s notation <span class="math inline">\(aRb\)</span>, we introduced the notation <code>R a b</code>, which we use when <code>R</code> has type <code>Rel A B</code>, <code>a</code> has type <code>A</code>, and <code>b</code> has type <code>B</code>. (The notation <code>(a, b) ∈ R</code>, in contrast, can be used only when <code>R</code> has type <code>Set (A × B)</code>.) If <code>R</code> has type <code>Rel A B</code>, then we think of <code>R</code> as representing some relationship that might hold between <code>a</code> and <code>b</code>, and <code>R a b</code> as the proposition saying that this relationship holds. And although <code>R</code> is not a set of ordered pairs, there is a corresponding set, <code>extension R</code>, of type <code>Set (A × B)</code>, with the property that <code>(a, b) ∈ extension R</code> if and only if <code>R a b</code>.</p>
<p>We will take a similar approach to functions in this chapter. For any types <code>A</code> and <code>B</code>, we introduce a new type <code>A → B</code>. If <code>f</code> has type <code>A → B</code>, then we think of <code>f</code> as representing some operation that can be applied to an object of type <code>A</code> to produce a corresponding object of type <code>B</code>. We will say that <code>f</code> is a <em>function</em> from <code>A</code> to <code>B</code>, and <code>A</code> is the <em>domain</em> of <code>f</code>. If <code>a</code> has type <code>A</code>, then we write <code>f a</code> (with a space but no parentheses) for the result of applying the operation represented by <code>f</code> to the object <code>a</code>. Thus, if we have <code>f : A → B</code> and <code>a : A</code>, then <code>f a</code> has type <code>B</code>. As with relations, if <code>f</code> has type <code>A → B</code>, then <code>f</code> is not a set of ordered pairs. But there is a corresponding set of ordered pairs, which we will call the <em>graph</em> of <code>f</code>, whose elements are the ordered pairs <code>(a, b)</code> for which <code>f a = b</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> graph {A B : <span class="kw">Type</span>} (f : A → B) : Set (A × B) :=</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    { (a, b) : A × B | f a = b }</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> simp_graph {A B : <span class="kw">Type</span>} (f : A → B) (a : A) (b : B) :</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    (a, b) ∈ graph f ↔ f a = b := <span class="kw">by</span> <span class="kw">rfl</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Every set of type <code>Set (A × B)</code> is the extension of some relation from <code>A</code> to <code>B</code>, but not every such set is the graph of a function from <code>A</code> to <code>B</code>. To be the graph of a function, it must have the property that was used to define functions in <em>HTPI</em>: each object of type <code>A</code> must be paired in the set with exactly one object of type <code>B</code>. Let’s give this property a name:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_func_graph {A B : <span class="kw">Type</span>} (F : Set (A × B)) : <span class="kw">Prop</span> :=</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    ∀ (x : A), ∃! (y : B), (x, y) ∈ F</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>And now we can say that the sets of type <code>Set (A × B)</code> that are graphs of functions from <code>A</code> to <code>B</code> are precisely the ones that have the property <code>is_func_graph</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> func_from_graph {A B : <span class="kw">Type</span>} (F : Set (A × B)) :</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    (∃ (f : A → B), graph f = F) ↔ is_func_graph F</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We will ask you to prove the left-to-right direction of this theorem in the exercises. The right-to-left direction can also be proven in Lean, but the proof requires methods that go beyond the scope of this book. Nevertheless, we will go ahead and use the theorem when we find it useful.</p>
<p>Section 5.1 of <em>HTPI</em> proves two theorems about functions. The first gives a convenient way of proving that two functions are equal:</p>
<div class="nthm" data-arguments="Theorem 5.1.4">
<p>Suppose <span class="math inline">\(f\)</span> and <span class="math inline">\(g\)</span> are functions from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span>. If <span class="math inline">\(\forall a \in A(f(a) = g(a))\)</span>, then <span class="math inline">\(f = g\)</span>.</p>
</div>
<p>The proof of this theorem in <em>HTPI</em> is based on the axiom of extensionality for sets. But in Lean, functions aren’t sets of ordered pairs, so this method of proof won’t work. Fortunately, Lean has a similar axiom of extensionality for functions. The axiom is called <code>funext</code>, and it proves Theorem 5.1.4.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_5_1_4 {A B : <span class="kw">Type</span>} (f g : A → B) :</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    (∀ (a : A), f a = g a) → f = g := funext</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We saw previously that if we are trying to prove <code>X = Y</code>, where <code>X</code> and <code>Y</code> both have type <code>Set U</code>, then often the best first step is the tactic <code>apply Set.ext</code>, which converts the goal to <code>∀ (x : U), x ∈ X ↔︎ x ∈ Y</code>. Similary, if we are trying to prove <code>f = g</code>, where <code>f</code> and <code>g</code> both have type <code>A → B</code>, then we will usually start with the tactic <code>apply funext</code>, which will convert the goal to <code>∀ (x : A), f x = g x</code>. By Theorem_5_1_4, this implies the original goal <code>f = g</code>. For example, here is a proof that if two functions have the same graph, then they are equal:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {A B : <span class="kw">Type</span>} (f g : A → B) :</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    graph f = graph g → f = g := <span class="kw">by</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : graph f = graph g  <span class="co">--Goal: f = g</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> funext                   <span class="co">--Goal: ∀ (x : A), f x = g x</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : A</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : (x, f x) ∈ graph f := <span class="kw">by</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>                       <span class="co">--Goal: f x = f x</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h1] <span class="kw">at</span> h2             <span class="co">--h2: (x, f x) ∈ graph g</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2                   <span class="co">--h2: g x = f x</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> f x = g x <span class="kw">from</span> h2.symm</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The axiom of extensionality for sets says that a set is completely determined by its elements. This is what justifies our usual method of defining a set: we specify what its elements are, using notation like <code>{0, 1, 2}</code> or <code>{ x : Nat | x &lt; 3 }</code>. Similarly, the axiom of extensionality for functions says that a function is completely determined by its values, and therefore we can define a function by specifying its values. For instance, we can define a function from <code>Nat</code> to <code>Nat</code> by specifying, for any <code>n : Nat</code>, the result of applying the function to <code>n</code>. As an example of this, we could define the “squaring function” from <code>Nat</code> to <code>Nat</code> to be the function that, when applied to any <code>n : Nat</code>, produces the result <code>n^2</code>. Here are two ways to define this function in Lean:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> square1 (n : Nat) : Nat := n^2</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> square2 : Nat → Nat := fun (n : Nat) =&gt; n^2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The first of these definitions uses notation we have used before; it says that if <code>n</code> has type <code>Nat</code>, then the expression <code>square1 n</code> also has type <code>Nat</code>, and it is definitionally equal to <code>n^2</code>. The second definition introduces new Lean notation. It says that <code>square2</code> has type <code>Nat → Nat</code>, and it defines it to be the function that, when applied to any <code>n</code> of type <code>Nat</code>, yields the result <code>n^2</code>. Of course, this also means that <code>square2 n</code> is definitionally equal to <code>n^2</code>. In general, the notation <code>fun (x : A) =&gt; ...</code> means “the function which, when applied to any <code>x</code> of type <code>A</code>, yields the result …” The two definitions above are equivalent. You can ask Lean to confirm this, and try out the squaring function, as follows (the <code>#eval</code> command asks Lean to evaluate an expression):</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> : square1 = square2 := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="sc">++</span><span class="kw">#eval</span><span class="sc">::</span> square1 7     <span class="co">--Answer: 49</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>There is one more theorem in Section 5.1 of <em>HTPI</em>. Theorem 5.1.5 says that if <span class="math inline">\(f\)</span> is a function from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span> and <span class="math inline">\(g\)</span> is a function from <span class="math inline">\(B\)</span> to <span class="math inline">\(C\)</span>, then the composition of <span class="math inline">\(g\)</span> and <span class="math inline">\(f\)</span> is a function from <span class="math inline">\(A\)</span> to <span class="math inline">\(C\)</span>. To state this theorem in Lean, we will have to make adjustments for the differences between the treatment of functions in <em>HTPI</em> and Lean. In Chapter 4, we defined <code>comp S R</code> to be the composition of <code>S</code> and <code>R</code>, where <code>R</code> has type <code>Set (A × B)</code> and <code>S</code> had type <code>Set (B × C)</code>. But functions in Lean are not sets of ordered pairs, so we cannot apply the operation <code>comp</code> to them. We can, however, apply it to their graphs. So the theorem corresponding to Theorem 5.1.5 in <em>HTPI</em> is this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_5_1_5 {A B C : <span class="kw">Type</span>} (f : A → B) (g : B → C) :</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    ∃ (h : A → C), graph h = comp (graph g) (graph f) := <span class="kw">by</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> h : A → C := fun (x : A) =&gt; g (f x)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro h</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> (a, c) : A × C</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that (a, c) ∈ graph h → (a, c) ∈ comp (graph g) (graph f)</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : (a, c) ∈ graph h</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1  <span class="co">--h1: h a = c</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>        <span class="co">--Goal: ∃ (x : B), (a, x) ∈ graph f ∧ (x, c) ∈ graph g</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro (f a)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that (a, f a) ∈ graph f</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rfl</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that (f a, c) ∈ graph g</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> g (f a) = c <span class="kw">from</span> h1</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that (a, c) ∈ comp (graph g) (graph f) → (a, c) ∈ graph h</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : (a, c) ∈ comp (graph g) (graph f)</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>        <span class="co">--Goal: h a = c</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1  <span class="co">--h1: ∃ (x : B), (a, x) ∈ graph f ∧ (x, c) ∈ graph g</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (b : B) (h2 : (a, b) ∈ graph f ∧ (b, c) ∈ graph g) <span class="kw">from</span> h1</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : (a, b) ∈ graph f := h2.left</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : (b, c) ∈ graph g := h2.right</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h3          <span class="co">--h3: f a = b</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h4          <span class="co">--h4: g b = c</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←h3] <span class="kw">at</span> h4   <span class="co">--h4: g (f a) = c</span></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> h a = c <span class="kw">from</span> h4</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Notice that the proof of <code>Theorem_5_1_5</code> begins by defining the function <code>h</code> for which <code>graph h = comp (graph g) (graph f)</code>. The definition says that for all <code>x</code> of type <code>A</code>, <code>h x = g (f x)</code>. This function <code>h</code> is called the <em>composition</em> of <code>g</code> and <code>f</code>, and it is denoted <code>g ∘ f</code>. (To type <code>∘</code> in VSCode, type <code>\comp</code> or <code>\circ</code>.) In other words, <code>g ∘ f</code> has type <code>A → C</code>, and for all <code>x</code> of type <code>A</code>, <code>(g ∘ f) x</code> is definitionally equal to <code>g (f x)</code>. In <em>HTPI</em>, functions are sets of ordered pairs, and the operation of composition of functions is literally the same as the operation <code>comp</code> that we used in Chapter 4. But in Lean, we distinguish among functions, relations, and sets of ordered pairs, so all we can say is that the operation of composition of functions corresponds to the operation <code>comp</code> from Chapter 4. The correspondence is that, as shown in the proof of <code>Theorem_5_1_5</code>, if <code>h = g ∘ f</code>, then <code>graph h = comp (graph g) (graph f)</code>.</p>
<p>We saw in part 4 of Theorem 4.2.5 that composition of relations is associative. Composition of functions is also associative. In fact, if <code>f : A → B</code>, <code>g : B → C</code>, and <code>h : C → D</code>, then <code>h ∘ (g ∘ f)</code> and <code>(h ∘ g) ∘ f</code> are definitionally equal, since they both mean the same thing as <code>fun (x : A) =&gt; h (g (f a))</code>. As a result, the tactic <code>rfl</code> proves the associativity of composition of functions:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {A B C D : <span class="kw">Type</span>} (f : A → B) (g : B → C) (h : C → D) :</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    h ∘ (g ∘ f) = (h ∘ g) ∘ f := <span class="kw">by</span> <span class="kw">rfl</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><em>HTPI</em> defines the identity function on a set <span class="math inline">\(A\)</span> to be the function <span class="math inline">\(i_A\)</span> from <span class="math inline">\(A\)</span> to <span class="math inline">\(A\)</span> such that <span class="math inline">\(\forall x \in A(i_A(x) = x)\)</span>, and Exercise 9 from Section 4.3 of <em>HTPI</em> implies that if <span class="math inline">\(f : A \to B\)</span>, then <span class="math inline">\(f \circ i_A = f\)</span> and <span class="math inline">\(i_B \circ f = f\)</span>. We say, therefore, that the identity functions are <em>identity elements</em> for composition of functions. Similarly, in Lean, for each type <code>A</code> there is an identity function from <code>A</code> to <code>A</code>. This identity function is denoted <code>id</code>; there is no need to specify <code>A</code> in the notation, because <code>A</code> is an implicit argument to <code>id</code>. Thus, when you use <code>id</code> to denote an identity function, Lean will figure out what type <code>A</code> to use as the domain of the function. (If, for some reason, you want to specify that the domain is some type <code>A</code>, you can write <code>@id A</code> instead of <code>id</code>.) For any <code>x</code>, of any type, <code>id x</code> is definitionally equal to <code>x</code>, and as a result the proof that <code>id</code> is an identity element for composition of functions can also be done with the <code>rfl</code> tactic:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {A B : <span class="kw">Type</span>} (f : A → B) : f ∘ id = f := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {A B : <span class="kw">Type</span>} (f : A → B) : id ∘ f = f := <span class="kw">by</span> <span class="kw">rfl</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="exercises" class="level3">
<h3 class="anchored" data-anchor-id="exercises">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb11"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> func_from_graph_ltr {A B : <span class="kw">Type</span>} (F : Set (A × B)) :</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    (∃ (f : A → B), graph f = F) → is_func_graph F := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb12"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_1_13a</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    {A B C : <span class="kw">Type</span>} (R : Set (A × B)) (S : Set (B × C)) (f : A → C)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (b : B), b ∈ Ran R ∧ b ∈ Dom S) (h2 : graph f = comp S R) :</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    is_func_graph S := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb13"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_1_14a</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    {A B : <span class="kw">Type</span>} (f : A → B) (R : BinRel A) (S : BinRel B)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    (h : ∀ (x y : A), R x y ↔ S (f x) (f y)) :</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    reflexive S → reflexive R := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>4. Here is a putative theorem:</p>
<div class="nthm" data-arguments="Theorem?">
<p>Suppose <span class="math inline">\(f : A \to B\)</span>, <span class="math inline">\(R\)</span> is a binary relation on <span class="math inline">\(A\)</span>, and <span class="math inline">\(S\)</span> is the binary relation on <span class="math inline">\(B\)</span> defined as follows: <span class="math display">\[
\forall x \in B \forall y \in B(xSy \leftrightarrow \exists u \in A\exists v \in A(f(u) = x \wedge f(v) = y \wedge uRv)).
\]</span> If <span class="math inline">\(R\)</span> is reflexive then <span class="math inline">\(S\)</span> is reflexive.</p>
</div>
<p>Is the theorem correct? Try to prove it in Lean. If you can’t prove it, see if you can find a counterexample.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">--You might not be able to complete this proof</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_1_15a</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    {A B : <span class="kw">Type</span>} (f : A → B) (R : BinRel A) (S : BinRel B)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    (h : ∀ (x y : B), S x y ↔ ∃ (u v : A), f u = x ∧ f v = y ∧ R u v) :</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    reflexive R → reflexive S := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>5. Here is a putative theorem with an incorrect proof:</p>
<div class="nthm" data-arguments="Theorem?">
<p>Suppose <span class="math inline">\(f : A \to B\)</span>, <span class="math inline">\(R\)</span> is a binary relation on <span class="math inline">\(A\)</span>, and <span class="math inline">\(S\)</span> is the binary relation on <span class="math inline">\(B\)</span> defined as follows: <span class="math display">\[
\forall x \in B \forall y \in B(xSy \leftrightarrow \exists u \in A\exists v \in A(f(u) = x \wedge f(v) = y \wedge uRv)).
\]</span> If <span class="math inline">\(R\)</span> is transitive then <span class="math inline">\(S\)</span> is transitive.</p>
</div>
<div class="npf" data-arguments="Incorrect Proof">
<p>Suppose <span class="math inline">\(R\)</span> is transitive. Let <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span>, and <span class="math inline">\(z\)</span> be arbitrary elements of <span class="math inline">\(B\)</span>. Assume that <span class="math inline">\(xSy\)</span> and <span class="math inline">\(ySz\)</span>. By the definition of <span class="math inline">\(S\)</span>, this means that there are <span class="math inline">\(u\)</span>, <span class="math inline">\(v\)</span>, and <span class="math inline">\(w\)</span> in <span class="math inline">\(A\)</span> such that <span class="math inline">\(f(u) = x\)</span>, <span class="math inline">\(f(v) = y\)</span>, <span class="math inline">\(f(w) = z\)</span>, <span class="math inline">\(uRv\)</span>, and <span class="math inline">\(vRw\)</span>. Since <span class="math inline">\(R\)</span> is transitive, it follows that <span class="math inline">\(uRw\)</span>. Since <span class="math inline">\(f(u) = x\)</span>, <span class="math inline">\(f(w) = z\)</span>, and <span class="math inline">\(uRw\)</span>, <span class="math inline">\(xSz\)</span>. Therefore <span class="math inline">\(S\)</span> is transitive. <span class="excl">&nbsp;□</span></p>
</div>
<p>Find the mistake in the proof by attempting to write the proof in Lean. Is the theorem correct?</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">--You might not be able to complete this proof</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_1_15c</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    {A B : <span class="kw">Type</span>} (f : A → B) (R : BinRel A) (S : BinRel B)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    (h : ∀ (x y : B), S x y ↔ ∃ (u v : A), f u = x ∧ f v = y ∧ R u v) :</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    transitive R → transitive S := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="numex" data-arguments="6">
<div class="sourceCode" id="cb16"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_1_16b</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    {A B : <span class="kw">Type</span>} (R : BinRel B) (S : BinRel (A → B))</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    (h : ∀ (f g : A → B), S f g ↔ ∀ (x : A), R (f x) (g x)) :</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    symmetric R → symmetric S := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="7">
<div class="sourceCode" id="cb17"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_1_17a {A : <span class="kw">Type</span>} (f : A → A) (a : A)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    (h : ∀ (x : A), f x = a) : ∀ (g : A → A), f ∘ g = f := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="8">
<div class="sourceCode" id="cb18"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_1_17b {A : <span class="kw">Type</span>} (f : A → A) (a : A)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    (h : ∀ (g : A → A), f ∘ g = f) :</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    ∃ (y : A), ∀ (x : A), f x = y := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="one-to-one-and-onto" class="level2">
<h2 class="anchored" data-anchor-id="one-to-one-and-onto">5.2. One-to-One and Onto</h2>
<p>Section 5.2 of <em>HTPI</em> introduces two important properties that a function might have. A function <code>f : A → B</code> is called <em>onto</em> if for every <code>b</code> of type <code>B</code> there is at least one <code>a</code> of type <code>A</code> such that <code>f a = b</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> onto {A B : <span class="kw">Type</span>} (f : A → B) : <span class="kw">Prop</span> :=</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    ∀ (y : B), ∃ (x : A), f x = y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It is called <em>one-to-one</em> if there do <em>not</em> exist distinct <code>a1</code> and <code>a2</code> of type <code>A</code> such that <code>f a1 = f a2</code>. This phrasing of the definition makes it clear what is at issue: Are there distinct objects in the domain to which the function assigns the same value? But it is a negative statement, and that would make it difficult to work with it in proofs. Fortunately, it is not hard to rephrase the definition as an equivalent positive statement, using quantifier negation, De Morgan, and conditional laws. The resulting equivalent positive statement is given in Theorem 5.2.3 of <em>HTPI</em>, and we take it as our official definition of <code>one_to_one</code> in Lean:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> one_to_one {A B : <span class="kw">Type</span>} (f : A → B) : <span class="kw">Prop</span> :=</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    ∀ (x1 x2 : A), f x1 = f x2 → x1 = x2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>There is only one more theorem about these properties in Section 5.2 of <em>HTPI</em>. It says that a composition of one-to-one functions is one-to-one, and a composition of onto functions is onto. It is straightforward to carry out these proofs in Lean by simplying applying the definitions of the relevant concepts.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_5_2_5_1 {A B C : <span class="kw">Type</span>} (f : A → B) (g : B → C) :</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    one_to_one f → one_to_one g → one_to_one (g ∘ f) := <span class="kw">by</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : one_to_one f</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : one_to_one g</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1  <span class="co">--h1: ∀ (x1 x2 : A), f x1 = f x2 → x1 = x2</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2  <span class="co">--h2: ∀ (x1 x2 : B), g x1 = g x2 → x1 = x2</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>        <span class="co">--Goal: ∀ (x1 x2 : A), (g ∘ f) x1 = (g ∘ f) x2 → x1 = x2</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a1 : A</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a2 : A    <span class="co">--Goal: (g ∘ f) a1 = (g ∘ f) a2 → a1 = a2</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> : (g ∘ f) a1; <span class="kw">define</span> : (g ∘ f) a2</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>                <span class="co">--Goal: g (f a1) = g (f a2) → a1 = a2</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : g (f a1) = g (f a2)</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : f a1 = f a2 := h2 (f a1) (f a2) h3</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a1 = a2 <span class="kw">from</span> h1 a1 a2 h4</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Notice that the tactic <code>define : (g ∘ f) a1</code> replaces <code>(g ∘ f) a1</code> with its definition, <code>g (f a1)</code>. As usual, this step isn’t really needed—Lean will apply the definition on its own when necessary, without being told. But using this tactic makes the proof easier to read. We use a similar approach for the second part of the theorem.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_5_2_5_2 {A B C : <span class="kw">Type</span>} (f : A → B) (g : B → C) :</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    onto f → onto g → onto (g ∘ f) := <span class="kw">by</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : onto f</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : onto g</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1           <span class="co">--h1: ∀ (y : B), ∃ (x : A), f x = y</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2           <span class="co">--h2: ∀ (y : C), ∃ (x : B), g x = y</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>                 <span class="co">--Goal: ∀ (y : C), ∃ (x : A), (g ∘ f) x = y</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> c : C</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (b : B) (h3 : g b = c) <span class="kw">from</span> h2 c</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : A) (h4 : f a = b) <span class="kw">from</span> h1 b</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro a   <span class="co">--Goal: (g ∘ f) a = c</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> : (g ∘ f) a     <span class="co">--Goal: g (f a) = c</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←h4] <span class="kw">at</span> h3</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> g (f a) = c <span class="kw">from</span> h3</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="exercises-1" class="level3">
<h3 class="anchored" data-anchor-id="exercises-1">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb23"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_2_10a {A B C : <span class="kw">Type</span>} (f: A → B) (g : B → C) :</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    onto (g ∘ f) → onto g := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb24"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_2_10b {A B C : <span class="kw">Type</span>} (f: A → B) (g : B → C) :</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    one_to_one (g ∘ f) → one_to_one f := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb25"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_2_11a {A B C : <span class="kw">Type</span>} (f: A → B) (g : B → C) :</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    onto f → ¬(one_to_one g) → ¬(one_to_one (g ∘ f)) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb26"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_2_11b {A B C : <span class="kw">Type</span>} (f: A → B) (g : B → C) :</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    ¬(onto f) → one_to_one g → ¬(onto (g ∘ f)) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb27"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_2_12 {A B : <span class="kw">Type</span>} (f : A → B) (g : B → Set A)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    (h : ∀ (b : B), g b = { a : A | f a = b }) :</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    onto f → one_to_one g := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="6">
<div class="sourceCode" id="cb28"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_2_16 {A B C : <span class="kw">Type</span>}</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    (R : Set (A × B)) (S : Set (B × C)) (f : A → C) (g : B → C)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    (h1 : graph f = comp S R) (h2 : graph g = S) (h3 : one_to_one g) :</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    is_func_graph R := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="7">
<div class="sourceCode" id="cb29"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_2_17a</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    {A B : <span class="kw">Type</span>} (f : A → B) (R : BinRel A) (S : BinRel B)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x y : B), S x y ↔ ∃ (u v : A), f u = x ∧ f v = y ∧ R u v)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    (h2 : onto f) : reflexive R → reflexive S := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="8">
<div class="sourceCode" id="cb30"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_2_17b</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    {A B : <span class="kw">Type</span>} (f : A → B) (R : BinRel A) (S : BinRel B)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (x y : B), S x y ↔ ∃ (u v : A), f u = x ∧ f v = y ∧ R u v)</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    (h2 : one_to_one f) : transitive R → transitive S := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="9">
<div class="sourceCode" id="cb31"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_2_21a {A B C : <span class="kw">Type</span>} (f : B → C) (g h : A → B)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    (h1 : one_to_one f) (h2 : f ∘ g = f ∘ h) : g = h := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="10">
<div class="sourceCode" id="cb32"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_2_21b {A B C : <span class="kw">Type</span>} (f : B → C) (a : A)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (g h : A → B), f ∘ g = f ∘ h → g = h) :</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    one_to_one f := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="inverses-of-functions" class="level2">
<h2 class="anchored" data-anchor-id="inverses-of-functions">5.3. Inverses of Functions</h2>
<p>Section 5.3 of <em>HTPI</em> is motivated by the following question: If <span class="math inline">\(f\)</span> is a function from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span>, is <span class="math inline">\(f^{-1}\)</span> a function from <span class="math inline">\(B\)</span> to <span class="math inline">\(A\)</span>? Here is the first theorem in that section:</p>
<div class="nthm" data-arguments="Theorem 5.3.1">
<p>Suppose <span class="math inline">\(f : A \to B\)</span>. If <span class="math inline">\(f\)</span> is one-to-one and onto, then <span class="math inline">\(f^{-1} : B \to A\)</span>.</p>
</div>
<p>Of course, we will have to rephrase this theorem slightly to prove it in Lean. If <code>f</code> has type <code>A → B</code>, then the inverse operation <code>inv</code> cannot be applied to <code>f</code>, but it can be applied to <code>graph f</code>. So we must rephrase the theorem like this:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_5_3_1 {A B : <span class="kw">Type</span>}</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    (f : A → B) (h1 : one_to_one f) (h2 : onto f) :</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    ∃ (g : B → A), graph g = inv (graph f)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To prove this theorem, we will use the theorem <code>func_from_graph</code> that was stated in Section 5.1. We can remind ourselves of what that theorem says by using the command <code>#check @func_from_graph</code>, which gives the result:</p>
<div class="ind">
<pre><code>@func_from_graph : ∀ {A B : Type} (F : Set (A × B)),
                    (∃ (f : A → B), graph f = F) ↔ is_func_graph F</code></pre>
</div>
<p>This means that, in the context of the proof of <code>Theorem_5_3_1</code>, <code>func_from_graph (inv (graph f))</code> is a proof of the statement <code>∃ (g : B → A), graph g = inv (graph f) ↔︎ is_func_graph (inv (graph f))</code>. Therefore the tactic <code>rewrite [func_from_graph (inv (graph f))]</code> will change the goal to <code>is_func_graph (inv (func f))</code>. In fact, we can just use <code>rewrite [func_from_graph]</code>, and Lean will figure out how to apply the theorem to rewrite the goal. The rest of the proof is straightforward.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_5_3_1 {A B : <span class="kw">Type</span>}</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    (f : A → B) (h1 : one_to_one f) (h2 : onto f) :</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    ∃ (g : B → A), graph g = inv (graph f) := <span class="kw">by</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [func_from_graph]   <span class="co">--Goal: is_func_graph (inv (graph f))</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>        <span class="co">--Goal: ∀ (x : B), ∃! (y : A), (x, y) ∈ inv (graph f)</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> b : B</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">exists_unique</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Existence</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h2          <span class="co">--h2: ∀ (y : B), ∃ (x : A), f x = y</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (a : A) (h4 : f a = b) <span class="kw">from</span> h2 b</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro a  <span class="co">--Goal: (b, a) ∈ inv (graph f)</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>                <span class="co">--Goal: f a = b</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> f a = b <span class="kw">from</span> h4</span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Uniqueness</span></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> a1 : A; <span class="kw">fix</span> a2 : A</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h3 : (b, a1) ∈ inv (graph f)</span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h4 : (b, a2) ∈ inv (graph f) <span class="co">--Goal: a1 = a2</span></span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h3          <span class="co">--h3: f a1 = b</span></span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h4          <span class="co">--h4: f a2 = b</span></span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←h4] <span class="kw">at</span> h3   <span class="co">--h3: f a1 = f a2</span></span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1          <span class="co">--h1: ∀ (x1 x2 : A), f x1 = f x2 → x1 = x2</span></span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> a1 = a2 <span class="kw">from</span> h1 a1 a2 h3</span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Suppose, now, that we have <code>f : A → B</code>, <code>g : B → A</code>, and <code>graph g = inv (graph f)</code>, as in <code>Theorem_5_3_1</code>. What can we say about the relationship between <code>f</code> and <code>g</code>? One answer is that <code>g ∘ f = id</code> and <code>f ∘ g = id</code>, as shown in Theorem 5.3.2 of <em>HTPI</em>. We’ll prove one of these facts, and leave the other as an exercise for you.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_5_3_2_1 {A B : <span class="kw">Type</span>} (f : A → B) (g : B → A)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    (h1 : graph g = inv (graph f)) : g ∘ f = id := <span class="kw">by</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> funext           <span class="co">--Goal: ∀ (x : A), (g ∘ f) x = id x</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : A              <span class="co">--Goal: (g ∘ f) a = id a</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : (f a, a) ∈ graph g := <span class="kw">by</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h1]         <span class="co">--Goal: (f a, a) ∈ inv (graph f)</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>               <span class="co">--Goal: f a = f a</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2           <span class="co">--h2: g (f a) = a</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> (g ∘ f) a = id a <span class="kw">from</span> h2</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_5_3_2_2 {A B : <span class="kw">Type</span>} (f : A → B) (g : B → A)</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>    (h1 : graph g = inv (graph f)) : f ∘ g = id := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Combining the theorems above, we have shown that if <code>f</code> is one-to-one and onto, then there is a function <code>g</code> such that <code>g ∘ f = id</code> and <code>f ∘ g = id</code>. In fact, the converse is true as well: if such a function <code>g</code> exists, then <code>f</code> must be one-to-one and onto. Again, we’ll prove one statement as leave the second as an exercise.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_5_3_3_1 {A B : <span class="kw">Type</span>} (f : A → B) :</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    (∃ (g : B → A), g ∘ f = id) → one_to_one f := <span class="kw">by</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : ∃ (g : B → A), g ∘ f = id</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (g : B → A) (h2 : g ∘ f = id) <span class="kw">from</span> h1</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>              <span class="co">--Goal: ∀ (x1 x2 : A), f x1 = f x2 → x1 = x2</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a1 : A; <span class="kw">fix</span> a2 : A</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : f a1 = f a2</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a1 = a2 <span class="kw">from</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> a1</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>        = id a1 := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>      _ = (g ∘ f) a1 := <span class="kw">by</span> <span class="kw">rw</span> [h2]</span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>      _ = g (f a1) := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>      _ = g (f a2) := <span class="kw">by</span> <span class="kw">rw</span> [h3]</span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>      _ = (g ∘ f) a2 := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>      _ = id a2 := <span class="kw">by</span> <span class="kw">rw</span> [h2]</span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>      _ = a2 := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_5_3_3_2 {A B : <span class="kw">Type</span>} (f : A → B) :</span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>    (∃ (g : B → A), f ∘ g = id) → onto f := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We can combine the theorems above to show that if we have <code>f : A → B</code>, <code>g : B → A</code>, <code>g ∘ f = id</code>, and <code>f ∘ g = id</code>, then <code>graph g</code> must be the inverse of <code>graph f</code>. Compare the proof below to the proof of Theorem 5.3.5 in <em>HTPI</em>.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_5_3_5 {A B : <span class="kw">Type</span>} (f : A → B) (g : B → A)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    (h1 : g ∘ f = id) (h2 : f ∘ g = id) : graph g = inv (graph f) := <span class="kw">by</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : one_to_one f := Theorem_5_3_3_1 f (Exists.intro g h1)</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : onto f := Theorem_5_3_3_2 f (Exists.intro g h2)</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (g' : B → A) (h5 : graph g' = inv (graph f))</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">from</span> Theorem_5_3_1 f h3 h4</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : g' ∘ f = id := Theorem_5_3_2_1 f g' h5</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h7 : g = g' :=</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> g</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>        = id ∘ g := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>      _ = (g' ∘ f) ∘ g := <span class="kw">by</span> <span class="kw">rw</span> [h6]</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>      _ = g' ∘ (f ∘ g) := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>      _ = g' ∘ id := <span class="kw">by</span> <span class="kw">rw</span> [h2]</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>      _ = g' := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←h7] <span class="kw">at</span> h5</span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> graph g = inv (graph f) <span class="kw">from</span> h5</span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="exercises-2" class="level3">
<h3 class="anchored" data-anchor-id="exercises-2">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb39"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_5_3_2_2 {A B : <span class="kw">Type</span>} (f : A → B) (g : B → A)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    (h1 : graph g = inv (graph f)) : f ∘ g = id := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb40"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_5_3_3_2 {A B : <span class="kw">Type</span>} (f : A → B) :</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    (∃ (g : B → A), f ∘ g = id) → onto f := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb41"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_3_11a {A B : <span class="kw">Type</span>} (f : A → B) (g : B → A) :</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    one_to_one f → f ∘ g = id → graph g = inv (graph f) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb42"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_3_11b {A B : <span class="kw">Type</span>} (f : A → B) (g : B → A) :</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    onto f → g ∘ f = id → graph g = inv (graph f) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb43"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_3_14a {A B : <span class="kw">Type</span>} (f : A → B) (g : B → A)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    (h : f ∘ g = id) : ∀ x ∈ Ran (graph g), g (f x) = x := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="6">
<div class="sourceCode" id="cb44"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_3_18 {A B C : <span class="kw">Type</span>} (f : A → C) (g : B → C)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    (h1 : one_to_one g) (h2 : onto g) :</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    ∃ (h : A → B), g ∘ h = f := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="mdsk">

</div>
<p>The next two exercises will use the following definition:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> conj (A : <span class="kw">Type</span>) (f1 f2 : A → A) : <span class="kw">Prop</span> :=</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>    ∃ (g g' : A → A), (f1 = g' ∘ f2 ∘ g) ∧ (g ∘ g' = id) ∧ (g' ∘ g = id)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="numex" data-arguments="7">
<div class="sourceCode" id="cb46"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_3_17a {A : <span class="kw">Type</span>} : symmetric (conj A) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="8">
<div class="sourceCode" id="cb47"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_3_17b {A : <span class="kw">Type</span>} (f1 f2 : A → A)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    (h1 : conj A f1 f2) (h2 : ∃ (a : A), f1 a = a) :</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    ∃ (a : A), f2 a = a := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="closures" class="level2">
<h2 class="anchored" data-anchor-id="closures">5.4. Closures</h2>
<p>Suppose we have <code>f : A → A</code> and <code>C : Set A</code>. We say that <code>C</code> is <em>closed</em> under <code>f</code> if the value of <code>f</code> at any element of <code>C</code> is again an element of <code>C</code>:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> closed {A : <span class="kw">Type</span>} (f : A → A) (C : Set A) : <span class="kw">Prop</span> := ∀ x ∈ C, f x ∈ C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>According to this definition, <code>closed f C</code> means that <code>C</code> is closed under <code>f</code>. Sometimes, if we have a set <code>B</code> of type <code>Set A</code> that is not closed under <code>f</code>, we are interested in adding more elements to the set to make it closed. The <em>closure</em> of <code>B</code> under <code>f</code> is the smallest set containing <code>B</code> that is closed under <code>f</code>. That is, it is the smallest element of <code>{ D : Set A | B ⊆ D ∧ closed f D }</code>, where we use the subset partial ordering on <code>Set A</code> to determine which element is smallest. We will write <code>closure f B C</code> to mean that the closure of <code>B</code> under <code>f</code> is <code>C</code>. We can define this as follows:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> closure {A : <span class="kw">Type</span>} (f : A → A) (B C : Set A) : <span class="kw">Prop</span> :=</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    smallestElt (sub A) C { D : Set A | B ⊆ D ∧ closed f D }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We know that smallest elements, when they exist, are unique, so it makes sense to talk about <em>the</em> closure of <code>B</code> under <code>f</code>. But not every set has a smallest element. Does every set have a closure? Theorem 5.4.5 in <em>HTPI</em> says that the answer is yes. The idea behind the proof is that, for any family of sets <code>F</code>, if <code>F</code> has a smallest element under the subset partial order, then that smallest element is equal to <code>⋂₀F</code>. (We’ll ask you to prove this in the exercises.)</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_5_4_5 {A : <span class="kw">Type</span>} (f : A → A) (B : Set A) :</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    ∃ (C : Set A), closure f B C := <span class="kw">by</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> F : Set (Set A) := { D : Set A | B ⊆ D ∧ closed f D }</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> C : Set A := ⋂₀F</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro C    <span class="co">--Goal: closure f B C</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>                  <span class="co">--Goal: C ∈ F ∧ ∀ x ∈ F, C ⊆ x</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that C ∈ F</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>                  <span class="co">--Goal: B ⊆ C ∧ closed f C</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro</span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that B ⊆ C</span></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">fix</span> a : A</span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">assume</span> h1 : a ∈ B       <span class="co">--Goal: a ∈ C</span></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span>                  <span class="co">--Goal: ∀ t ∈ F, a ∈ t</span></span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">fix</span> D : Set A</span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">assume</span> h2 : D ∈ F</span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span> <span class="kw">at</span> h2            <span class="co">--h2: B ⊆ D ∧ closed f D</span></span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> a ∈ D <span class="kw">from</span> h2.left h1</span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that C is closed under f</span></span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span>                  <span class="co">--Goal: ∀ x ∈ C, f x ∈ C</span></span>
<span id="cb50-22"><a href="#cb50-22" aria-hidden="true" tabindex="-1"></a>      <span class="kw">fix</span> a : A</span>
<span id="cb50-23"><a href="#cb50-23" aria-hidden="true" tabindex="-1"></a>      <span class="kw">assume</span> h1 : a ∈ C       <span class="co">--Goal: f a ∈ C</span></span>
<span id="cb50-24"><a href="#cb50-24" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span>                  <span class="co">--Goal: ∀ t ∈ F, f a ∈ t</span></span>
<span id="cb50-25"><a href="#cb50-25" aria-hidden="true" tabindex="-1"></a>      <span class="kw">fix</span> D : Set A</span>
<span id="cb50-26"><a href="#cb50-26" aria-hidden="true" tabindex="-1"></a>      <span class="kw">assume</span> h2 : D ∈ F       <span class="co">--Goal: f a ∈ D</span></span>
<span id="cb50-27"><a href="#cb50-27" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span> <span class="kw">at</span> h1            <span class="co">--h1: ∀ t ∈ F, a ∈ t</span></span>
<span id="cb50-28"><a href="#cb50-28" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h3 : a ∈ D := h1 D h2</span>
<span id="cb50-29"><a href="#cb50-29" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span> <span class="kw">at</span> h2            <span class="co">--h2: B ⊆ D ∧ closed f D</span></span>
<span id="cb50-30"><a href="#cb50-30" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h4 : closed f D := h2.right</span>
<span id="cb50-31"><a href="#cb50-31" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span> <span class="kw">at</span> h4            <span class="co">--h4: ∀ x ∈ D, f x ∈ D</span></span>
<span id="cb50-32"><a href="#cb50-32" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> f a ∈ D <span class="kw">from</span> h4 a h3</span>
<span id="cb50-33"><a href="#cb50-33" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb50-34"><a href="#cb50-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb50-35"><a href="#cb50-35" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that C is smallest</span></span>
<span id="cb50-36"><a href="#cb50-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> D : Set A</span>
<span id="cb50-37"><a href="#cb50-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : D ∈ F      <span class="co">--Goal: sub A C D</span></span>
<span id="cb50-38"><a href="#cb50-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb50-39"><a href="#cb50-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> a : A</span>
<span id="cb50-40"><a href="#cb50-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : a ∈ C       <span class="co">--Goal: a ∈ D</span></span>
<span id="cb50-41"><a href="#cb50-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h2            <span class="co">--h2: ∀ t ∈ F, a ∈ t</span></span>
<span id="cb50-42"><a href="#cb50-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> a ∈ D <span class="kw">from</span> h2 D h1</span>
<span id="cb50-43"><a href="#cb50-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb50-44"><a href="#cb50-44" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The idea of the closure of a set under a function can also be applied to functions of two variables. One way to represent a function of two variables on a type <code>A</code> would be to use a function <code>g</code> of type <code>(A × A) → A</code>. If <code>a</code> and <code>b</code> have type <code>A</code>, then <code>(a, b)</code> has type <code>A × A</code>, and the result of applying the function <code>g</code> to the pair of values <code>a</code> and <code>b</code> would be written <code>g (a, b)</code>.</p>
<p>However, there is another way to represent a function of two variables that turns out to be more convenient in Lean. Suppose <code>f</code> has type <code>A → A → A</code>. As with the arrow used in conditional propositions, the arrow for function types groups to the right, so <code>A → A → A</code> means <code>A → (A → A)</code>. Thus, if <code>a</code> has type <code>A</code>, then <code>f a</code> has type <code>A → A</code>. In other words, <code>f a</code> is a function from <code>A</code> to <code>A</code>, and therefore if <code>b</code> has type <code>A</code> then <code>f a b</code> has type <code>A</code>. The upshot is that if <code>f</code> is followed by two objects of type <code>A</code>, then the resulting expression has type <code>A</code>, so <code>f</code> can be thought of as a function that applies to a pair of objects of type <code>A</code> and gives a value of type <code>A</code>.</p>
<p>For example, we can think of addition of integers as a function of two variables. Here are three ways to define this function in Lean.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plus (m n : Int) : Int := m + n</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plus' : Int → Int → Int := fun (m n : Int) =&gt; m + n</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plus'' : Int → Int → Int := fun (m : Int) =&gt; (fun (n : Int) =&gt; m + n)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The third definition matches the description above most closely: <code>plus''</code> is a function that, when applied to an integer <code>m</code>, produces a new function <code>plus'' m : Int → Int</code>. The function <code>plus'' m</code> is defined to be the function that, when applied to an integer <code>n</code>, produces the value <code>m + n</code>. In other words, <code>plus'' m n = m + n</code>. The first two definitions are more convenient ways of defining exactly the same function. Let’s have Lean confirm this, and try out the function:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> : plus = plus'' := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> : plus' = plus'' := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="sc">++</span><span class="kw">#eval</span><span class="sc">::</span> plus 3 2     <span class="co">--Answer: 5</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>There are two reasons why this way of representing functions of two variables in Lean is more convenient. First, it saves us the trouble of grouping the arguments of the function together into an ordered pair before applying the function. If we have <code>f : A → A → A</code> and <code>a b : A</code>, then to apply the function <code>f</code> to the arguments <code>a</code> and <code>b</code> we can just write <code>f a b</code>. Second, it allows for the possibility of “partially applying” the function <code>f</code>. The expression <code>f a</code> is meaningful, and denotes the function that, when applied to any <code>b : A</code>, produces the result <code>f a b</code>. For example, if <code>m</code> is an integer, then <code>plus m</code> denotes the function that, when applied to an integer <code>n</code>, produces the result <code>m + n</code>. We might call <code>plus m</code> the “add to <code>m</code>” function.</p>
<p>We have actually been using these ideas for a long time. In Chapter 3, we introduced the type <code>Pred U</code> of predicates applying to objects of type <code>U</code>, but we did not explain how such predicates are represented internally in Lean. In fact, <code>Pred U</code> is defined to be the type <code>U → Prop</code>, so if <code>P</code> has type <code>Pred U</code>, then <code>P</code> is a function from <code>U</code> to <code>Prop</code>, and if <code>x</code> has type <code>U</code>, then the proposition <code>P x</code> is the result of applying the function <code>P</code> to <code>x</code>. Similarly, <code>Rel A B</code> stands for <code>A → B → Prop</code>, so if <code>R</code> has type <code>Rel A B</code>, then <code>R</code> is a function of two variables, one of type <code>A</code> and one of type <code>B</code>. Earlier in this section, we defined <code>closed f C</code> to be the proposition asserting that <code>C</code> is closed under <code>f</code>. This means that <code>closed</code> is a function of two variables, the first a function <code>f</code> of type <code>A → A</code> and the second a set <code>C</code> of type <code>Set A</code> (where the type <code>A</code> is an implicit argument of <code>closed</code>). But that means that the partial application <code>closed f</code> denotes a function from <code>Set A</code> to <code>Prop</code>. In other words, <code>closed f</code> is a predicate applying to sets of type <code>Set A</code>; we could think of it as the “is closed under <code>f</code>” predicate. Similarly, in Section 4.4 we defined <code>sub</code> to be a function of three variables: if <code>A</code> is a type and <code>X</code> and <code>Y</code> have type <code>Set A</code>, then <code>sub A X Y</code> is the proposition <code>X ⊆ Y</code>. Since then, we have used the partial application <code>sub A</code>, which is the subset relation on <code>Set A</code>. For example, we used it earlier in this section in the definition of <code>closure</code>.</p>
<p>Returning to the subject of closures, here’s how we can extend the idea of closures to functions of two variables:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> closed2 {A : <span class="kw">Type</span>} (f : A → A → A) (C : Set A) : <span class="kw">Prop</span> :=</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>    ∀ x ∈ C, ∀ y ∈ C, f x y ∈ C</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> closure2 {A : <span class="kw">Type</span>} (f : A → A → A) (B C : Set A) : <span class="kw">Prop</span> := </span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>    smallestElt (sub A) C { D : Set A | B ⊆ D ∧ closed2 f D }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We will leave it as an exercise for you to prove that closures under functions of two variables also exist.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_5_4_9 {A : <span class="kw">Type</span>} (f : A → A → A) (B : Set A) :</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>    ∃ (C : Set A), closure2 f B C := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="exercises-3" class="level3">
<h3 class="anchored" data-anchor-id="exercises-3">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb55"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {A : <span class="kw">Type</span>} (F : Set (Set A)) (B : Set A) :</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>    smallestElt (sub A) B F → B = ⋂₀F := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>2. If <code>B</code> has type <code>Set A</code>, then <code>complement B</code> is the set <code>{ a : A | a ∉ B }</code>. Thus, for any <code>a</code> of type <code>A</code>, <code>a ∈ complement B</code> if and only if <code>a ∉ B</code>:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> complement {A : <span class="kw">Type</span>} (B : Set A) : Set A := { a : A | a ∉ B }</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> simp_complement {A : <span class="kw">Type</span>} (a : A) (B : Set A) :</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>    a ∈ complement B ↔ a ∉ B := <span class="kw">by</span> <span class="kw">rfl</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Use this definition and theorem to prove the following theorem:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_4_7 {A : <span class="kw">Type</span>} (f g : A → A) (C : Set A)</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>    (h1 : f ∘ g = id) (h2 : closed f C) : closed g (complement C) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb58"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_4_9a {A : <span class="kw">Type</span>} (f : A → A) (C1 C2 : Set A)</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    (h1 : closed f C1) (h2 : closed f C2) : closed f (C1 ∪ C2) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb59"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_4_10a {A : <span class="kw">Type</span>} (f : A → A) (B1 B2 C1 C2 : Set A)</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>    (h1 : closure f B1 C1) (h2 : closure f B2 C2) :</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>    B1 ⊆ B2 → C1 ⊆ C2 := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb60"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_4_10b {A : <span class="kw">Type</span>} (f : A → A) (B1 B2 C1 C2 : Set A)</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>    (h1 : closure f B1 C1) (h2 : closure f B2 C2) :</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>    closure f (B1 ∪ B2) (C1 ∪ C2) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="6">
<div class="sourceCode" id="cb61"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_5_4_9 {A : <span class="kw">Type</span>} (f : A → A → A) (B : Set A) :</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>    ∃ (C : Set A), closure2 f B C := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>7. Suppose we define a set to be closed under a family of functions if it is closed under all of the functions in the family. Of course, the closure of a set <code>B</code> under a family of functions is the smallest set containing <code>B</code> that is closed under the family.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> closed_family {A : <span class="kw">Type</span>} (F : Set (A → A)) (C : Set A) : <span class="kw">Prop</span> :=</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>    ∀ f ∈ F, closed f C</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> closure_family {A : <span class="kw">Type</span>} (F : Set (A → A)) (B C : Set A) : <span class="kw">Prop</span> :=</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>    smallestElt (sub A) C { D : Set A | B ⊆ D ∧ closed_family F D }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Prove that the closure of a set under a family of functions always exists:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_5_4_13a {A : <span class="kw">Type</span>} (F : Set (A → A)) (B : Set A) :</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    ∃ (C : Set A), closure_family F B C := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="images-and-inverse-images-a-research-project" class="level2">
<h2 class="anchored" data-anchor-id="images-and-inverse-images-a-research-project">5.5. Images and Inverse Images: A Research Project</h2>
<p>Section 5.5 of <em>HTPI</em> introduces two new definitions. Suppose <span class="math inline">\(f : A \to B\)</span>. If <span class="math inline">\(X \subseteq A\)</span>, then the <em>image</em> of <span class="math inline">\(X\)</span> under <span class="math inline">\(f\)</span> is the set <span class="math inline">\(f(X)\)</span> defined as follows: <span class="math display">\[
f(X) = \{f(x) \mid x \in X\} = \{b \in B \mid \exists x \in X(f(x) = b)\}.
\]</span> If <span class="math inline">\(Y \subseteq B\)</span>, then the <em>inverse image</em> of <span class="math inline">\(Y\)</span> under <span class="math inline">\(f\)</span> is the set <span class="math inline">\(f^{-1}(Y)\)</span> defined as follows: <span class="math display">\[
f^{-1}(Y) = \{a \in A \mid f(a) \in Y\}.
\]</span></p>
<p>Here are definitions of these concepts in Lean:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> image {A B : <span class="kw">Type</span>} (f : A → B) (X : Set A) : Set B :=</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>    { f x | x ∈ X }</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> inverse_image {A B : <span class="kw">Type</span>} (f : A → B) (Y : Set B) : Set A :=</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>    { a : A | f a ∈ Y }</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- The following theorems illustrate the meaning of these definitions:</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> simp_image {A B : <span class="kw">Type</span>} (f : A → B) (X : Set A) (b : B) :</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>    b ∈ image f X ↔ ∃ x ∈ X, f x = b := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> simp_inverse_image {A B : <span class="kw">Type</span>} (f : A → B) (Y : Set B) (a : A) :</span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a>    a ∈ inverse_image f Y ↔ f a ∈ Y := <span class="kw">by</span> <span class="kw">rfl</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It is natural to wonder how these concepts interact with familiar operations on sets. <em>HTPI</em> gives an example of such an interaction in Theorem 5.5.2. The theorem makes two assertions. Here are proofs of the two parts of the theorem in Lean.</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_5_5_2_1 {A B : <span class="kw">Type</span>} (f : A → B) (W X : Set A) :</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    image f (W ∩ X) ⊆ image f W ∩ image f X := <span class="kw">by</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : B</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : y ∈ image f (W ∩ X)  <span class="co">--Goal: y ∈ image f W ∩ image f X</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1                     <span class="co">--h1: ∃ (x : A), x ∈ W ∩ X ∧ f x = y</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (x : A) (h2 : x ∈ W ∩ X ∧ f x = y) <span class="kw">from</span> h1</span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> : x ∈ W ∩ X <span class="kw">at</span> h2         <span class="co">--h2: (x ∈ W ∧ x ∈ X) ∧ f x = y</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro</span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that y ∈ image f W</span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>                           <span class="co">--Goal: ∃ (x : A), x ∈ W ∧ f x = y</span></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ∃ (x : A), x ∈ W ∧ f x = y <span class="kw">from</span></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>      Exists.intro x (And.intro h2.left.left h2.right)</span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that y ∈ image f X</span></span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> y ∈ image f X <span class="kw">from</span></span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a>      Exists.intro x (And.intro h2.left.right h2.right)</span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-20"><a href="#cb65-20" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_5_5_2_2 {A B : <span class="kw">Type</span>} (f : A → B) (W X : Set A)</span>
<span id="cb65-21"><a href="#cb65-21" aria-hidden="true" tabindex="-1"></a>    (h1 : one_to_one f) : image f (W ∩ X) = image f W ∩ image f X := <span class="kw">by</span></span>
<span id="cb65-22"><a href="#cb65-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb65-23"><a href="#cb65-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : B      <span class="co">--Goal: y ∈ image f (W ∩ X) ↔ y ∈ image f W ∩ image f X</span></span>
<span id="cb65-24"><a href="#cb65-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb65-25"><a href="#cb65-25" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb65-26"><a href="#cb65-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : y ∈ image f (W ∩ X)</span>
<span id="cb65-27"><a href="#cb65-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> y ∈ image f W ∩ image f X <span class="kw">from</span> Theorem_5_5_2_1 f W X h2</span>
<span id="cb65-28"><a href="#cb65-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb65-29"><a href="#cb65-29" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb65-30"><a href="#cb65-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : y ∈ image f W ∩ image f X  <span class="co">--Goal: y ∈ image f (W ∩ X)</span></span>
<span id="cb65-31"><a href="#cb65-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h2                  <span class="co">--h2: y ∈ image f W ∧ y ∈ image f X</span></span>
<span id="cb65-32"><a href="#cb65-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [simp_image, simp_image] <span class="kw">at</span> h2</span>
<span id="cb65-33"><a href="#cb65-33" aria-hidden="true" tabindex="-1"></a>          <span class="co">--h2: (∃ (x : A), x ∈ W ∧ f x = y) ∧ ∃ (x : A), x ∈ X ∧ f x = y</span></span>
<span id="cb65-34"><a href="#cb65-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (x1 : A) (h3 : x1 ∈ W ∧ f x1 = y) <span class="kw">from</span> h2.left</span>
<span id="cb65-35"><a href="#cb65-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (x2 : A) (h4 : x2 ∈ X ∧ f x2 = y) <span class="kw">from</span> h2.right</span>
<span id="cb65-36"><a href="#cb65-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h5 : f x2 = y := h4.right</span>
<span id="cb65-37"><a href="#cb65-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←h3.right] <span class="kw">at</span> h5  <span class="co">--h5: f x2 = f x1</span></span>
<span id="cb65-38"><a href="#cb65-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1               <span class="co">--h1: ∀ (x1 x2 : A), f x1 = f x2 → x1 = x2</span></span>
<span id="cb65-39"><a href="#cb65-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h6 : x2 = x1 := h1 x2 x1 h5</span>
<span id="cb65-40"><a href="#cb65-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h6] <span class="kw">at</span> h4           <span class="co">--h4: x1 ∈ X ∧ f x1 = y</span></span>
<span id="cb65-41"><a href="#cb65-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> y ∈ image f (W ∩ X) <span class="kw">from</span></span>
<span id="cb65-42"><a href="#cb65-42" aria-hidden="true" tabindex="-1"></a>      Exists.intro x1 (And.intro (And.intro h3.left h4.left) h3.right)</span>
<span id="cb65-43"><a href="#cb65-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb65-44"><a href="#cb65-44" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The rest of Section 5.5 of <em>HTPI</em> consists of statements for you to try to prove. Here are the statements, written as examples in Lean. Some are correct and some are not; some can be made correct by adding additional hypotheses or weakening the conclusion. Prove as much as you can.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {A B : <span class="kw">Type</span>} (f : A → B) (W X : Set A) :</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>    image f (W ∪ X) = image f W ∪ image f X := <span class="cn">sorry</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {A B : <span class="kw">Type</span>} (f : A → B) (W X : Set A) :</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>    image f (W \ X) = image f W \ image f X := <span class="cn">sorry</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {A B : <span class="kw">Type</span>} (f : A → B) (W X : Set A) :</span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>    W ⊆ X ↔ image f W ⊆ image f X := <span class="cn">sorry</span></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {A B : <span class="kw">Type</span>} (f : A → B) (Y Z : Set B) :</span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>    inverse_image f  (Y ∩ Z) =</span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>        inverse_image f Y ∩ inverse_image f Z := <span class="cn">sorry</span></span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {A B : <span class="kw">Type</span>} (f : A → B) (Y Z : Set B) :</span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>    inverse_image f  (Y ∪ Z) =</span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a>        inverse_image f Y ∪ inverse_image f Z := <span class="cn">sorry</span></span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {A B : <span class="kw">Type</span>} (f : A → B) (Y Z : Set B) :</span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true" tabindex="-1"></a>    inverse_image f  (Y \ Z) =</span>
<span id="cb66-20"><a href="#cb66-20" aria-hidden="true" tabindex="-1"></a>        inverse_image f Y \ inverse_image f Z := <span class="cn">sorry</span></span>
<span id="cb66-21"><a href="#cb66-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-22"><a href="#cb66-22" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {A B : <span class="kw">Type</span>} (f : A → B) (Y Z : Set B) :</span>
<span id="cb66-23"><a href="#cb66-23" aria-hidden="true" tabindex="-1"></a>    Y ⊆ Z ↔ inverse_image f Y ⊆ inverse_image f Z := <span class="cn">sorry</span></span>
<span id="cb66-24"><a href="#cb66-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-25"><a href="#cb66-25" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {A B : <span class="kw">Type</span>} (f : A → B) (X : Set A) :</span>
<span id="cb66-26"><a href="#cb66-26" aria-hidden="true" tabindex="-1"></a>    inverse_image f (image f X) = X := <span class="cn">sorry</span></span>
<span id="cb66-27"><a href="#cb66-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-28"><a href="#cb66-28" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {A B : <span class="kw">Type</span>} (f : A → B) (Y : Set B) :</span>
<span id="cb66-29"><a href="#cb66-29" aria-hidden="true" tabindex="-1"></a>    image f (inverse_image f Y) = Y := <span class="cn">sorry</span></span>
<span id="cb66-30"><a href="#cb66-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-31"><a href="#cb66-31" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {A : <span class="kw">Type</span>} (f : A → A) (C : Set A) :</span>
<span id="cb66-32"><a href="#cb66-32" aria-hidden="true" tabindex="-1"></a>    closed f C → image f C ⊆ C := <span class="cn">sorry</span></span>
<span id="cb66-33"><a href="#cb66-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-34"><a href="#cb66-34" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {A : <span class="kw">Type</span>} (f : A → A) (C : Set A) :</span>
<span id="cb66-35"><a href="#cb66-35" aria-hidden="true" tabindex="-1"></a>    image f C ⊆ C → C ⊆ inverse_image f C := <span class="cn">sorry</span></span>
<span id="cb66-36"><a href="#cb66-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-37"><a href="#cb66-37" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {A : <span class="kw">Type</span>} (f : A → A) (C : Set A) :</span>
<span id="cb66-38"><a href="#cb66-38" aria-hidden="true" tabindex="-1"></a>    C ⊆ inverse_image f C → closed f C := <span class="cn">sorry</span></span>
<span id="cb66-39"><a href="#cb66-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-40"><a href="#cb66-40" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {A B : <span class="kw">Type</span>} (f : A → B) (g : B → A) (Y : Set B)</span>
<span id="cb66-41"><a href="#cb66-41" aria-hidden="true" tabindex="-1"></a>    (h1 : f ∘ g = id) (h2 : g ∘ f = id) :</span>
<span id="cb66-42"><a href="#cb66-42" aria-hidden="true" tabindex="-1"></a>    inverse_image f Y = image g Y := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Chap4.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Relations</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./Chap6.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Mathematical Induction</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
      <div class="nav-footer-center">© 2023 Daniel J. Velleman. Short excerpts from <a href="https://doi.org/10.1017/9781108539890"><i>How To Prove It</i></a>, published by Cambridge University Press, reproduced with permission.</div>
  </div>
</footer>



</body></html>