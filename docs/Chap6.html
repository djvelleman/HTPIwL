<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.189">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>How To Prove It with Lean - 6&nbsp; Mathematical Induction</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Chap7.html" rel="next">
<link href="./Chap5.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="HTPIwLstyles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Mathematical Induction</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">How To Prove It with Lean</a> 
        <div class="sidebar-tools-main">
    <a href="./How-To-Prove-It-with-Lean.pdf" title="Download PDF" class="sidebar-tool px-1"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Preface</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap1.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Sentential Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap2.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Quantificational Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./IntroLean.html" class="sidebar-item-text sidebar-link">Introduction to Lean</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap3.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Proofs</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap4.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Relations</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap5.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Functions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap6.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Mathematical Induction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap7.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Number Theory</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap8.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Infinite Sets</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Appendix.html" class="sidebar-item-text sidebar-link">Appendix</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">In This Chapter</h2>
   
  <ul class="collapse">
  <li><a href="#proof-by-mathematical-induction" id="toc-proof-by-mathematical-induction" class="nav-link active" data-scroll-target="#proof-by-mathematical-induction">6.1. Proof by Mathematical Induction</a></li>
  <li><a href="#more-examples" id="toc-more-examples" class="nav-link" data-scroll-target="#more-examples">6.2. More Examples</a></li>
  <li><a href="#recursion" id="toc-recursion" class="nav-link" data-scroll-target="#recursion">6.3. Recursion</a></li>
  <li><a href="#strong-induction" id="toc-strong-induction" class="nav-link" data-scroll-target="#strong-induction">6.4. Strong Induction</a></li>
  <li><a href="#closures-again" id="toc-closures-again" class="nav-link" data-scroll-target="#closures-again">6.5. Closures Again</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<div class="hidden">
$$
\newcommand{\setmin}{\mathbin{\backslash}}
\newcommand{\symmdiff}{\mathbin{∆}}
$$
</div>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Mathematical Induction</span></h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<section id="proof-by-mathematical-induction" class="level2">
<h2 class="anchored" data-anchor-id="proof-by-mathematical-induction">6.1. Proof by Mathematical Induction</h2>
<p>Section 6.1 of <em>HTPI</em> introduces a new proof technique called <em>mathematical induction</em>. It is used for proving statements of the form <code>∀ (n : Nat), P n</code>. Here is how it works (<em>HTPI</em> p.&nbsp;273):</p>
<section id="to-prove-a-goal-of-the-form-n-nat-p-n" class="level4">
<h4 class="anchored" data-anchor-id="to-prove-a-goal-of-the-form-n-nat-p-n">To prove a goal of the form <code>∀ (n : Nat), P n</code>:</h4>
<div class="ind">
<p>First prove <code>P 0</code>, and then prove <code>∀ (n : Nat), P n → P (n + 1)</code>. The first of these proofs is sometimes called the <em>base case</em> and the second the <em>induction step</em>.</p>
</div>
<p>For an explanation of why this strategy works to establish the truth of <code>∀ (n : Nat), P n</code>, see <em>HTPI</em>. Here we focus on using mathematical induction in Lean.</p>
<p>To use mathematical induction in a Lean proof, we will use the tactic <code>by_induc</code>. If the goal has the form <code>∀ (n : Nat), P n</code>, then the <code>by_induc</code> tactic leaves the list of givens unchanged, but it replaces the goal with the goals for the base case and induction step. Thus, the effect of the tactic can be summarized as follows:</p>
<div class="lftrt">
<div class="bef">
<div class="sourceCode" id="cb1"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span> ⋮</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>⊢ ∀ (n : Nat), P n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="aft">
<div class="sourceCode" id="cb2"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> Base_Case</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span> ⋮</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>⊢ P 0</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> Induction_Step</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span> ⋮</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>⊢ ∀ (n : Nat), P n → P (n + 1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>To illustrate proof by mathematical induction in Lean, we turn first to Example 6.1.2 in <em>HTPI</em>, which gives a proof of the statement <span class="math inline">\(\forall n \in \mathbb{N} (3 \mid (n^3 - n))\)</span>. For reasons that we will explain a little later, we will prove a slightly different theorem: <span class="math inline">\(\forall n \in \mathbb{N} (3 \mid (n^3 + 2n))\)</span>. Here is a proof of the theorem, modeled on the proof in Example 6.1.2 of <em>HTPI</em> (<em>HTPI</em> pp.&nbsp;276–277).</p>
<div class="thm">
<p>For every natural number <span class="math inline">\(n\)</span>, <span class="math inline">\(3 \mid (n^3 + 2n)\)</span>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>We use mathematical induction.</p>
<p>Base Case: If <span class="math inline">\(n = 0\)</span>, then <span class="math inline">\(n^3 + 2n = 0 = 3 \cdot 0\)</span>, so <span class="math inline">\(3 \mid (n^3 + 2n)\)</span>.</p>
<p>Induction Step: Let <span class="math inline">\(n\)</span> be an arbitrary natural number and suppose <span class="math inline">\(3 \mid (n^3 + 2n)\)</span>. Then we can choose an integer <span class="math inline">\(k\)</span> such that <span class="math inline">\(3k = n^3 + 2n\)</span>. Thus, <span class="math display">\[\begin{align*}
(n+1)^3 + 2(n+1) &amp;= n^3 + 3n^2 + 3n + 1 + 2n + 2\\
&amp;= (n^3 + 2n) + 3n^2 + 3n + 3\\
&amp;= 3k + 3n^2 + 3n + 3\\
&amp;= 3(k + n^2 + n + 1).
\end{align*}\]</span> Therefore <span class="math inline">\(3 \mid ((n+1)^3 + 2(n+1))\)</span>, as required. <span class="excl">&nbsp;□</span></p>
</div>
<p>Now let’s try writing the same proof in Lean. We start, of course, with the <code>by_induc</code> tactic.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb3"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_6_1_2 :</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), 3 ∣ n ^ 3 + 2 * n := <span class="kw">by</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb4"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> Base_Case</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>⊢ 3 ∣ 0 ^ 3 + 2 * 0</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> Induction_Step</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>⊢ ∀ (n : ℕ),</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  3 ∣ n ^ 3 + 2 * n →</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  3 ∣ (n + 1) ^ 3 +</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>      2 * (n + 1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The base case is easy: The <code>define</code> tactic tells us that the goal means <code>∃ (c : Nat), 0 ^ 3 + 2 * 0 = 3 * c</code>, and then <code>apply Exists.intro 0</code> changes the goal to <code>0 ^ 3 + 2 * 0 = 3 * 0</code>. Both sides are definitionally equal to <code>0</code>, so <code>rfl</code> finishes off the base case. For the induction step, we begin, as in the <em>HTPI</em> proof, by introducing an arbitrary natural number <code>n</code> and assuming <code>3 ∣ n ^ 3 + 2 * n</code>. This assumption is called the <em>inductive hypothesis</em>, so in the Lean proof we give it the identifier <code>ih</code>. Our goal now is to prove <code>3 ∣ (n + 1) ^ 3 + 2 * (n + 1)</code>.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb5"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_6_1_2 :</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), 3 ∣ n ^ 3 + 2 * n := <span class="kw">by</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro 0</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> n : Nat</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : 3 ∣ n ^ 3 + 2 * n</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb6"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> Induction_Step</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="in">n </span>: ℕ</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="in">ih </span>: 3 ∣ n ^ 3 + 2 * n</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>⊢ 3 ∣ (n + 1) ^ 3 +</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>      2 * (n + 1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The rest of the Lean proof follows the model of the <em>HTPI</em> proof: we use the inductive hypothesis to introduce a <code>k</code> such that <code>n ^ 3 + 2 * n = 3 * k</code>, and then we use a calculational proof to show that <code>(n + 1) ^ 3 + 2 * (n + 1) = 3 * (k + n ^ 2 + n + 1)</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_6_1_2 :</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), 3 ∣ n ^ 3 + 2 * n := <span class="kw">by</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>         <span class="co">--Goal : ∃ (c : Nat), 0 ^ 3 + 2 * 0 = 3 * c</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro 0</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> n : Nat</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : 3 ∣ n ^ 3 + 2 * n</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> ih   <span class="co">--ih : ∃ (c : Nat), n ^ 3 + 2 * n = 3 * c</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (k : Nat) (h1 : n ^ 3 + 2 * n = 3 * k) <span class="kw">from</span> ih</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>         <span class="co">--Goal : ∃ (c : Nat), (n + 1) ^ 3 + 2 * (n + 1) = 3 * c</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro (k + n ^ 2 + n + 1)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> (n + 1) ^ 3 + 2 * (n + 1) = 3 * (k + n ^ 2 + n + 1) <span class="kw">from</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> (n + 1) ^ 3 + 2 * (n + 1)</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        _ = n ^ 3 + 2 * n + 3 * n ^ 2 + 3 * n + 3 := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        _ = 3 * k + 3 * n ^ 2 + 3 * n + 3 := <span class="kw">by</span> <span class="kw">rw</span> [h1]</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        _ = 3 * (k + n ^ 2 + n + 1) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Next we’ll look at Example 6.1.1 in <em>HTPI</em>, which proves that for every natural number <span class="math inline">\(n\)</span>, <span class="math inline">\(2^0 + 2^1 + \cdots + 2^n = 2^{n+1} - 1\)</span>. Once again, we will change the theorem slightly before proving it in Lean. What we will prove is that for every <span class="math inline">\(n\)</span>, <span class="math inline">\((2^0 + 2^1 + \cdots + 2^n) + 1 = 2^{n+1}\)</span>. To understand this theorem you must be able to recognize what the “<span class="math inline">\(\cdots\)</span>” stands for. A human reader will probably realize that the numbers being added up here are the numbers of the form <span class="math inline">\(2^i\)</span>, where <span class="math inline">\(i\)</span> runs through all of the natural numbers from 0 to <span class="math inline">\(n\)</span>. But Lean can’t be expected to figure out this pattern, so we must be more explicit.</p>
<p>Section 6.3 of <em>HTPI</em> introduces the explicit notation that mathematicians usually use for such sums. If <span class="math inline">\(f\)</span> is a function whose domain is the natural numbers, then <span class="math display">\[
\sum_{i=0}^n f(i) = f(0) + f(1) + \cdots + f(n).
\]</span> More generally, if <span class="math inline">\(k \le n\)</span> then <span class="math display">\[
\sum_{i=k}^n f(i) = f(k) + f(k+1) + \cdots + f(n).
\]</span></p>
<p>The notation we will use in Lean for this sum is <code>Sum i from k to n, f i</code>. Thus, a mathematician would state our theorem like this:</p>
<div class="thm">
<p>For every natural number <span class="math inline">\(n\)</span>, <span class="math display">\[
\left(\sum_{i=0}^n 2^i\right) + 1 = 2^{n+1}.
\]</span></p>
</div>
<p>And to state the same theorem in Lean, we will write:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_6_1_1 :</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), (<span class="kw">Sum</span> i <span class="kw">from</span> 0 <span class="kw">to</span> n, 2 ^ i) + 1 = 2 ^ (n + 1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We will have more to say later about how the notation <code>Sum i from k to n, f i</code> is defined. But to use the notation in a proof, we will just need to know a few theorems. The <code>#check</code> command will tell us the meanings of the theorems <code>sum_base</code>, <code>sum_step</code>, and <code>sum_from_zero_step</code>:</p>
<div class="ind">
<pre><code>@sum_base : ∀ {A : Type} [inst : AddZeroClass A] {k : ℕ} {f : ℕ → A},
            Sum i from k to k, f i = f k

@sum_step : ∀ {A : Type} [inst : AddZeroClass A] {k n : ℕ} {f : ℕ → A},
            k ≤ n → Sum i from k to n + 1, f i =
              (Sum i from k to n, f i) + f (n + 1)

@sum_from_zero_step :
            ∀ {A : Type} [inst : AddZeroClass A] {n : ℕ} {f : ℕ → A},
            Sum i from 0 to n + 1, f i =
              (Sum i from 0 to n, f i) + f (n + 1)</code></pre>
</div>
<p>As usual, we don’t need to pay too much attention to the implicit arguments in the first line of each statement. What is important is that <code>sum_base</code> can be used to prove any statement of the form</p>
<div class="ind">
<pre><code>Sum i from k to k, f i = f k</code></pre>
</div>
<p>and <code>sum_step</code> proves any statement of the form</p>
<div class="ind">
<pre><code>k ≤ n → Sum i from k to n + 1, f i = (Sum i from k to n, f i) + f (n + 1).</code></pre>
</div>
<p>In the case <code>k = 0</code>, we have the simpler theorem <code>sum_from_zero_step</code>, which proves</p>
<div class="ind">
<pre><code>Sum i from 0 to n + 1, f i = (Sum i from 0 to n, f i) + f (n + 1).</code></pre>
</div>
<p>With that preparation, we can start on the proof. Once again we begin with the <code>by_induc</code> tactic. Our goal for the base case is <code>(Sum i from 0 to 0, 2 ^ i) + 1 = 2 ^ (0 + 1)</code>. To deal with the term <code>Sum i from 0 to 0, 2 ^ i</code>, we use that fact that <code>sum_base</code> proves <code>Sum i from 0 to 0, 2 ^ i = 2 ^ 0</code>. It follows that the tactic <code>rewrite [sum_base]</code> will change the goal to <code>2 ^ 0 + 1 = 2 ^ (0 + 1)</code>. Of course, this means <code>2 = 2</code>, so <code>rfl</code> finishes the base case. For the induction step, we start by introducing an arbitrary natural number <code>n</code> and assuming the inductive hypothesis.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_6_1_1 :</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), (<span class="kw">Sum</span> i <span class="kw">from</span> 0 <span class="kw">to</span> n, 2 ^ i) + 1 = 2 ^ (n + 1) := <span class="kw">by</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [sum_base]</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> n : Nat</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : (<span class="kw">Sum</span> i <span class="kw">from</span> 0 <span class="kw">to</span> n, 2 ^ i) + 1 = 2 ^ (n + 1)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Our goal is now <code>(Sum i from 0 to n + 1, 2 ^ i) + 1 = 2 ^ (n + 1 + 1)</code>, and we use a calculational proof to prove this. Often the key to the proof of the induction step is to find a relationship between the inductive hypothesis and the goal. In this case, that means finding a relationship between <code>Sum i from 0 to n, 2 ^ i</code> and <code>Sum i from 0 to n + 1, 2 ^ i</code>. The relationship we need is given by the theorem <code>sum_from_zero_step</code>. The tactic <code>rewrite [sum_from_zero_step]</code> will replace <code>Sum i from 0 to n + 1, 2 ^ i</code> with <code>(Sum i from 0 to n, 2 ^ i) + 2 ^ (n + 1)</code>. The rest of the calculation proof involves straightforward algebra, handled by the <code>ring</code> tactic, together with an application of the inductive hypothesis.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Example_6_1_1 :</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), (<span class="kw">Sum</span> i <span class="kw">from</span> 0 <span class="kw">to</span> n, 2 ^ i) + 1 = 2 ^ (n + 1) := <span class="kw">by</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [sum_base]</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> n : Nat</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : (<span class="kw">Sum</span> i <span class="kw">from</span> 0 <span class="kw">to</span> n, 2 ^ i) + 1 = 2 ^ (n + 1)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> (<span class="kw">Sum</span> i <span class="kw">from</span> 0 <span class="kw">to</span> n + 1, 2 ^ i) + 1 = 2 ^ (n + 1 + 1) <span class="kw">from</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> (<span class="kw">Sum</span> i <span class="kw">from</span> 0 <span class="kw">to</span> n + 1, 2 ^ i) + 1</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>        _ = (<span class="kw">Sum</span> i <span class="kw">from</span> 0 <span class="kw">to</span> n, 2 ^ i) + 2 ^ (n + 1) + 1 := <span class="kw">by</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>              <span class="kw">rw</span> [sum_from_zero_step]</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>        _ = (<span class="kw">Sum</span> i <span class="kw">from</span> 0 <span class="kw">to</span> n, 2 ^ i) + 1 + 2 ^ (n + 1) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>        _ = 2 ^ (n + 1) + 2 ^ (n + 1) := <span class="kw">by</span> <span class="kw">rw</span> [ih]</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>        _ = 2 ^ (n + 1 + 1) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The last example in Section 6.1 of <em>HTPI</em> gives a proof of the statement <span class="math inline">\(\forall n \ge 5 (2^n &gt; n^2)\)</span>. The proof is by mathematical induction, but since we are only interested in natural numbers greater than or equal to 5, it uses 5 in the base case instead of 0. Here are the theorem and proof from <em>HTPI</em> (<em>HTPI</em> p.&nbsp;278):</p>
<div class="thm">
<p>For every natural number <span class="math inline">\(n \ge 5\)</span>, <span class="math inline">\(2^n &gt; n^2\)</span>.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>By mathematical induction.</p>
<p>Base case: When <span class="math inline">\(n = 5\)</span> we have <span class="math inline">\(2^n = 32 &gt; 25 = n^2\)</span>.</p>
<p>Induction step: Let <span class="math inline">\(n \ge 5\)</span> be arbitrary, and suppose that <span class="math inline">\(2^n &gt; n^2\)</span>. Then <span class="math display">\[\begin{align*}
2^{n+1} &amp;= 2 \cdot 2^n\\
&amp;&gt; 2n^2 &amp;&amp;\text{(inductive hypothesis)}\\
&amp;= n^2 + n^2\\
&amp;\ge n^2 + 5n &amp;&amp;\text{(since $n \ge 5$)}\\
&amp;= n^2 + 2n + 3n\\
&amp;&gt; n^2 + 2n + 1 = (n+1)^2. &amp;&amp;\Box
\end{align*}\]</span> </p>
</div>
<p>Notice that the sequence of calculations at the end of the proof mixes <span class="math inline">\(=\)</span>, <span class="math inline">\(&gt;\)</span>, and <span class="math inline">\(\ge\)</span> in a way that establishes the final conclusion <span class="math inline">\(2^{n+1} &gt; (n+1)^2\)</span>. As we’ll see, such a mixture is allowed in calculational proofs in Lean as well.</p>
<p>To write this proof in Lean, there is no need to specify that the base case should be <code>n = 5</code>; the <code>by_induc</code> tactic is smart enough to figure that out on its own, as you can see in the tactic state below. (Notice that, as in <em>HTPI</em>, in Lean we can write <code>∀ n ≥ k, P n</code> as an abbreviation for <code>∀ (n : Nat), n ≥ k → P n</code>.)</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb15"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_6_1_3 :</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    ∀ n ≥ 5, 2 ^ n &gt; n ^ 2 := <span class="kw">by</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb16"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> Base_Case</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>⊢ 2 ^ 5 &gt; 5 ^ 2</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> Induction_Step</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>⊢ ∀ n ≥ 5,</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  2 ^ n &gt; n ^ 2 →</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  2 ^ (n + 1) &gt;</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>      (n + 1) ^ 2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>To complete this proof we’ll use two tactics we haven’t used before: <code>decide</code> and <code>linarith</code>. The truth or falsity of the inequality in the base case can be decided by simply doing the necessary arithmetic. The tactic <code>decide</code> can do such calculations, and it proves the base case.</p>
<p>For the induction step, we introduce an arbitrary natural number <code>n</code>, assume <code>n ≥ 5</code>, and assume the inductive hypothesis, <code>2 ^ n &gt; n ^ 2</code>. Then we use a calculational proof to imitate the reasoning at the end of the <em>HTPI</em> proof. The tactic <code>linarith</code> makes inferences that involve combining linear equations and inequalities. It is able to prove almost all of the inequalities in the calculational proof. The exception is <code>n * n ≥ 5 * n</code> (which is not linear because of the term <code>n * n</code>). So we prove that inequality separately, using a theorem from Lean’s library, <code>Nat.mul_le_mul_right</code>. The command <code>#check @Nat.mul_le_mul_right</code> tells us the meaning of that theorem:</p>
<div class="ind">
<pre><code>@Nat.mul_le_mul_right : ∀ {n m : ℕ} (k : ℕ), n ≤ m → n * k ≤ m * k</code></pre>
</div>
<p>Thus, <code>Nat.mul_le_mul_right n</code> can be used to prove the statement <code>5 ≤ n → 5 * n ≤ n * n</code>. Lean recognizes <code>x ≥ y</code> as meaning the same thing as <code>y ≤ x</code>, so we can apply this statement to our assumption <code>n ≥ 5</code> to prove that <code>n * n ≥ 5 * n</code>. Once we have proven that inequality, the <code>linarith</code> tactic can use it to complete the required inequality reasoning.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_6_1_3 : ∀ n ≥ 5, 2 ^ n &gt; n ^ 2 := <span class="kw">by</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">decide</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> n : Nat</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : n ≥ 5</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : 2 ^ n &gt; n ^ 2</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : n * n ≥ 5 * n := Nat.mul_le_mul_right n h1</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> 2 ^ (n + 1) &gt; (n + 1) ^ 2 <span class="kw">from</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> 2 ^ (n + 1)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>        _ = 2 * 2 ^ n := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>        _ &gt; 2 * n ^ 2 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>        _ ≥ n ^ 2 + 5 * n := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>        _ &gt; n ^ 2 + 2 * n + 1 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>        _ = (n + 1) ^ 2 := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, we turn to the question of why we made small changes in two of the examples from <em>HTPI</em>. Perhaps you have guessed by now that we were trying to avoid the use of subtraction. All of the numbers in the examples in this section were natural numbers, and subtraction of natural numbers is problematic. In the natural numbers, <code>3 - 2</code> is equal to <code>1</code>, but what is <code>2 - 3</code>? Lean’s answer is <code>0</code>.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="sc">++</span><span class="do">#eval</span><span class="sc">::</span> 2 - 3     <span class="co">--Answer: 0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In Lean, if <code>a</code> and <code>b</code> are natural numbers and <code>a &lt; b</code>, then <code>a - b</code> is defined to be <code>0</code>. As a result, the algebraic laws of natural number subtraction are complicated. For example, <code>2 - 3 + 1 = 0 + 1 = 1</code>, but <code>2 + 1 - 3 = 3 - 3 = 0</code>, so it is not true that for all natural numbers <code>a</code>, <code>b</code>, and <code>c</code>, <code>a - b + c = a + c - b</code>.</p>
<p>If you thought that the answer to the subtraction problem <code>2 - 3</code> was <code>-1</code>, then you automatically switched from the natural numbers to the integers. (Recall that the natural numbers are the numbers 0, 1, 2, …, while the integers are the numbers …, –3, –2, –1, 0, 1, 2, 3, ….) To a human mathematician, this is a perfectly natural thing to do: the natural numbers are a subset of the integers, so <code>2</code> and <code>3</code> are not only natural numbers but also integers, and we can compute <code>2 - 3</code> in the integers.</p>
<p>However, that’s not how things work in Lean. In Lean, different types are completely separate. In particular, <code>Nat</code> and <code>Int</code> are separate types, and therefore the natural numbers are not a subset of the integers. Of course, there is an integer 2, but it is different from the natural number 2. By default, Lean assumes that <code>2</code> denotes the natural number 2, but you can specify that you want the integer 2 by writing <code>(2 : Int)</code>. Subtraction of integers in Lean is the subtraction you are familiar with, and it has all the algebraic properties you would expect. If we want to use subtraction in the theorems in this section, we are better off using familiar integer subtraction rather than funky natural number subtraction.</p>
<p>To prove the theorem in Example 6.1.1 as it appears in <em>HTPI</em>, we could state the theorem like this:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_6_1_1 :</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), <span class="kw">Sum</span> i <span class="kw">from</span> 0 <span class="kw">to</span> n, (2 : Int) ^ i =</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    (2 : Int) ^ (n + 1) - (1 : Int)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The expression <code>Sum i from 0 to n, (2 : Int) ^ i</code> denotes a sum of integers, so it is an integer. Similarly, the right side of the equation is an integer, and the equation asserts the equality of two integers. The subtraction on the right side of the equation is integer subtraction, so we can use the usual algebraic laws to reason about it. In fact, the proof of the theorem in this form is not hard:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_6_1_1 :</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), <span class="kw">Sum</span> i <span class="kw">from</span> 0 <span class="kw">to</span> n, (2 : Int) ^ i =</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    (2 : Int) ^ (n + 1) - (1 : Int) := <span class="kw">by</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [sum_base]</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> n : Nat</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : <span class="kw">Sum</span> i <span class="kw">from</span> 0 <span class="kw">to</span> n, (2 : Int) ^ i =</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>        (2 : Int) ^ (n + 1) - (1 : Int)</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> <span class="kw">Sum</span> i <span class="kw">from</span> 0 <span class="kw">to</span> n + 1, (2 : Int) ^ i =</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>        (2 : Int) ^ (n + 1 + 1) - (1 : Int) <span class="kw">from</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> <span class="kw">Sum</span> i <span class="kw">from</span> 0 <span class="kw">to</span> n + 1, (2 : Int) ^ i</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>        _ = (<span class="kw">Sum</span> i <span class="kw">from</span> 0 <span class="kw">to</span> n, (2 : Int) ^ i)</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>            + (2 : Int) ^ (n + 1) := <span class="kw">by</span> <span class="kw">rw</span> [sum_from_zero_step]</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>        _ = (2 : Int) ^ (n + 1) - (1 : Int)</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>            + (2 : Int) ^ (n + 1) := <span class="kw">by</span> <span class="kw">rw</span> [ih]</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>        _ = (2 : Int) ^ (n + 1 + 1) - (1 : Int) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>If you change <code>(2 : Int)</code> and <code>(1 : Int)</code> to <code>2</code> and <code>1</code>, then the right side of the equation will be a difference of two natural numbers, and Lean will interpret the subtraction as natural number subtraction. The proof won’t work because the <code>ring</code> tactic is not able to deal with the peculiar algebraic properties of natural number subtraction. (The theorem is still true, but the proof is harder.)</p>
</section>
<section id="exercises" class="level3">
<h3 class="anchored" data-anchor-id="exercises">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb22"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Exercise_6_1_1 :</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), 2 * <span class="kw">Sum</span> i <span class="kw">from</span> 0 <span class="kw">to</span> n, i = n * (n + 1) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb23"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Exercise_6_1_4 :</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), <span class="kw">Sum</span> i <span class="kw">from</span> 0 <span class="kw">to</span> n, 2 * i + 1 = (n + 1) ^ 2 := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb24"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_1_9a : ∀ (n : Nat), 2 ∣ n ^ 2 + n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb25"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_1_13 :</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    ∀ (a b : Int) (n : Nat), (a - b) ∣ (a ^ n - b ^ n) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb26"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_1_15 : ∀ n ≥ 10, 2 ^ n &gt; n ^ 3 := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="6">
<div class="sourceCode" id="cb27"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> nonzero_is successor :</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), n ≠ 0 → ∃ (m : Nat), n = m + 1 := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>For the next two exercises you will need the following definitions:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> nat_even (n : Nat) : <span class="kw">Prop</span> := ∃ (k : Nat), n = 2 * k</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> nat_odd (n : Nat) : <span class="kw">Prop</span> := ∃ (k : Nat), n = 2 * k + 1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="numex" data-arguments="7">
<div class="sourceCode" id="cb29"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_1_16a1 :</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), nat_even n ∨ nat_odd n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="8">
<div class="sourceCode" id="cb30"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint:  You may find the lemma nonzero_is_successor</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="co">--from a previous exercise useful, as well as Nat.add_right_cancel.</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_1_16a2 :</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), ¬(nat_even n ∧ nat_odd n) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="more-examples" class="level2">
<h2 class="anchored" data-anchor-id="more-examples">6.2. More Examples</h2>
<p>We saw in the last section that mathematical induction can be used to prove theorems about calculations involving natural numbers. But mathematical induction has a much wider range of uses. Section 6.2 of <em>HTPI</em> illustrates this by proving two theorems about finite sets.</p>
<p>How can mathematical induction be used to prove a statement about finite sets? To say that a set is finite means that it has <span class="math inline">\(n\)</span> elements, for some natural number <span class="math inline">\(n\)</span>. Thus, to say that all finite sets have some property, we can say that for every natural number <span class="math inline">\(n\)</span>, every set with <span class="math inline">\(n\)</span> elements has the property. Since this statement starts with “for every natural number <span class="math inline">\(n\)</span>,” we can use mathematical induction to try to prove it.</p>
<p>What does it mean to say that a set “has <span class="math inline">\(n\)</span> elements”? Section 6.2 of <em>HTPI</em> says that for the proofs in that section, “an intuitive understanding of this concept will suffice.” Unfortunately, intuition is not Lean’s strong suit! So we’ll need to be more explicit about how to talk about finite sets in Lean.</p>
<p>In Chapter 8, we’ll define <code>numElts A n</code> to be a proposition saying that the set <code>A</code> has <code>n</code> elements, and we’ll prove several theorems involving that proposition. Those theorems make precise and explicit the intuitive ideas that we’ll need in this section. We’ll state those theorems here and use them in our proofs, but you’ll have to wait until Section 8.1½ to see how they are proven. Here are the theorems we’ll need:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> zero_elts_iff_empty {U : <span class="kw">Type</span>} (A : Set U) :</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    numElts A 0 ↔ empty A</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> one_elt_iff_singleton {U : <span class="kw">Type</span>} (A : Set U) :</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    numElts A 1 ↔ ∃ (x : U), A = {x}</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> nonempty_of_pos_numElts {U : <span class="kw">Type</span>} {A : Set U} {n : Nat}</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    (h1 : numElts A n) (h2 : n &gt; 0) : ∃ (x : U), x ∈ A</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> remove_one_numElts {U : <span class="kw">Type</span>} {A : Set U} {n : Nat} {a : U}</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>    (h1 : numElts A (n + 1)) (h2 : a ∈ A) : numElts (A \ {a}) n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>These theorems should make intuitive sense. The first says that a set has zero elements if and only if it is empty, and the second says that a set has one element if and only if it is a singleton set. The third theorem says that if a set has a positive number of elements, then there is something in the set. And the fourth says that if a set has <span class="math inline">\(n + 1\)</span> elements and you remove one element, then the resulting set has <span class="math inline">\(n\)</span> elements. You can probably guess that we’ll be using the last theorem in the induction steps of our proofs.</p>
<p>Our first theorem about finite sets says that if <span class="math inline">\(R\)</span> is a partial order on <span class="math inline">\(A\)</span>, then every finite, nonempty subset of <span class="math inline">\(A\)</span> has an <span class="math inline">\(R\)</span>-minimal element. (This is not true in general for infinite subsets of <span class="math inline">\(A\)</span>. Can you think of an example of an infinite subset of a partially ordered set that has no minimal element?) To say that a set is finite and nonempty we can say that it has <span class="math inline">\(n\)</span> elements for some <span class="math inline">\(n \ge 1\)</span>. So here’s how we state our theorem in Lean:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_6_2_1 {A : <span class="kw">Type</span>} (R : BinRel A) (h : partial_order R) :</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    ∀ n ≥ 1, ∀ (B : Set A), numElts B n →</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>      ∃ (x : A), minimalElt R x B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>When we use mathematical induction to prove this theorem, the base case will be <code>n = 1</code>. To write the proof for the base case, we start by assuming <code>B</code> is a set with one element. We can then use the theorem <code>one_elt_iff_singleton</code> to conclude that <code>B = {b}</code>, for some <code>b</code> of type <code>A</code>. We need to prove that <code>B</code> has a minimal element, and the only possibility for the minimal element is <code>b</code>. Verifying that <code>minimalElt R b B</code> is straightforward. Here is the proof of the base case:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_6_2_1 {A : <span class="kw">Type</span>} (R : BinRel A) (h : partial_order R) :</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    ∀ n ≥ 1, ∀ (B : Set A), numElts B n →</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>      ∃ (x : A), minimalElt R x B := <span class="kw">by</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> B : Set A</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : numElts B 1</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [one_elt_iff_singleton] <span class="kw">at</span> h2</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (b : A) (h3 : B = {b}) <span class="kw">from</span> h2</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro b</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>         <span class="co">--Goal : b ∈ B ∧ ¬∃ x ∈ B, R x b ∧ x ≠ b</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that b ∈ B</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [h3]    <span class="co">--Goal : b ∈ {b}</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span>          <span class="co">--Goal : b = b</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rfl</span></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that nothing in B is smaller than b</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>      <span class="kw">by_contra</span> h4</span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">obtain</span> (x : A) (h5 : x ∈ B ∧ R x b ∧ x ≠ b) <span class="kw">from</span> h4</span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h6 : x ∈ B := h5.left</span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [h3] <span class="kw">at</span> h6   <span class="co">--h6 : x ∈ {b}</span></span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span> <span class="kw">at</span> h6         <span class="co">--h6 : x = b</span></span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> False <span class="kw">from</span> h5.right.right h6</span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Notice that since the definition of <code>minimalElt R b B</code> involves a negative statement, we found it convenient to use proof by contradiction to prove it.</p>
<p>For the induction step, we assume that <code>n ≥ 1</code> and that every set with <code>n</code> elements has an <code>R</code>-minimal element. We must prove that every set with <code>n + 1</code> elements has a minimal element, so we let <code>B</code> be an arbitrary set with <code>n + 1</code> elements. To apply the inductive hypothesis, we need a set with <code>n</code> elements. So we pick some <code>b ∈ B</code> (using the theorem <code>nonempty_of_pos_numElts</code>) and then remove it from <code>B</code> to get the set <code>B' = B \ {b}</code>. The theorem <code>remove_one_numElts</code> tells us that <code>B'</code> has <code>n</code> elements, so by the inductive hypothesis, we can then let <code>c</code> be a minimal element of <code>B'</code>. We now know about two elements of <code>B</code>: <code>b</code> and <code>c</code>. Which will be a minimal element of <code>B</code>? As explained in <em>HTPI</em>, it depends on whether or not <code>R b c</code>. We’ll prove that if <code>R b c</code>, then <code>b</code> is a minimal element of <code>B</code>, and if not, then <code>c</code> is a minimal element. It will be convenient to prove these last two facts separately as lemmas. The first lemma says that in the situation at this point in the proof, if <code>R b c</code>, then <code>b</code> is an <code>R</code>-minimal element of <code>B</code>. Here is the proof.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_6_2_1_1 {A : <span class="kw">Type</span>} {R : BinRel A} {B : Set A} {b c : A}</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    (h1 : partial_order R) (h2 : b ∈ B) (h3 : minimalElt R c (B \ {b}))</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    (h4 : R b c) : minimalElt R b B := <span class="kw">by</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h3</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">--h3 : c ∈ B \ {b} ∧ ¬∃ x ∈ B \ {b}, R x c ∧ x ≠ c</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>  <span class="co">--Goal : b ∈ B ∧ ¬∃ x ∈ B, R x b ∧ x ≠ b</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro h2    <span class="co">--Goal : ¬∃ x ∈ B, R x b ∧ x ≠ b</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">contradict</span> h3.right <span class="kw">with</span> h5</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (x : A) (h6 : x ∈ B ∧ R x b ∧ x ≠ b) <span class="kw">from</span> h5</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro x  <span class="co">--Goal : x ∈ B \ {b} ∧ R x c ∧ x ≠ c</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that x ∈ B \ {b}</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> x ∈ B \ {b} <span class="kw">from</span> And.intro h6.left h6.right.right</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that R x c ∧ x ≠ c</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> Rtrans : transitive R := h1.right.left</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h7 : R x c := Rtrans x b c h6.right.left h4</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro h7</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">by_contra</span> h8</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h8] <span class="kw">at</span> h6  <span class="co">--h6 : c ∈ B ∧ R c b ∧ c ≠ b</span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> Rantisymm : antisymmetric R := h1.right.right</span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h9 : c = b := Rantisymm c b h6.right.left h4</span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> False <span class="kw">from</span> h6.right.right h9</span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The second lemma says that if <code>¬R b c</code>, then <code>c</code> is an <code>R</code>-minimal element of <code>B</code>. We’ll leave the proof as an exercise for you:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_6_2_1_2 {A : <span class="kw">Type</span>} {R : BinRel A} {B : Set A} {b c : A}</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    (h1 : partial_order R) (h2 : b ∈ B) (h3 : minimalElt R c (B \ {b}))</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    (h4 : ¬R b c) : minimalElt R c B := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With this preparation, we are finally ready to give the proof of the induction step of <code>Example_6_2_1</code>:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_6_2_1 {A : <span class="kw">Type</span>} (R : BinRel A) (h : partial_order R) :</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    ∀ n ≥ 1, ∀ (B : Set A), numElts B n →</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>      ∃ (x : A), minimalElt R x B := <span class="kw">by</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> n : Nat</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : n ≥ 1</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : ∀ (B : Set A), numElts B n → ∃ (x : A), minimalElt R x B</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> B : Set A</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h3 : numElts B (n + 1)</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : n + 1 &gt; 0 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (b : A) (h5 : b ∈ B) <span class="kw">from</span> nonempty_of_pos_numElts h3 h4</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">set</span> B' : Set A := B \ {b}</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h6 : numElts B' n := remove_one_numElts h3 h5</span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (c : A) (h7 : minimalElt R c B') <span class="kw">from</span> ih B' h6</span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">by_cases</span> h8 : R b c</span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 1. h8 : R b c</span></span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h9 : minimalElt R b B := Lemma_6_2_1_1 h h5 h7 h8</span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> ∃ (x : A), minimalElt R x B <span class="kw">from</span> Exists.intro b h9</span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 2. h8 : ¬R b c</span></span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h9 : minimalElt R c B := Lemma_6_2_1_2 h h5 h7 h8</span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> ∃ (x : A), minimalElt R x B <span class="kw">from</span> Exists.intro c h9</span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We’ll consider one more theorem from Section 6.2 of <em>HTPI</em>. Example 6.2.2 proves that a partial order on a finite set can always be extended to a total order. Rather than give that proof, we are going to prove the more general theorem that is stated in Exercise 2 in Section 6.2 of <em>HTPI</em>. To explain the theorem in that exercise, it will be helpful to introduce a bit of terminology. Suppose <code>R</code> is a partial order on <code>A</code> and <code>b</code> has type <code>A</code>. We will say that <code>b</code> is <em><code>R</code>-comparable to everything</em> if <code>∀ (x : A), R b x ∨ R x b</code>. If <code>B</code> is a set of objects of type <code>A</code>, we say that <code>B</code> is <em><code>R</code>-comparable to everything</em> if every element of <code>B</code> is <code>R</code>-comparable to everything; that is, if <code>∀ b ∈ B, ∀ (x : A), R b x ∨ R x b</code>. Finally, we say that another binary relation <code>T</code> <em>extends</em> <code>R</code> if <code>∀ (x y : A), R x y → T x y</code>. We are going to prove that if <code>R</code> is a partial order on <code>A</code> and <code>B</code> is a finite set of objects of type <code>A</code>, then there is a partial order <code>T</code> that extends <code>R</code> such that <code>B</code> is <code>T</code>-comparable to everything. In other words, we are going to prove the following theorem:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_2_2 {A : <span class="kw">Type</span>} (R : BinRel A) (h : partial_order R) :</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat) (B : Set A), numElts B n → ∃ (T : BinRel A),</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    partial_order T ∧ (∀ (x y : A), R x y → T x y) ∧</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    ∀ x ∈ B, ∀ (y : A), T x y ∨ T y x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In the exercises, we will ask you to show that this implies the theorem in Example 6.2.2.</p>
<p>It will be helpful to begin with a warm-up exercise. We’ll show that a partial order can always be extended to make a single object comparable to everything. In other words, we’ll show that if <code>R</code> is a partial order on <code>A</code> and <code>b</code> has type <code>A</code>, then we can define a partial order <code>T</code> extending <code>R</code> such that <code>b</code> is <code>T</code>-comparable to everything. To define <code>T</code>, we will need to make sure that for every <code>x</code> of type <code>A</code>, either <code>T b x</code> or <code>T x b</code>. If <code>R x b</code>, then since <code>T</code> must extend <code>R</code>, we must have <code>T x b</code>. If <code>¬R x b</code>, then we will define <code>T</code> so that <code>T b x</code>. But notice that if we follow this plan, then for any <code>x</code> and <code>y</code>, if we have <code>R x b</code> and <code>¬R y b</code>, then we will have <code>T x b</code> and <code>T b y</code>, and since <code>T</code> must be transitive, we must then have <code>T x y</code>. Summing up, if we have <code>R x y</code> then we must have <code>T x y</code>, and if we have <code>R x b</code> and <code>¬R y b</code> then we will also need to have <code>T x y</code>. So let’s try defining <code>T x y</code> to mean <code>R x y ∨ (R x b ∧ ¬R y b)</code>.</p>
<p>It will be useful to have a name for this relation <code>T</code>. Since it is an extension of <code>R</code> determined by the element <code>b</code>, we will give it the name <code>extendPO R b</code>. Here is the definition of this relation:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> extendPO {A : <span class="kw">Type</span>} (R : BinRel A) (b : A) (x y : A) : <span class="kw">Prop</span> :=</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  R x y ∨ (R x b ∧ ¬R y b)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We need to prove a number of things about <code>extendPO R b</code>. First of all, we need to prove that it is a partial order. We’ll leave most of the details as exercises for you:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> extendPO_is_ref {A : <span class="kw">Type</span>} (R : BinRel A) (b : A)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    (h : partial_order R) : reflexive (extendPO R b) := <span class="cn">sorry</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> extendPO_is_trans {A : <span class="kw">Type</span>} (R : BinRel A) (b : A)</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    (h : partial_order R) : transitive (extendPO R b) := <span class="cn">sorry</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> extendPO_is_antisymm {A : <span class="kw">Type</span>} (R : BinRel A) (b : A)</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    (h : partial_order R) : antisymmetric (extendPO R b) := <span class="cn">sorry</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> extendPO_is_po {A : <span class="kw">Type</span>} (R : BinRel A) (b : A)</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>    (h : partial_order R) : partial_order (extendPO R b) := </span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>  And.intro (extendPO_is_ref R b h)</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>    (And.intro (extendPO_is_trans R b h) (extendPO_is_antisymm R b h))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It is easy to prove that <code>extendPO R b</code> extends <code>R</code>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> extendPO_extends {A : <span class="kw">Type</span>} (R : BinRel A) (b : A) (x y : A) :</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    R x y → extendPO R b x y := <span class="kw">by</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : R x y</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> R x y ∨ R x b ∧ ¬R y b <span class="kw">from</span> Or.inl h1</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, we verify that <code>extendPO R b</code> does what it was supposed to do: it makes <code>b</code> comparable with everything:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> extendPO_all_comp {A : <span class="kw">Type</span>} (R : BinRel A) (b : A)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    (h : partial_order R) :</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    ∀ (x : A), extendPO R b b x ∨ extendPO R b x b := <span class="kw">by</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> Rref : reflexive R := h.left</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : A</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">or_left</span> <span class="kw">with</span> h1</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1     <span class="co">--h1 : ¬(R x b ∨ R x b ∧ ¬R b b)</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">demorgan</span> <span class="kw">at</span> h1   <span class="co">--h1 : ¬R x b ∧ ¬(R x b ∧ ¬R b b)</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>           <span class="co">--Goal : R b x ∨ R b b ∧ ¬R x b</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Or.inr</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> R b b ∧ ¬R x b <span class="kw">from</span> And.intro (Rref b) h1.left</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With this preparation, we can finally return to our theorem <code>Exercise_6_2_2</code>. We will prove it by mathematical induction. In the base case we must show that if <code>B</code> has 0 elements then we can extend <code>R</code> to make everything in <code>B</code> comparable to everything. Of course, no extension is necessary, since it is vacuously true that all elements of <code>B</code> are <code>R</code>-comparable to everything. For the induction step, after assuming the inductive hypothesis, we must prove that if <code>B</code> has <code>n + 1</code> elements then we can extend <code>R</code> to make all elements of <code>B</code> comparable to everything. As before, we choose <code>b ∈ B</code> and let <code>B' = B \ {b}</code>. By inductive hypothesis, we can find an extension <code>T'</code> of <code>R</code> that makes all elements of <code>B'</code> comparable to everything, so we just have to extend <code>T'</code> further to make <code>b</code> comparable to everything. But as we have just seen, we can do this with <code>extendPO T' b</code>.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_2_2 {A : <span class="kw">Type</span>} (R : BinRel A) (h : partial_order R) :</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat) (B : Set A), numElts B n → ∃ (T : BinRel A),</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    partial_order T ∧ (∀ (x y : A), R x y → T x y) ∧</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    ∀ x ∈ B, ∀ (y : A), T x y ∨ T y x := <span class="kw">by</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> B : Set A</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : numElts B 0</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [zero_elts_iff_empty] <span class="kw">at</span> h2</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h2     <span class="co">--h2 : ¬∃ (x : A), x ∈ B</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro R</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro h</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro</span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that R extends R</span></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">fix</span> x : A; <span class="kw">fix</span> y : A</span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">assume</span> h3 : R x y</span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> R x y <span class="kw">from</span> h3</span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that everything in B comparable to everything under R</span></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">fix</span> x : A</span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">assume</span> h3 : x ∈ B</span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a>      <span class="kw">contradict</span> h2</span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> ∃ (x : A), x ∈ B <span class="kw">from</span> Exists.intro x h3</span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb42-27"><a href="#cb42-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> n : Nat</span>
<span id="cb42-28"><a href="#cb42-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : ∀ (B : Set A), numElts B n → ∃ (T : BinRel A),</span>
<span id="cb42-29"><a href="#cb42-29" aria-hidden="true" tabindex="-1"></a>      partial_order T ∧ (∀ (x y : A), R x y → T x y) ∧</span>
<span id="cb42-30"><a href="#cb42-30" aria-hidden="true" tabindex="-1"></a>      ∀ (x : A), x ∈ B → ∀ (y : A), T x y ∨ T y x</span>
<span id="cb42-31"><a href="#cb42-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> B : Set A</span>
<span id="cb42-32"><a href="#cb42-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : numElts B (n + 1)</span>
<span id="cb42-33"><a href="#cb42-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : n + 1 &gt; 0 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb42-34"><a href="#cb42-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (b : A) (h4 : b ∈ B) <span class="kw">from</span> nonempty_of_pos_numElts h2 h3</span>
<span id="cb42-35"><a href="#cb42-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">set</span> B' : Set A := B \ {b}</span>
<span id="cb42-36"><a href="#cb42-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h5 : numElts B' n := remove_one_numElts h2 h4</span>
<span id="cb42-37"><a href="#cb42-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h6 : ∃ (T : BinRel A), partial_order T ∧</span>
<span id="cb42-38"><a href="#cb42-38" aria-hidden="true" tabindex="-1"></a>      (∀ (x y : A), R x y → T x y) ∧</span>
<span id="cb42-39"><a href="#cb42-39" aria-hidden="true" tabindex="-1"></a>      ∀ (x : A), x ∈ B' → ∀ (y : A), T x y ∨ T y x := ih B' h5</span>
<span id="cb42-40"><a href="#cb42-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (T' : BinRel A)</span>
<span id="cb42-41"><a href="#cb42-41" aria-hidden="true" tabindex="-1"></a>      (h7 : partial_order T' ∧ (∀ (x y : A), R x y → T' x y) ∧</span>
<span id="cb42-42"><a href="#cb42-42" aria-hidden="true" tabindex="-1"></a>      ∀ (x : A), x ∈ B' → ∀ (y : A), T' x y ∨ T' y x) <span class="kw">from</span> h6</span>
<span id="cb42-43"><a href="#cb42-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> T'po : partial_order T' := h7.left</span>
<span id="cb42-44"><a href="#cb42-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> T'extR : ∀ (x y : A), R x y → T' x y := h7.right.left</span>
<span id="cb42-45"><a href="#cb42-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> T'compB' : ∀ (x : A), x ∈ B' →</span>
<span id="cb42-46"><a href="#cb42-46" aria-hidden="true" tabindex="-1"></a>      ∀ (y : A), T' x y ∨ T' y x := h7.right.right</span>
<span id="cb42-47"><a href="#cb42-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">set</span> T : BinRel A := extendPO T' b</span>
<span id="cb42-48"><a href="#cb42-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro T</span>
<span id="cb42-49"><a href="#cb42-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro (extendPO_is_po T' b T'po)</span>
<span id="cb42-50"><a href="#cb42-50" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro</span>
<span id="cb42-51"><a href="#cb42-51" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that T extends R</span></span>
<span id="cb42-52"><a href="#cb42-52" aria-hidden="true" tabindex="-1"></a>      <span class="kw">fix</span> x : A; <span class="kw">fix</span> y : A</span>
<span id="cb42-53"><a href="#cb42-53" aria-hidden="true" tabindex="-1"></a>      <span class="kw">assume</span> h8 : R x y</span>
<span id="cb42-54"><a href="#cb42-54" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h9 : T' x y := T'extR x y h8</span>
<span id="cb42-55"><a href="#cb42-55" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> T x y <span class="kw">from</span> (extendPO_extends T' b x y h9)</span>
<span id="cb42-56"><a href="#cb42-56" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb42-57"><a href="#cb42-57" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that everything in B comparable to everything under T</span></span>
<span id="cb42-58"><a href="#cb42-58" aria-hidden="true" tabindex="-1"></a>      <span class="kw">fix</span> x : A</span>
<span id="cb42-59"><a href="#cb42-59" aria-hidden="true" tabindex="-1"></a>      <span class="kw">assume</span> h8 : x ∈ B</span>
<span id="cb42-60"><a href="#cb42-60" aria-hidden="true" tabindex="-1"></a>      <span class="kw">by_cases</span> h9 : x = b</span>
<span id="cb42-61"><a href="#cb42-61" aria-hidden="true" tabindex="-1"></a>      · <span class="co">-- Case 1. h9 : x = b</span></span>
<span id="cb42-62"><a href="#cb42-62" aria-hidden="true" tabindex="-1"></a>        <span class="kw">rewrite</span> [h9]</span>
<span id="cb42-63"><a href="#cb42-63" aria-hidden="true" tabindex="-1"></a>        <span class="kw">show</span> ∀ (y : A), T b y ∨ T y b <span class="kw">from</span> extendPO_all_comp T' b T'po</span>
<span id="cb42-64"><a href="#cb42-64" aria-hidden="true" tabindex="-1"></a>        <span class="kw">done</span></span>
<span id="cb42-65"><a href="#cb42-65" aria-hidden="true" tabindex="-1"></a>      · <span class="co">-- Case 2. h9 : x ≠ b</span></span>
<span id="cb42-66"><a href="#cb42-66" aria-hidden="true" tabindex="-1"></a>        <span class="kw">have</span> h10 : x ∈ B' := And.intro h8 h9</span>
<span id="cb42-67"><a href="#cb42-67" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fix</span> y : A</span>
<span id="cb42-68"><a href="#cb42-68" aria-hidden="true" tabindex="-1"></a>        <span class="kw">have</span> h11 : T' x y ∨ T' y x := T'compB' x h10 y</span>
<span id="cb42-69"><a href="#cb42-69" aria-hidden="true" tabindex="-1"></a>        <span class="kw">by_cases</span> <span class="kw">on</span> h11</span>
<span id="cb42-70"><a href="#cb42-70" aria-hidden="true" tabindex="-1"></a>        · <span class="co">-- Case 2.1. h11 : T' x y</span></span>
<span id="cb42-71"><a href="#cb42-71" aria-hidden="true" tabindex="-1"></a>          <span class="kw">show</span> T x y ∨ T y x <span class="kw">from</span></span>
<span id="cb42-72"><a href="#cb42-72" aria-hidden="true" tabindex="-1"></a>            Or.inl (extendPO_extends T' b x y h11)</span>
<span id="cb42-73"><a href="#cb42-73" aria-hidden="true" tabindex="-1"></a>          <span class="kw">done</span></span>
<span id="cb42-74"><a href="#cb42-74" aria-hidden="true" tabindex="-1"></a>        · <span class="co">-- Case 2.2. h11 : T' y x</span></span>
<span id="cb42-75"><a href="#cb42-75" aria-hidden="true" tabindex="-1"></a>          <span class="kw">show</span> T x y ∨ T y x <span class="kw">from</span></span>
<span id="cb42-76"><a href="#cb42-76" aria-hidden="true" tabindex="-1"></a>            Or.inr (extendPO_extends T' b y x h11)</span>
<span id="cb42-77"><a href="#cb42-77" aria-hidden="true" tabindex="-1"></a>          <span class="kw">done</span></span>
<span id="cb42-78"><a href="#cb42-78" aria-hidden="true" tabindex="-1"></a>        <span class="kw">done</span></span>
<span id="cb42-79"><a href="#cb42-79" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb42-80"><a href="#cb42-80" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb42-81"><a href="#cb42-81" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="exercises-1" class="level3">
<h3 class="anchored" data-anchor-id="exercises-1">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb43"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_6_2_1_2 {A : <span class="kw">Type</span>} {R : BinRel A} {B : Set A} {b c : A}</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    (h1 : partial_order R) (h2 : b ∈ B) (h3 : minimalElt R c (B \ {b}))</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    (h4 : ¬R b c) : minimalElt R c B := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb44"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> extendPO_is_ref {A : <span class="kw">Type</span>} (R : BinRel A) (b : A)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    (h : partial_order R) : reflexive (extendPO R b) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb45"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> extendPO_is_trans {A : <span class="kw">Type</span>} (R : BinRel A) (b : A)</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>    (h : partial_order R) : transitive (extendPO R b) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb46"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> extendPO_is_antisymm {A : <span class="kw">Type</span>} (R : BinRel A) (b : A)</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    (h : partial_order R) : antisymmetric (extendPO R b) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb47"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_2_3 {A : <span class="kw">Type</span>} (R : BinRel A)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    (h : total_order R) : ∀ n ≥ 1, ∀ (B : Set A),</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    numElts B n → ∃ (b : A), smallestElt R b B := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="6">
<div class="sourceCode" id="cb48"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint:  First prove that R is reflexive.</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_2_4a {A : <span class="kw">Type</span>} (R : BinRel A)</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    (h : ∀ (x y : A), R x y ∨ R y x) : ∀ n ≥ 1, ∀ (B : Set A),</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    numElts B n → ∃ x ∈ B, ∀ y ∈ B, ∃ (z : A), R x z ∧ R z y := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="7">
<div class="sourceCode" id="cb49"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Exercise_6_2_16 {A : <span class="kw">Type</span>} (f : A → A)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    (h : one_to_one f) : ∀ (n : Nat) (B : Set A), numElts B n →</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>    closed f B → ∀ y ∈ B, ∃ x ∈ B, f x = y := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="8">
<div class="sourceCode" id="cb50"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint:  Use Exercise_6_2_2.</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_6_2_2 {A : <span class="kw">Type</span>} (R : BinRel A)</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    (h1 : ∃ (n : Nat), numElts {x : A | x = x} n)</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    (h2 : partial_order R) : ∃ (T : BinRel A),</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>      total_order T ∧ ∀ (x y : A), R x y → T x y := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="recursion" class="level2">
<h2 class="anchored" data-anchor-id="recursion">6.3. Recursion</h2>
<p>In the last two sections, we saw that we can prove that all natural numbers have some property by proving that 0 has the property, and also that for every natural number <span class="math inline">\(n\)</span>, if <span class="math inline">\(n\)</span> has the property then so does <span class="math inline">\(n + 1\)</span>. In this section we will see that a similar idea can be used to define a function whose domain is the natural numbers. We can define a function <span class="math inline">\(f\)</span> with domain <span class="math inline">\(\mathbb{N}\)</span> by specifying the value of <span class="math inline">\(f(0)\)</span>, and also saying how to compute <span class="math inline">\(f(n+1)\)</span> if you already know the value of <span class="math inline">\(f(n)\)</span>.</p>
<p>For example, we can define a function <span class="math inline">\(f : \mathbb{N} \to \mathbb{N}\)</span> as follows:</p>
<div class="quote">
<p><span class="math inline">\(f(0) = 1\)</span>;<br> for every <span class="math inline">\(n \in \mathbb{N}\)</span>, <span class="math inline">\(f(n+1) = (n+1) \cdot f(n)\)</span>.</p>
</div>
<p>Here is the same definition written in Lean. (For reasons that will become clear shortly, we have given the function the name <code>fact</code>.)</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fact (k : Nat) : Nat :=</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> k <span class="kw">with</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; 1</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    | n + 1 =&gt; (n + 1) * fact n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Lean can use this definition to compute <code>fact k</code> for any natural number <code>k</code>. The <code>match</code> statement tells Lean to try to match the input <code>k</code> with one of the two patterns <code>0</code> and <code>n + 1</code>, and then to use the corresponding formula after <code>=&gt;</code> to compute <code>fact k</code>. For example, if we ask Lean for <code>fact 4</code>, it first checks if <code>4</code> matches <code>0</code>. Since it doesn’t, it goes on to the next line and determines that <code>4</code> matches the pattern <code>n + 1</code>, with <code>n = 3</code>, so it uses the formula <code>fact 4 = 4 * fact 3</code>. Of course, now it must compute <code>fact 3</code>, which it does in the same way: <code>3</code> matches <code>n + 1</code> with <code>n = 2</code>, so <code>fact 3 = 3 * fact 2</code>. Continuing in this way, Lean determines that</p>
<div class="ind">
<pre><code>fact 4 = 4 * fact 3 = 4 * (3 * fact 2) = 4 * (3 * (2 * fact 1))
       = 4 * (3 * (2 * (1 * fact 0))) = 4 * (3 * (2 * (1 * 1))) = 24.</code></pre>
</div>
<p>You can confirm this with the <code>#eval</code> command:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">#eval</span> fact 4   <span class="co">--Answer: 24</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Of course, by now you have probably guessed why we used the name <code>fact</code> for his function: <code>fact k</code> is <code>k</code> factorial—the product of all the numbers from 1 to <code>k</code>.</p>
<p>This style of definition is called a <em>recursive</em> definition. If a function is defined by a recursive definition, then theorems about that function are often most easily proven by induction. For example, here is a theorem about the factorial function. It is Example 6.3.1 in <em>HTPI</em>, and we begin the Lean proof by imitating the proof in <em>HTPI</em>.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> <span class="sc">??</span><span class="an">Example_6_3_1</span><span class="sc">::</span> : ∀ n ≥ 4, fact n &gt; 2 ^ n := <span class="kw">by</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">decide</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> n : Nat</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : n ≥ 4</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : fact n &gt; 2 ^ n</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> fact (n + 1) &gt; 2 ^ (n + 1) <span class="kw">from</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> fact (n + 1)</span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>        _ = (n + 1) * fact n := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>        _ &gt; (n + 1) * 2 ^ n := <span class="cn">sorry</span></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a>        _ &gt; 2 * 2 ^ n := <span class="cn">sorry</span></span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>        _ = 2 ^ (n + 1) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>There are two steps in the calculational proof at the end that require justification. The first says that <code>(n + 1) * fact n &gt; (n + 1) * 2 ^ n</code>, which should follow from the inductive hypothesis <code>ih : fact n &gt; 2 ^ n</code> by multiplying both sides by <code>n + 1</code>. Is there a theorem that would justify this inference?</p>
<p>This may remind you of a step in <code>Example_6_1_3</code> where we used the theorem <code>Nat.mul_le_mul_right</code>, which says <code>∀ {n m : ℕ} (k : ℕ), n ≤ m → n * k ≤ m * k</code>. Our situation in this example is similar, but it involves a strict inequality (<code>&gt;</code> rather than <code>≥</code>) and it involves multiplying on the left rather than the right. Many theorems about inequalities in Lean’s library contain either <code>le</code> (for “less than or equal to”) or <code>lt</code> (for “less than”) in their names, but they can also be used to prove statements involving <code>≥</code> or <code>&gt;</code>. Perhaps the theorem we need is named something like <code>Nat.mul_lt_mul_left</code>. If you type <code>#check @Nat.mul_lt_mul_</code> into VS Code, a pop-up window will appear listing several theorems that begin with <code>Nat.mul_lt_mul_</code>. There is no <code>Nat.mul_lt_mul_left</code>, but there is a theorem called <code>Nat.mul_lt_mul_of_pos_left</code>, and its meaning is</p>
<div class="ind">
<pre><code>@Nat.mul_lt_mul_of_pos_left : ∀ {n m k : ℕ},
                                n &lt; m → k &gt; 0 → k * n &lt; k * m</code></pre>
</div>
<p>Lean has correctly reminded us that, to multiply both sides of a strict inequality by a number <code>k</code>, we need to know that <code>k &gt; 0</code>. So in our case, we’ll need to prove that <code>n + 1 &gt; 0</code>. Once we have that, we can use the theorem <code>Nat.mul_lt_mul_of_pos_left</code> to eliminate the first <code>sorry</code>.</p>
<p>The second <code>sorry</code> is similar: <code>(n + 1) * 2 ^ n &gt; 2 * 2 ^ n</code> should follow from <code>n + 1 &gt; 2</code> and <code>2 ^ n &gt; 0</code>, and you can verify that the theorem that will justify this inference is <code>Nat.mul_lt_mul_of_pos_right</code>.</p>
<p>So we have three inequalities that we need to prove before we can justify the steps of the calculational proof: <code>n + 1 &gt; 0</code>, <code>n + 1 &gt; 2</code>, and <code>2 ^ n &gt; 0</code>. We’ll insert <code>have</code> steps before the calculational proof to assert these three inequalities. If you try it, you’ll find that <code>linarith</code> can prove the first two, but not the third.</p>
<p>How can we prove <code>2 ^ n &gt; 0</code>? It is often helpful to think about whether there is a general principle that is behind a statement we are trying to prove. In our case, the inequality <code>2 ^ n &gt; 0</code> is an instance of the general fact that if <code>m</code> and <code>n</code> are any natural numbers with <code>m &gt; 0</code>, then <code>m ^ n &gt; 0</code>. Maybe that fact is in Lean’s library:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (m n : Nat) (h : m &gt; 0) : m ^ n &gt; 0 := <span class="kw">by</span> <span class="sc">++</span><span class="do">apply?</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>apply?</code> tactic comes up with <code>exact Nat.pos_pow_of_pos n h</code>, and <code>#check @Nat.pos_pow_of_pos</code> gives the result</p>
<div class="ind">
<pre><code>@Nat.pos_pow_of_pos : ∀ {n : ℕ} (m : ℕ), 0 &lt; n → 0 &lt; n ^ m</code></pre>
</div>
<p>That means that we can use <code>Nat.pos_pow_of_pos</code> to prove <code>2 ^ n &gt; 0</code>, but first we’ll need to prove that <code>2 &gt; 0</code>. We now have all the pieces we need; putting them together leads to this proof:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_6_3_1 : ∀ n ≥ 4, fact n &gt; 2 ^ n := <span class="kw">by</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">decide</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> n : Nat</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : n ≥ 4</span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : fact n &gt; 2 ^ n</span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : n + 1 &gt; 0 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : n + 1 &gt; 2 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : 2 &gt; 0 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h5 : 2 ^ n &gt; 0 := Nat.pos_pow_of_pos n h4</span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> fact (n + 1) &gt; 2 ^ (n + 1) <span class="kw">from</span></span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> fact (n + 1)</span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a>        _ = (n + 1) * fact n := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a>        _ &gt; (n + 1) * 2 ^ n := Nat.mul_lt_mul_of_pos_left ih h2</span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a>        _ &gt; 2 * 2 ^ n := Nat.mul_lt_mul_of_pos_right h3 h5</span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a>        _ = 2 ^ (n + 1) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>But there is an easier way. Look at the two “&gt;” steps in the calculational proof at the end of <code>Example_6_3_1</code>. In both cases, we took a known relationship between two quantities and did something to both sides that preserved the relationship. In the first case, the known relationship was <code>ih : fact n &gt; 2 ^ n</code>, and we multiplied both sides by <code>n + 1</code> on the left; in the second, the known relationship was <code>h3 : n + 1 &gt; 2</code>, and we multiplied both sides by <code>2 ^ n</code> on the right. To justify these steps, we had to find the right theorems in Lean’s library, and we ended up needing auxiliary positivity facts: <code>h2 : n + 1 &gt; 0</code> in the first case and <code>h5 : 2 ^ n &gt; 0</code> in the second. There is a tactic that can simplify these steps: if <code>h</code> is a proof of a statement asserting a relationship between two quantities, then the tactic <code>rel [h]</code> will attempt to prove any statement obtained from that relationship by applying the same operation to both sides. The tactic will try to find a theorem in Lean’s library that says that the operation preserves the relationship, and if the theorem requires auxiliary positivity facts, it will try to prove those facts as well. The <code>rel</code> tactic doesn’t always succeed, but when it does, it saves you the trouble of searching through the library for the necessary theorems. In this case, the tactic allows us to give a much simpler proof of <code>Example_6_3_1</code>:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_6_3_1 : ∀ n ≥ 4, fact n &gt; 2 ^ n := <span class="kw">by</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">decide</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> n : Nat</span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : n ≥ 4</span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : fact n &gt; 2 ^ n</span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : n + 1 &gt; 2 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> fact (n + 1) &gt; 2 ^ (n + 1) <span class="kw">from</span></span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> fact (n + 1)</span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a>        _ = (n + 1) * fact n := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a>        _ &gt; (n + 1) * 2 ^ n := <span class="kw">by</span> <span class="kw">rel</span> [ih]</span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a>        _ &gt; 2 * 2 ^ n := <span class="kw">by</span> <span class="kw">rel</span> [h2]</span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a>        _ = 2 ^ (n + 1) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The next example in <em>HTPI</em> is a proof of one of the laws of exponents: <code>a ^ (m + n) = a ^ m * a ^ n</code>. Lean’s definition of exponentiation with natural number exponents is recursive. The definitions Lean uses are essentially as follows:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="co">--For natural numbers b and k, b ^ k = nat_pow b k:</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> nat_pow (b k : Nat) : Nat :=</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> k <span class="kw">with</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; 1</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>    | n + 1 =&gt; (nat_pow b n) * b</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a><span class="co">--For a real number b and a natural number k, b ^ k = real_pow b k:</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> real_pow (b : Real) (k : Nat) : Real :=</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> k <span class="kw">with</span></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; 1</span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>    | n + 1 =&gt; (real_pow b n) * b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let’s prove the addition law for exponents:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_6_3_2_cheating : ∀ (a : Real) (m n : Nat),</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>    a ^ (m + n) = a ^ m * a ^ n := <span class="kw">by</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : Real; <span class="kw">fix</span> m : Nat; <span class="kw">fix</span> n : Nat</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">ring</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Well, that wasn’t really fair. The <code>ring</code> tactic knows the laws of exponents, so it has no trouble proving this theorem. But we want to know <em>why</em> the law holds, so let’s see if we can prove it without using <code>ring</code>. The following proof is essentially the same as the proof in <em>HTPI</em>:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_6_3_2 : ∀ (a : Real) (m n : Nat),</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>    a ^ (m + n) = a ^ m * a ^ n := <span class="kw">by</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : Real; <span class="kw">fix</span> m : Nat</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">--Goal : ∀ (n : Nat), a ^ (m + n) = a ^ m * a ^ n</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> a ^ (m + 0) = a ^ m * a ^ 0 <span class="kw">from</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> a ^ (m + 0)</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>        _ = a ^ m := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>        _ = a ^ m * 1 := (mul_one (a ^ m)).symm</span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>        _ = a ^ m * a ^ 0 := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> n : Nat</span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : a ^ (m + n) = a ^ m * a ^ n</span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> a ^ (m + (n + 1)) = a ^ m * a ^ (n + 1) <span class="kw">from</span></span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> a ^ (m + (n + 1))</span>
<span id="cb62-18"><a href="#cb62-18" aria-hidden="true" tabindex="-1"></a>        _ = a ^ ((m + n) + 1) := <span class="kw">by</span> <span class="kw">rw</span> [add_assoc]</span>
<span id="cb62-19"><a href="#cb62-19" aria-hidden="true" tabindex="-1"></a>        _ = a ^ (m + n) * a := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb62-20"><a href="#cb62-20" aria-hidden="true" tabindex="-1"></a>        _ = (a ^ m * a ^ n) * a := <span class="kw">by</span> <span class="kw">rw</span> [ih]</span>
<span id="cb62-21"><a href="#cb62-21" aria-hidden="true" tabindex="-1"></a>        _ = a ^ m * (a ^ n * a) := <span class="kw">by</span> <span class="kw">rw</span> [mul_assoc]</span>
<span id="cb62-22"><a href="#cb62-22" aria-hidden="true" tabindex="-1"></a>        _ = a ^ m * (a ^ (n + 1)) := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb62-23"><a href="#cb62-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb62-24"><a href="#cb62-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, we’ll prove the theorem in Example 6.3.4 of <em>HTPI</em>, which again involves exponentiation with natural number exponents. Here’s the beginning of the proof:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb63"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_6_3_4 : ∀ (x : Real), x &gt; -1 →</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), (1 + x) ^ n ≥ 1 + n * x := <span class="kw">by</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : Real</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : x &gt; -1</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb64"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: ℝ</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: x &gt; -1</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>⊢ ∀ (n : ℕ),</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  (1 + x) ^ n ≥</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>    1 + ↑n * x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Look carefully at the goal in the tactic state. Why is there a <code>↑</code> before the last <code>n</code>? The reason has to do with types. The variable <code>x</code> has type <code>Real</code> and <code>n</code> has type <code>Nat</code>, so how can Lean multiply <code>n</code> by <code>x</code>? Remember, in Lean, the natural numbers are not a subset of the real numbers. The two types are completely separate, but for each natural number, there is a corresponding real number. To multiply <code>n</code> by <code>x</code>, Lean had to convert <code>n</code> to the corresponding real number, through a process called <em>coercion</em>. The notation <code>↑n</code> denotes the result of <em>coercing</em> (or <em>casting</em>) <code>n</code> to another type—in this case, <code>Real</code>. Since <code>↑n</code> and <code>x</code> are both real numbers, Lean can use the multiplication operation on the real numbers to multiply them. (To type <code>↑</code> in VSCode, type <code>\uparrow</code>, or just <code>\u</code>.)</p>
<p>As we will see, the need for coercion in this example will make the proof a bit more complicated, because we’ll need to use some theorems about coercions. Theorems about coercion of natural numbers to some other type often have names that start <code>Nat.cast</code>.</p>
<p>Continuing with the proof, since exponentiation is defined recursively, let’s try mathematical induction:</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb65"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_6_3_4 : ∀ (x : Real), x &gt; -1 →</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), (1 + x) ^ n ≥ 1 + n * x := <span class="kw">by</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : Real</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : x &gt; -1</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span>  </span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb66"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> Base_Case</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: ℝ</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: x &gt; -1</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>⊢ (1 + x) ^ 0 ≥</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  1 + ↑0 * x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>You might think that <code>linarith</code> could prove the goal for the base case, but it can’t. The problem is the <code>↑0</code>, which denotes the result of coercing the natural number <code>0</code> to a real number. Of course, that should be the real number <code>0</code>, but is it? Yes, but the <code>linarith</code> tactic doesn’t know that. The theorem <code>Nat.cast_zero</code> says that <code>↑0 = 0</code> (where the <code>0</code> on the right side of the equation is the <em>real number</em> <code>0</code>), so the tactic <code>rewrite [Nat.cast_zero]</code> will convert <code>↑0</code> to <code>0</code>. After that step, <code>linarith</code> can complete the proof of the base case, and we can start on the induction step.</p>
<div class="inout">
<div class="inpt">
<div class="sourceCode" id="cb67"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_6_3_4 : ∀ (x : Real), x &gt; -1 →</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), (1 + x) ^ n ≥ 1 + n * x := <span class="kw">by</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : Real</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : x &gt; -1</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [Nat.cast_zero]</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">linarith</span></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> n : Nat</span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : (1 + x) ^ n ≥ 1 + n * x</span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="outpt">
<div class="sourceCode" id="cb68"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="re">case</span> Induction_Step</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="in">x </span>: ℝ</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a><span class="in">h1 </span>: x &gt; -1</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="in">n </span>: ℕ</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a><span class="in">ih </span>: (1 + x) ^ n ≥</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>    1 + ↑n * x</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>⊢ (1 + x) ^ (n + 1) ≥</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  1 + ↑(n + 1) * x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Once again, there’s a complication caused by coercion. The inductive hypothesis talks about <code>↑n</code>, but the goal involves <code>↑(n + 1)</code>. What is the relationship between these? Surely it should be the case that <code>↑(n + 1) = ↑n + 1</code>; that is, the result of coercing the natural number <code>n + 1</code> to a real number should be one larger than the result of coercing <code>n</code> to a real number. The theorem <code>Nat.cast_succ</code> says exactly that, so <code>rewrite [Nat.cast_succ]</code> will change the <code>↑(n + 1)</code> in the goal to <code>↑n + 1</code>. (The number <code>n + 1</code> is sometimes called the <em>successor</em> of <code>n</code>, and <code>succ</code> is short for “successor.”) With that change, we can continue with the proof. The following proof is modeled on the proof in <em>HTPI</em>.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> <span class="sc">??</span><span class="an">Example_6_3_4</span><span class="sc">::</span> : ∀ (x : Real), x &gt; -1 →</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), (1 + x) ^ n ≥ 1 + n * x := <span class="kw">by</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : Real</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : x &gt; -1</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [Nat.cast_zero]</span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">linarith</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> n : Nat</span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : (1 + x) ^ n ≥ 1 + n * x</span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [Nat.cast_succ]</span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> (1 + x) ^ (n + 1) ≥ 1 + (n + 1) * x <span class="kw">from</span></span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> (1 + x) ^ (n + 1)</span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>        _ = (1 + x) ^ n * (1 + x) := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>        _ ≥ (1 + n * x) * (1 + x) := <span class="cn">sorry</span></span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a>        _ = 1 + n * x + x + n * x ^ 2 := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true" tabindex="-1"></a>        _ ≥ 1 + n * x + x + 0 := <span class="cn">sorry</span></span>
<span id="cb69-20"><a href="#cb69-20" aria-hidden="true" tabindex="-1"></a>        _ = 1 + (n + 1) * x := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb69-21"><a href="#cb69-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb69-22"><a href="#cb69-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Note that in the calculational proof, each <code>n</code> or <code>n + 1</code> that is multiplied by <code>x</code> is really <code>↑n</code> or <code>↑n + 1</code>, but we don’t need to say so explicitly; Lean fills in coercions automatically when they are required.</p>
<p>All that’s left is to replace the two occurrences of <code>sorry</code> with justifications. The first <code>sorry</code> step should follow from the inductive hypothesis by multiplying both sides by <code>1 + x</code>, so a natural attempt to justify it would be <code>by rel [ih]</code>. Unfortunately, we get an error message saying that <code>rel</code> failed. The error message tells us that <code>rel</code> needed to know that <code>0 ≤ 1 + x</code>, and it was unable to prove it, so we’ll have to provide a proof of that statement ourselves. Fortunately, <code>linarith</code> can handle it (deducing it from <code>h1 : x &gt; -1</code>), and once we fill in that additional step, the <code>rel</code> tactic succeeds.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> <span class="sc">??</span><span class="an">Example_6_3_4</span><span class="sc">::</span> : ∀ (x : Real), x &gt; -1 →</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), (1 + x) ^ n ≥ 1 + n * x := <span class="kw">by</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : Real</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : x &gt; -1</span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [Nat.cast_zero]</span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">linarith</span></span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> n : Nat</span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : (1 + x) ^ n ≥ 1 + n * x</span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [Nat.cast_succ]</span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : 0 ≤ 1 + x := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> (1 + x) ^ (n + 1) ≥ 1 + (n + 1) * x <span class="kw">from</span></span>
<span id="cb70-16"><a href="#cb70-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> (1 + x) ^ (n + 1)</span>
<span id="cb70-17"><a href="#cb70-17" aria-hidden="true" tabindex="-1"></a>        _ = (1 + x) ^ n * (1 + x) := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb70-18"><a href="#cb70-18" aria-hidden="true" tabindex="-1"></a>        _ ≥ (1 + n * x) * (1 + x) := <span class="kw">by</span> <span class="kw">rel</span> [ih]</span>
<span id="cb70-19"><a href="#cb70-19" aria-hidden="true" tabindex="-1"></a>        _ = 1 + n * x + x + n * x ^ 2 := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb70-20"><a href="#cb70-20" aria-hidden="true" tabindex="-1"></a>        _ ≥ 1 + n * x + x + 0 := <span class="cn">sorry</span></span>
<span id="cb70-21"><a href="#cb70-21" aria-hidden="true" tabindex="-1"></a>        _ = 1 + (n + 1) * x := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb70-22"><a href="#cb70-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb70-23"><a href="#cb70-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For the second <code>sorry</code> step, we’ll need to know that <code>n * x ^ 2 ≥ 0</code>. To prove it, we start with the fact that the square of any real number is nonnegative:</p>
<div class="ind">
<pre><code>@sq_nonneg : ∀ {α : Type u_1} [inst : LinearOrderedSemiring α]
              [inst_1 : ExistsAddOfLE α]
              (a : α), 0 ≤ a ^ 2</code></pre>
</div>
<p>As usual, we don’t need to pay much attention to the implicit arguments; what is important is the last line, which tells us that <code>sq_nonneg x</code> is a proof of <code>x ^ 2 ≥ 0</code>. To get <code>n * x ^ 2 ≥ 0</code> we just have to multiply both sides by <code>n</code>, which we can justify with the <code>rel</code> tactic, and then one more application of <code>rel</code> will handle the remaining <code>sorry</code>. Here is the complete proof:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_6_3_4 : ∀ (x : Real), x &gt; -1 →</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), (1 + x) ^ n ≥ 1 + n * x := <span class="kw">by</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : Real</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : x &gt; -1</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [Nat.cast_zero]</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">linarith</span></span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> n : Nat</span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : (1 + x) ^ n ≥ 1 + n * x</span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [Nat.cast_succ]</span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : 0 ≤ 1 + x := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : x ^ 2 ≥ 0 := sq_nonneg x</span>
<span id="cb72-16"><a href="#cb72-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : n * x ^ 2 ≥ 0 :=</span>
<span id="cb72-17"><a href="#cb72-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> n * x ^ 2</span>
<span id="cb72-18"><a href="#cb72-18" aria-hidden="true" tabindex="-1"></a>        _ ≥ n * 0 := <span class="kw">by</span> <span class="kw">rel</span> [h3]</span>
<span id="cb72-19"><a href="#cb72-19" aria-hidden="true" tabindex="-1"></a>        _ = 0 := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb72-20"><a href="#cb72-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> (1 + x) ^ (n + 1) ≥ 1 + (n + 1) * x <span class="kw">from</span></span>
<span id="cb72-21"><a href="#cb72-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> (1 + x) ^ (n + 1)</span>
<span id="cb72-22"><a href="#cb72-22" aria-hidden="true" tabindex="-1"></a>        _ = (1 + x) ^ n * (1 + x) := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb72-23"><a href="#cb72-23" aria-hidden="true" tabindex="-1"></a>        _ ≥ (1 + n * x) * (1 + x) := <span class="kw">by</span> <span class="kw">rel</span> [ih]</span>
<span id="cb72-24"><a href="#cb72-24" aria-hidden="true" tabindex="-1"></a>        _ = 1 + n * x + x + n * x ^ 2 := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb72-25"><a href="#cb72-25" aria-hidden="true" tabindex="-1"></a>        _ ≥ 1 + n * x + x + 0 := <span class="kw">by</span> <span class="kw">rel</span> [h4]</span>
<span id="cb72-26"><a href="#cb72-26" aria-hidden="true" tabindex="-1"></a>        _ = 1 + (n + 1) * x := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb72-27"><a href="#cb72-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb72-28"><a href="#cb72-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Before ending this section, we’ll return to a topic left unexplained before. We can now describe how <code>Sum i from k to n, f i</code> is defined. The key is a function <code>sum_seq</code>, which is defined by recursion:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sum_seq {A : <span class="kw">Type</span>} [AddZeroClass A]</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>    (m k : Nat) (f : Nat → A) : A :=</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; 0</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>    | n + 1 =&gt; sum_seq n k f + f (k + n)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To get an idea of what this definition means, let’s try evaluating <code>sum_seq 3 k f</code>:</p>
<div class="ind">
<pre><code>sum_seq 3 k f = sum_seq 2 k f + f (k + 2)
              = sum_seq 1 k f + f (k + 1) + f (k + 2)
              = sum_seq 0 k f + f (k + 0) + f (k + 1) + f (k + 2)
              = 0 + f (k + 0) + f (k + 1) + f (k + 2)
              = f k + f (k + 1) + f (k + 2).</code></pre>
</div>
<p>So <code>sum_seq 3 k f</code> adds up three consecutive values of <code>f</code>, starting with <code>f k</code>. More generally, <code>sum_seq n k f</code> adds up a sequence of <code>n</code> consecutive values of <code>f</code>, starting with <code>f k</code>. (The implicit arguments say that the type of the values of <code>f</code> can be any type for which <code>+</code> and <code>0</code> make sense.) The notation <code>Sum i from k to n, f i</code> is now defined to be a shorthand for <code>sum_seq (n + 1 - k) k f</code>. We’ll leave it to you to puzzle out why that gives the desired result.</p>
<section id="exercises-2" class="level3">
<h3 class="anchored" data-anchor-id="exercises-2">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb75"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_3_4 : ∀ (n : Nat),</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>    3 * (<span class="kw">Sum</span> i <span class="kw">from</span> 0 <span class="kw">to</span> n, (2 * i + 1) ^ 2) =</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>    (n + 1) * (2 * n + 1) * (2 * n + 3) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb76"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_3_7b (f : Nat → Real) (c : Real) : ∀ (n : Nat),</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">Sum</span> i <span class="kw">from</span> 0 <span class="kw">to</span> n, c * f i = c * <span class="kw">Sum</span> i <span class="kw">from</span> 0 <span class="kw">to</span> n, f i := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb77"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> fact_pos : ∀ (n : Nat), fact n ≥ 1 := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb78"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint:  Use the theorem fact_pos from the previous exercise.</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_3_13a (k : Nat) : ∀ (n : Nat),</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>    fact (k ^ 2 + n) ≥ k ^ (2 * n) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb79"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint:  Use the theorem in the previous exercise.</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a><span class="co">--You may find it useful to first prove a lemma:</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a><span class="co">--∀ (k : Nat), 2 * k ^ 2 + 1 ≥ k</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_3_13b (k : Nat) : ∀ n ≥ 2 * k ^ 2,</span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>    fact n ≥ k ^ n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>6. A sequence is defined recursively as follows:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> seq_6_3_15 (k : Nat) : Int :=</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> k <span class="kw">with</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; 0</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>    | n + 1 =&gt; 2 * seq_6_3_15 n + n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Prove the following theorem about this sequence:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_3_15 : ∀ (n : Nat),</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>    seq_6_3_15 n = 2 ^ n - n - 1 := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>7. A sequence is defined recursively as follows:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> seq_6_3_16 (k : Nat) : Nat :=</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> k <span class="kw">with</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; 2</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>    | n + 1 =&gt; (seq_6_3_16 n) ^ 2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Find a formula for <code>seq_6_3_16 n</code>. Fill in the blank in the theorem below with your formula and then prove the theorem.</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_3_16 : ∀ (n : Nat),</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>    seq_6_3_16 n = ___ := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="strong-induction" class="level2">
<h2 class="anchored" data-anchor-id="strong-induction">6.4. Strong Induction</h2>
<p>In the induction step of a proof by mathematical induction, we prove that a natural number has some property from the assumption that the previous number has the property. Section 6.4 of <em>HTPI</em> introduces a version of mathematical induction in which we get to assume that <em>all</em> smaller numbers have the property. Since this is a stronger assumption, this version of induction is called <em>strong induction</em>. Here is how strong induction works (<em>HTPI</em> p.&nbsp;304):</p>
<section id="to-prove-a-goal-of-the-form-n-nat-p-n-1" class="level4">
<h4 class="anchored" data-anchor-id="to-prove-a-goal-of-the-form-n-nat-p-n-1">To prove a goal of the form <code>∀ (n : Nat), P n</code>:</h4>
<div class="ind">
<p>Prove that <code>∀ (n : Nat), (∀ n_1 &lt; n, P n_1) → P n</code>.</p>
</div>
<p>To write a proof by strong induction in Lean, we use the tactic <code>by_strong_induc</code>, whose effect on the tactic state can be illustrated as follows.</p>
<div class="lftrt">
<div class="bef">
<div class="sourceCode" id="cb84"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span> ⋮</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>⊢ ∀ (n : Nat), P n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="aft">
<div class="sourceCode" id="cb85"><pre class="sourceCode state code-with-copy"><code class="sourceCode state"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span> ⋮</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>⊢  ∀ (n : Nat),</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;&gt;</span>  (∀ n_1 &lt; n, P n_1) → P n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>To illustrate this, we begin with Example 6.4.1 of <em>HTPI</em>.</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_6_4_1 : ∀ m &gt; 0, ∀ (n : Nat),</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>    ∃ (q r : Nat), n = m * q + r ∧ r &lt; m</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Imitating the strategy of the proof in <em>HTPI</em>, we let <code>m</code> be an arbitrary natural number, assume <code>m &gt; 0</code>, and then prove the statement <code>∀ (n : Nat), ∃ (q r : Nat), n = m * q + r ∧ r &lt; m</code> by strong induction. That means that after introducing an arbitrary natural number <code>n</code>, we assume the inductive hypothesis, which says <code>∀ n_1 &lt; n, ∃ (q r : Nat), n_1 = m * q + r ∧ r &lt; m</code>.</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_6_4_1 : ∀ m &gt; 0, ∀ (n : Nat),</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>    ∃ (q r : Nat), n = m * q + r ∧ r &lt; m := <span class="kw">by</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> m : Nat</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : m &gt; 0</span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_strong_induc</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> n : Nat</span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> ih : ∀ n_1 &lt; n, ∃ (q r : Nat), n_1 = m * q + r ∧ r &lt; m</span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Our goal now is to prove that <code>∃ (q r : Nat), n = m * q + r ∧ r &lt; m</code>. Although strong induction does not require a base case, it is not uncommon for proofs by strong induction to involve reasoning by cases. The proof in <em>HTPI</em> uses cases based on whether or not <code>n &lt; m</code>. If <code>n &lt; m</code>, then the proof is easy: the numbers <code>q = 0</code> and <code>r​ = n</code> clearly have the required properties. If <code>¬n &lt; m</code>, then we can write <code>n</code> as <code>n = k + m</code>, for some natural number <code>k</code>. Since <code>m &gt; 0</code>, we have <code>k &lt; n</code>, so we can apply the inductive hypothesis to <code>k</code>. Notice that if <code>m &gt; 1</code>, then <code>k</code> is not the number immediately preceding <code>n</code>; that’s why this proof uses strong induction rather than ordinary induction.</p>
<p>How do we come up with the number <code>k</code> in the previous paragraph? We’ll use a theorem from Lean’s library. There are two slightly different versions of the theorem—notice that the first ends with <code>m + k</code> and the second ends with <code>k + m</code>:</p>
<div class="ind">
<pre><code>@Nat.exists_eq_add_of_le : ∀ {m n : ℕ}, m ≤ n → ∃ (k : ℕ), n = m + k

@Nat.exists_eq_add_of_le' : ∀ {m n : ℕ}, m ≤ n → ∃ (k : ℕ), n = k + m</code></pre>
</div>
<p>We’ll use the second version in our proof.</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_6_4_1 : ∀ m &gt; 0, ∀ (n : Nat),</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>    ∃ (q r : Nat), n = m * q + r ∧ r &lt; m := <span class="kw">by</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> m : Nat</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : m &gt; 0</span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_strong_induc</span></span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> n : Nat</span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> ih : ∀ n_1 &lt; n, ∃ (q r : Nat), n_1 = m * q + r ∧ r &lt; m</span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> h2 : n &lt; m</span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h2 : n &lt; m</span></span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro 0</span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro n     <span class="co">--Goal : n = m * 0 + n ∧ n &lt; m</span></span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro _ h2</span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">ring</span></span>
<span id="cb89-14"><a href="#cb89-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb89-15"><a href="#cb89-15" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h2 : ¬n &lt; m</span></span>
<span id="cb89-16"><a href="#cb89-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : m ≤ n := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb89-17"><a href="#cb89-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (k : Nat) (h4 : n = k + m) <span class="kw">from</span> Nat.exists_eq_add_of_le' h3</span>
<span id="cb89-18"><a href="#cb89-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h5 : k &lt; n := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb89-19"><a href="#cb89-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h6 : ∃ (q r : Nat), k = m * q + r ∧ r &lt; m := ih k h5</span>
<span id="cb89-20"><a href="#cb89-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (q' : Nat)</span>
<span id="cb89-21"><a href="#cb89-21" aria-hidden="true" tabindex="-1"></a>      (h7 : ∃ (r : Nat), k = m * q' + r ∧ r &lt; m) <span class="kw">from</span> h6</span>
<span id="cb89-22"><a href="#cb89-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (r' : Nat) (h8 : k = m * q' + r' ∧ r' &lt; m) <span class="kw">from</span> h7</span>
<span id="cb89-23"><a href="#cb89-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro (q' + 1)</span>
<span id="cb89-24"><a href="#cb89-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro r'     <span class="co">--Goal : n = m * (q' + 1) + r' ∧ r' &lt; m</span></span>
<span id="cb89-25"><a href="#cb89-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro _ h8.right</span>
<span id="cb89-26"><a href="#cb89-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> n = m * (q' + 1) + r' <span class="kw">from</span></span>
<span id="cb89-27"><a href="#cb89-27" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> n</span>
<span id="cb89-28"><a href="#cb89-28" aria-hidden="true" tabindex="-1"></a>        _ = k + m := h4</span>
<span id="cb89-29"><a href="#cb89-29" aria-hidden="true" tabindex="-1"></a>        _ = m * q' + r' + m := <span class="kw">by</span> <span class="kw">rw</span> [h8.left]</span>
<span id="cb89-30"><a href="#cb89-30" aria-hidden="true" tabindex="-1"></a>        _ = m * (q' + 1) + r' := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb89-31"><a href="#cb89-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb89-32"><a href="#cb89-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The numbers <code>q</code> and <code>r</code> in <code>Example_6_4_1</code> are called the <em>quotient</em> and <em>remainder</em> when <code>n</code> is divided by <code>m</code>. Lean knows how to compute these numbers: if <code>n</code> and <code>m</code> are natural numbers, then in Lean, <code>n / m</code> denotes the quotient when <code>n</code> is divided by <code>m</code>, and <code>n % m</code> denotes the remainder. (The number <code>n % m</code> is also sometimes called <code>n</code> <em>modulo</em> <code>m</code>, or <code>n</code> <em>mod</em> <code>m</code>.) And Lean knows theorems stating that these numbers have the properties specified in <code>Example_6_4_1</code>:</p>
<div class="ind">
<pre><code>@Nat.div_add_mod : ∀ (m n : ℕ), n * (m / n) + m % n = m

@Nat.mod_lt : ∀ (x : ℕ) {y : ℕ}, y &gt; 0 → x % y &lt; y</code></pre>
</div>
<p>By the way, although we are unlikely to want to use the notation <code>n / 0</code> or <code>n % 0</code>, Lean uses the definitions <code>n / 0 = 0</code> and <code>n % 0 = n</code>. As a result, the equation <code>n * (m / n) + m % n = m</code> is true even if <code>n = 0</code>. That’s why the theorem <code>Nat.div_add_mod</code> doesn’t include a requirement that <code>n &gt; 0</code>. It is important to keep in mind that division of natural numbers is not the same as division of real numbers. For example, dividing the natural number <code>5</code> by the natural number <code>2</code> gives a quotient of <code>2</code> (with a remainder of <code>1</code>), so <code>(5 : Nat) / (2 : Nat)</code> is <code>2</code>, but <code>(5 : Real) / (2 : Real)</code> is <code>2.5</code>.</p>
<p>There is also a strong form of recursion. As an example of this, here is a recursive definition of a sequence of numbers called the <em>Fibonacci numbers</em>:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Fib (n : Nat) : Nat :=</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> n <span class="kw">with</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; 0</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>    | 1 =&gt; 1</span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>    | k + 2 =&gt; Fib k + Fib (k + 1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Notice that the formula for <code>Fib (k + 2)</code> involves the <em>two</em> previous values of <code>Fib</code>, not just the immediately preceding value. That is the sense in which the recursion is <em>strong</em>. Not surprisingly, theorems about the Fibonacci numbers are often proven by induction—either ordinary or strong. We’ll illustrate this with a proof by strong induction that <code>∀ (n : Nat), Fib n &lt; 2 ^ n</code>. This time we’ll need to treat the cases <code>n = 0</code> and <code>n = 1</code> separately, since these values are treated separately in the definition of <code>Fib n</code>. And we’ll need to know that if <code>n</code> doesn’t fall into either of those cases, then it falls into the third case: <code>n = k + 2</code> for some natural number <code>k</code>. Since similar ideas will come up several times in the rest of this book, it will be useful to begin by proving lemmas that will help with this kind of reasoning.</p>
<p>We’ll need two theorems from Lean’s library, the second of which has two slightly different versions:</p>
<div class="ind">
<pre><code>@Nat.pos_of_ne_zero : ∀ {n : ℕ}, n ≠ 0 → 0 &lt; n

@lt_of_le_of_ne : ∀ {α : Type u_1} [inst : PartialOrder α] {a b : α},
                    a ≤ b → a ≠ b → a &lt; b

@lt_of_le_of_ne' : ∀ {α : Type u_1} [inst : PartialOrder α] {a b : α},
                    a ≤ b → b ≠ a → a &lt; b</code></pre>
</div>
<p>If we have <code>h1 : n ≠ 0</code>, then <code>Nat.pos_of_ne_zero h1</code> is a proof of <code>0 &lt; n</code>. But for natural numbers <code>a</code> and <code>b</code>, Lean treats <code>a &lt; b</code> as meaning the same thing as <code>a + 1 ≤ b</code>, so this is also a proof of <code>1 ≤ n</code>. If we also have <code>h2 : n ≠ 1</code>, then we can use <code>lt_of_le_of_ne'</code> to conclude <code>1 &lt; n</code>, which is definitionally equal to <code>2 ≤ n</code>. Combining this reasoning with the theorem <code>Nat.exists_eq_add_of_le'</code>, which we used in the last example, we can prove two lemmas that will be helpful for reasoning in which the first one or two natural numbers have to be treated separately.</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> exists_eq_add_one_of_ne_zero {n : Nat}</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>    (h1 : n ≠ 0) : ∃ (k : Nat), n = k + 1 := <span class="kw">by</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : 1 ≤ n := Nat.pos_of_ne_zero h1</span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ∃ (k : Nat), n = k + 1 <span class="kw">from</span> Nat.exists_eq_add_of_le' h2</span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> exists_eq_add_two_of_ne_zero_one {n : Nat}</span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a>    (h1 : n ≠ 0) (h2 : n ≠ 1) : ∃ (k : Nat), n = k + 2 := <span class="kw">by</span></span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : 1 ≤ n := Nat.pos_of_ne_zero h1</span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : 2 ≤ n := lt_of_le_of_ne' h3 h2</span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ∃ (k : Nat), n = k + 2 <span class="kw">from</span> Nat.exists_eq_add_of_le' h4</span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With this preparation, we can present the proof:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> : ∀ (n : Nat), Fib n &lt; 2 ^ n := <span class="kw">by</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_strong_induc</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> n : Nat</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> ih : ∀ n_1 &lt; n, Fib n_1 &lt; 2 ^ n_1</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> h1 : n = 0</span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h1 : n = 0</span></span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h1]   <span class="co">--Goal : Fib 0 &lt; 2 ^ 0</span></span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">decide</span></span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb94-10"><a href="#cb94-10" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h1 : ¬n = 0</span></span>
<span id="cb94-11"><a href="#cb94-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">by_cases</span> h2 : n = 1</span>
<span id="cb94-12"><a href="#cb94-12" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 2.1. h2 : n = 1</span></span>
<span id="cb94-13"><a href="#cb94-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [h2]</span>
<span id="cb94-14"><a href="#cb94-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">decide</span></span>
<span id="cb94-15"><a href="#cb94-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb94-16"><a href="#cb94-16" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 2.2. h2 : ¬n = 1</span></span>
<span id="cb94-17"><a href="#cb94-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">obtain</span> (k : Nat) (h3 : n = k + 2) <span class="kw">from</span></span>
<span id="cb94-18"><a href="#cb94-18" aria-hidden="true" tabindex="-1"></a>        exists_eq_add_two_of_ne_zero_one h1 h2</span>
<span id="cb94-19"><a href="#cb94-19" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h4 : k &lt; n := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb94-20"><a href="#cb94-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h5 : Fib k &lt; 2 ^ k := ih k h4</span>
<span id="cb94-21"><a href="#cb94-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h6 : k + 1 &lt; n := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb94-22"><a href="#cb94-22" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h7 : Fib (k + 1) &lt; 2 ^ (k + 1) := ih (k + 1) h6</span>
<span id="cb94-23"><a href="#cb94-23" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [h3]            <span class="co">--Goal : Fib (k + 2) &lt; 2 ^ (k + 2)</span></span>
<span id="cb94-24"><a href="#cb94-24" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> Fib (k + 2) &lt; 2 ^ (k + 2) <span class="kw">from</span></span>
<span id="cb94-25"><a href="#cb94-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">calc</span> Fib (k + 2)</span>
<span id="cb94-26"><a href="#cb94-26" aria-hidden="true" tabindex="-1"></a>          _ = Fib k + Fib (k + 1) := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb94-27"><a href="#cb94-27" aria-hidden="true" tabindex="-1"></a>          _ &lt; 2 ^ k + Fib (k + 1) := <span class="kw">by</span> <span class="kw">rel</span> [h5]</span>
<span id="cb94-28"><a href="#cb94-28" aria-hidden="true" tabindex="-1"></a>          _ &lt; 2 ^ k + 2 ^ (k + 1) := <span class="kw">by</span> <span class="kw">rel</span> [h7]</span>
<span id="cb94-29"><a href="#cb94-29" aria-hidden="true" tabindex="-1"></a>          _ ≤ 2 ^ k + 2 ^ (k + 1) + 2 ^ k := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb94-30"><a href="#cb94-30" aria-hidden="true" tabindex="-1"></a>          _ = 2 ^ (k + 2) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb94-31"><a href="#cb94-31" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb94-32"><a href="#cb94-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb94-33"><a href="#cb94-33" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>As with ordinary induction, strong induction can be useful for proving statements that do not at first seem to have the form <code>∀ (n : Nat), ...</code>. To illustrate this, we’ll prove the <em>well-ordering principle</em>, which says that if a set <code>S : Set Nat</code> is nonempty, then it has a smallest element. We’ll prove the contrapositive: if <code>S</code> has no smallest element, then it is empty. To say that <code>S</code> is empty means <code>∀ (n : Nat), n ∉ S</code>, and that’s the statement to which we will apply strong induction.</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> well_ord_princ (S : Set Nat) : (∃ (n : Nat), n ∈ S) →</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>    ∃ n ∈ S, ∀ m ∈ S, n ≤ m := <span class="kw">by</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">contrapos</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : ¬∃ n ∈ S, ∀ m ∈ S, n ≤ m</span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">quant_neg</span>                   <span class="co">--Goal : ∀ (n : Nat), n ∉ S</span></span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_strong_induc</span></span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> n : Nat</span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> ih : ∀ n_1 &lt; n, n_1 ∉ S  <span class="co">--Goal : n ∉ S</span></span>
<span id="cb95-9"><a href="#cb95-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">contradict</span> h1 <span class="kw">with</span> h2       <span class="co">--h2 : n ∈ S</span></span>
<span id="cb95-10"><a href="#cb95-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">--Goal : ∃ n ∈ S, ∀ m ∈ S, n ≤ m</span></span>
<span id="cb95-11"><a href="#cb95-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro n        <span class="co">--Goal : n ∈ S ∧ ∀ m ∈ S, n ≤ m</span></span>
<span id="cb95-12"><a href="#cb95-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro h2          <span class="co">--Goal : ∀ m ∈ S, n ≤ m</span></span>
<span id="cb95-13"><a href="#cb95-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> m : Nat</span>
<span id="cb95-14"><a href="#cb95-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : m ∈ S</span>
<span id="cb95-15"><a href="#cb95-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : m &lt; n → m ∉ S := ih m</span>
<span id="cb95-16"><a href="#cb95-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">contrapos</span> <span class="kw">at</span> h4             <span class="co">--h4 : m ∈ S → ¬m &lt; n</span></span>
<span id="cb95-17"><a href="#cb95-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : ¬m &lt; n := h4 h3</span>
<span id="cb95-18"><a href="#cb95-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">linarith</span></span>
<span id="cb95-19"><a href="#cb95-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Section 6.4 of <em>HTPI</em> ends with an example of an application of the well-ordering principle. The example gives a proof that <span class="math inline">\(\sqrt{2}\)</span> is irrational. If <span class="math inline">\(\sqrt{2}\)</span> were rational, then there would be natural numbers <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> such that <span class="math inline">\(q \ne 0\)</span> and <span class="math inline">\(p/q = \sqrt{2}\)</span>, and therefore <span class="math inline">\(p^2 = 2q^2\)</span>. So we can prove that <span class="math inline">\(\sqrt{2}\)</span> is irrational by showing that there do not exist natural numbers <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> such that <span class="math inline">\(q \ne 0\)</span> and <span class="math inline">\(p^2 = 2q^2\)</span>.</p>
<p>The proof uses a definition from the exercises of Section 6.1:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> nat_even (n : Nat) : <span class="kw">Prop</span> := ∃ (k : Nat), n = 2 * k</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We will also use the following lemma, whose proof we leave as an exercise for you:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> sq_even_iff_even (n : Nat) : nat_even (n * n) ↔ nat_even n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>And we’ll need another theorem that we haven’t seen before:</p>
<div class="ind">
<pre><code>@mul_left_cancel_iff_of_pos : ∀ {α : Type u_1} {a b c : α}
                    [inst : MulZeroClass α] [inst_1 : PartialOrder α]
                    [inst_2 : PosMulReflectLE α],
                    0 &lt; a → (a * b = a * c ↔ b = c)</code></pre>
</div>
<p>To show that <span class="math inline">\(\sqrt{2}\)</span> is irrational, we will prove the statement</p>
<div class="quote">
<pre><code>¬∃ (q p : Nat), p * p = 2 * (q * q) ∧ q ≠ 0</code></pre>
</div>
<p>We proceed by contradiction. If this statement were false, then the set</p>
<div class="quote">
<pre><code>S = {q : Nat | ∃ (p : Nat), p * p = 2 * (q * q) ∧ q ≠ 0}</code></pre>
</div>
<p>would be nonempty, and therefore, by the well-ordering principle, it would have a smallest element. We then show that this leads to a contradiction. Here is the proof.</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_6_4_5 :</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>    ¬∃ (q p : Nat), p * p = 2 * (q * q) ∧ q ≠ 0 := <span class="kw">by</span></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> S : Set Nat :=</span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>    {q : Nat | ∃ (p : Nat), p * p = 2 * (q * q) ∧ q ≠ 0}</span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_contra</span> h1</span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : ∃ (q : Nat), q ∈ S := h1</span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : ∃ q ∈ S, ∀ r ∈ S, q ≤ r := well_ord_princ S h2</span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (q : Nat) (h4 : q ∈ S ∧ ∀ r ∈ S, q ≤ r) <span class="kw">from</span> h3</span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> qinS : q ∈ S := h4.left</span>
<span id="cb101-10"><a href="#cb101-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> qleast : ∀ r ∈ S, q ≤ r := h4.right</span>
<span id="cb101-11"><a href="#cb101-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> qinS     <span class="co">--qinS : ∃ (p : Nat), p * p = 2 * (q * q) ∧ q ≠ 0</span></span>
<span id="cb101-12"><a href="#cb101-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (p : Nat) (h5 : p * p = 2 * (q * q) ∧ q ≠ 0) <span class="kw">from</span> qinS</span>
<span id="cb101-13"><a href="#cb101-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> pqsqrt2 : p * p = 2 * (q * q) := h5.left</span>
<span id="cb101-14"><a href="#cb101-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> qne0 : q ≠ 0 := h5.right</span>
<span id="cb101-15"><a href="#cb101-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : nat_even (p * p) := Exists.intro (q * q) pqsqrt2</span>
<span id="cb101-16"><a href="#cb101-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [sq_even_iff_even p] <span class="kw">at</span> h6    <span class="co">--h6 : nat_even p</span></span>
<span id="cb101-17"><a href="#cb101-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (p' : Nat) (p'halfp : p = 2 * p') <span class="kw">from</span> h6</span>
<span id="cb101-18"><a href="#cb101-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h7 : 2 * (2 * (p' * p')) = 2 * (q * q) := <span class="kw">by</span></span>
<span id="cb101-19"><a href="#cb101-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←pqsqrt2, p'halfp]</span>
<span id="cb101-20"><a href="#cb101-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">ring</span></span>
<span id="cb101-21"><a href="#cb101-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb101-22"><a href="#cb101-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h8 : 2 &gt; 0 := <span class="kw">by</span> <span class="kw">decide</span></span>
<span id="cb101-23"><a href="#cb101-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [mul_left_cancel_iff_of_pos h8] <span class="kw">at</span> h7</span>
<span id="cb101-24"><a href="#cb101-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">--h7 : 2 * (p' * p') = q * q</span></span>
<span id="cb101-25"><a href="#cb101-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h9 : nat_even (q * q) := Exists.intro (p' * p') h7.symm</span>
<span id="cb101-26"><a href="#cb101-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [sq_even_iff_even q] <span class="kw">at</span> h9   <span class="co">--h9 : nat_even q</span></span>
<span id="cb101-27"><a href="#cb101-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (q' : Nat) (q'halfq : q = 2 * q') <span class="kw">from</span> h9</span>
<span id="cb101-28"><a href="#cb101-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h10 : 2 * (p' * p') = 2 * (2 * (q' * q')) := <span class="kw">by</span></span>
<span id="cb101-29"><a href="#cb101-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h7, q'halfq]</span>
<span id="cb101-30"><a href="#cb101-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">ring</span></span>
<span id="cb101-31"><a href="#cb101-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb101-32"><a href="#cb101-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [mul_left_cancel_iff_of_pos h8] <span class="kw">at</span> h10</span>
<span id="cb101-33"><a href="#cb101-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">--h10 : p' * p' = 2 * (q' * q')</span></span>
<span id="cb101-34"><a href="#cb101-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> q'ne0 : q' ≠ 0 := <span class="kw">by</span></span>
<span id="cb101-35"><a href="#cb101-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">contradict</span> qne0 <span class="kw">with</span> h11</span>
<span id="cb101-36"><a href="#cb101-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [q'halfq, h11]</span>
<span id="cb101-37"><a href="#cb101-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb101-38"><a href="#cb101-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb101-39"><a href="#cb101-39" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> q'inS : q' ∈ S := Exists.intro p' (And.intro h10 q'ne0)</span>
<span id="cb101-40"><a href="#cb101-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> qleq' : q ≤ q' := qleast q' q'inS</span>
<span id="cb101-41"><a href="#cb101-41" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [q'halfq] <span class="kw">at</span> qleq'        <span class="co">--qleq' : 2 * q' ≤ q'</span></span>
<span id="cb101-42"><a href="#cb101-42" aria-hidden="true" tabindex="-1"></a>  <span class="kw">contradict</span> q'ne0</span>
<span id="cb101-43"><a href="#cb101-43" aria-hidden="true" tabindex="-1"></a>  <span class="kw">linarith</span></span>
<span id="cb101-44"><a href="#cb101-44" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="exercises-3" class="level3">
<h3 class="anchored" data-anchor-id="exercises-3">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb102"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint: Use Exercise_6_1_16a1 and Exercise_6_1_16a2.</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a><span class="co">--from the exercises of Section 6.1.</span></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> sq_even_iff_even (n : Nat) :</span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>    nat_even (n * n) ↔ nat_even n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb103"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="co">--This theorem proves that the square root of 6 is irrational</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_4_4a :</span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>    ¬∃ (q p : Nat), p * p = 6 * (q * q) ∧ q ≠ 0 := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb104"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_4_5 :</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>    ∀ n ≥ 12, ∃ (a b : Nat), 3 * a + 7 * b = n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb105"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_4_7a : ∀ (n : Nat),</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">Sum</span> i <span class="kw">from</span> 0 <span class="kw">to</span> n, Fib i) + 1 = Fib (n + 2) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb106"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_4_7c : ∀ (n : Nat),</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">Sum</span> i <span class="kw">from</span> 0 <span class="kw">to</span> n, Fib (2 * i + 1) = Fib (2 * n + 2) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="6">
<div class="sourceCode" id="cb107"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_4_8a : ∀ (m n : Nat),</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>    Fib (m + n + 1) = Fib m * Fib n + Fib (m + 1) * Fib (n + 1) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="7">
<div class="sourceCode" id="cb108"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_4_8d : ∀ (m k : Nat), Fib m ∣ Fib (m * k) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Hint for #7: Let <code>m</code> be an arbitrary natural number, and then use induction on <code>k</code>. For the induction step, you must prove <code>Fib m ∣ Fib (m * (k + 1))</code>. If <code>m = 0 ∨ k = 0</code>, then this is easy. If not, then use <code>exists_eq_add_one_of_ne_zero</code> to obtain a natural number <code>j</code> such that <code>m * k = j + 1</code>, and therefore <code>m * (k + 1) = j + m + 1</code>, and then apply <code>Exercise_6_4_8a</code>.</p>
</div>
<div class="numex" data-arguments="8">
<div class="sourceCode" id="cb109"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Fib_like (n : Nat) : Nat :=</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> n <span class="kw">with</span></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; 1</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a>    | 1 =&gt; 2</span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>    | k + 2 =&gt; 2 * (Fib_like k) + Fib_like (k + 1)</span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Fib_like_formula : ∀ (n : Nat), Fib_like n = 2 ^ n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="9">
<div class="sourceCode" id="cb110"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> triple_rec (n : Nat) : Nat :=</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> n <span class="kw">with</span></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; 0</span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>    | 1 =&gt; 2</span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a>    | 2 =&gt; 4</span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a>    | k + 3 =&gt; 4 * triple_rec k +</span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a>                6 * triple_rec (k + 1) + triple_rec (k + 2)</span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> triple_rec_formula :</span>
<span id="cb110-10"><a href="#cb110-10" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), triple_rec n = 2 ^ n * Fib n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>10. In this exercise you will prove that the numbers <code>q</code> and <code>r</code> in <code>Example_6_4_1</code> are unique. It is helpful to prove a lemma first.</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> quot_rem_unique_lemma {m q r q' r' : Nat}</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>    (h1 : m * q + r = m * q' + r') (h2 : r' &lt; m) : q ≤ q' := <span class="cn">sorry</span></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> quot_rem_unique (m q r q' r' : Nat)</span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a>    (h1 : m * q + r = m * q' + r') (h2 : r &lt; m) (h3 : r' &lt; m) :</span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a>    q = q' ∧ r = r' := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>11. Use the theorem in the previous exercise to prove the following characterization of <code>n / m</code> and <code>n % m</code>.</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> div_mod_char (m n q r : Nat)</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>    (h1 : n = m * q + r) (h2 : r &lt; m) : q = n / m ∧ r = n % m := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="closures-again" class="level2">
<h2 class="anchored" data-anchor-id="closures-again">6.5. Closures Again</h2>
<p>Section 6.5 of <em>HTPI</em> gives one more application of recursion and induction: another proof of the existence of closures of sets under functions. Recall from Section 5.4 that if <code>f : A → A</code> and <code>B : Set A</code>, then the <em>closure</em> of <code>B</code> under <code>f</code> is the smallest set containing <code>B</code> that is closed under <code>f</code>. In Section 5.4, we constructed the closure of <code>B</code> under <code>f</code> by taking the intersection of all sets containing <code>B</code> that are closed under <code>f</code>. In this section, we construct the closure by starting with the set <code>B</code> and repeatedly taking the image under <code>f</code>. For the motivation for this strategy, see <em>HTPI</em>; here we focus on how to carry out this strategy in Lean.</p>
<p>To talk about repeatedly taking the image of a set under a function, we will need a recursive definition:</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rep_image {A : <span class="kw">Type</span>} (f : A → A) (n : Nat) (B : Set A) : Set A :=</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> n <span class="kw">with</span></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; B</span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>    | k + 1 =&gt; image f (rep_image f k B)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>According to this definition, <code>rep_image f 0 B = B</code>, <code>rep_image f 1 B = image f B</code>, <code>rep_image f 2 B = image f (image f B)</code>, and so on. In other words, <code>rep_image f n B</code> is the result of starting with <code>B</code> and then taking the image under <code>f</code> <code>n</code> times. To make it easier to work with this definition, we state two simple theorems, both of which follow immediately from the definition.</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> rep_image_base {A : <span class="kw">Type</span>} (f : A → A) (B : Set A) :</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>    rep_image f 0 B = B := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> rep_image_step {A : <span class="kw">Type</span>} (f : A → A) (n : Nat) (B : Set A) :</span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a>    rep_image f (n + 1) B = image f (rep_image f n B) := <span class="kw">by</span> <span class="kw">rfl</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We will prove that the closure of <code>B</code> under <code>f</code> is the union of the sets <code>rep_image f n B</code>. We will call this the <em>cumulative image</em> of <code>B</code> under <code>f</code>, and we define it as follows:</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cumul_image {A : <span class="kw">Type</span>} (f : A → A) (B : Set A) : Set A :=</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>  {x : A | ∃ (n : Nat), x ∈ rep_image f n B}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To prove that <code>cumul_image f B</code> is the closure of <code>B</code> under <code>f</code>, we first prove a lemma saying that if <code>B ⊆ D</code> and <code>D</code> is closed under <code>f</code>, then for every natural number <code>n</code>, <code>rep_image f n B ⊆ D</code>. We prove it by induction.</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> rep_image_sub_closed {A : <span class="kw">Type</span>} {f : A → A} {B D : Set A}</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>    (h1 : B ⊆ D) (h2 : closed f D) :</span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), rep_image f n B ⊆ D := <span class="kw">by</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [rep_image_base]          <span class="co">--Goal : B ⊆ D</span></span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> B ⊆ D <span class="kw">from</span> h1</span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> n : Nat</span>
<span id="cb116-11"><a href="#cb116-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : rep_image f n B ⊆ D   <span class="co">--Goal : rep_image f (n + 1) B ⊆ D</span></span>
<span id="cb116-12"><a href="#cb116-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> x : A</span>
<span id="cb116-13"><a href="#cb116-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h3 : x ∈ rep_image f (n + 1) B  <span class="co">--Goal : x ∈ D</span></span>
<span id="cb116-14"><a href="#cb116-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [rep_image_step] <span class="kw">at</span> h3</span>
<span id="cb116-15"><a href="#cb116-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h3    <span class="co">--h3 : ∃ x_1 ∈ rep_image f n B, f x_1 = x</span></span>
<span id="cb116-16"><a href="#cb116-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (b : A) (h4 : b ∈ rep_image f n B ∧ f b = x) <span class="kw">from</span> h3</span>
<span id="cb116-17"><a href="#cb116-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←h4.right]   <span class="co">--Goal : f b ∈ D    </span></span>
<span id="cb116-18"><a href="#cb116-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h5 : b ∈ D := ih h4.left</span>
<span id="cb116-19"><a href="#cb116-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h2          <span class="co">--h2 : ∀ x ∈ D, f x ∈ D</span></span>
<span id="cb116-20"><a href="#cb116-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> f b ∈ D <span class="kw">from</span> h2 b h5</span>
<span id="cb116-21"><a href="#cb116-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb116-22"><a href="#cb116-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With this preparation, we can now prove that <code>cumul_image f B</code> is the closure of <code>B</code> under <code>f</code>.</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_6_5_1 {A : <span class="kw">Type</span>} (f : A → A) (B : Set A) :</span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>    closure f B (cumul_image f B) := <span class="kw">by</span></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro</span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that cumul_image f B ∈ {D : Set A | B ⊆ D ∧ closed f D}</span></span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>  <span class="co">--Goal : B ⊆ cumul_image f B ∧ closed f (cumul_image f B)</span></span>
<span id="cb117-7"><a href="#cb117-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro</span>
<span id="cb117-8"><a href="#cb117-8" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that B ⊆ cumul_image f B</span></span>
<span id="cb117-9"><a href="#cb117-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">fix</span> x : A</span>
<span id="cb117-10"><a href="#cb117-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">assume</span> h1 : x ∈ B</span>
<span id="cb117-11"><a href="#cb117-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span>     <span class="co">--Goal : ∃ (n : Nat), x ∈ rep_image f n B</span></span>
<span id="cb117-12"><a href="#cb117-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro 0</span>
<span id="cb117-13"><a href="#cb117-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [rep_image_base]  <span class="co">--Goal : x ∈ B</span></span>
<span id="cb117-14"><a href="#cb117-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> x ∈ B <span class="kw">from</span> h1</span>
<span id="cb117-15"><a href="#cb117-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb117-16"><a href="#cb117-16" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that cumul_image f B closed under f</span></span>
<span id="cb117-17"><a href="#cb117-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span></span>
<span id="cb117-18"><a href="#cb117-18" aria-hidden="true" tabindex="-1"></a>      <span class="kw">fix</span> x : A</span>
<span id="cb117-19"><a href="#cb117-19" aria-hidden="true" tabindex="-1"></a>      <span class="kw">assume</span> h1 : x ∈ cumul_image f B  <span class="co">--Goal : f x ∈ cumul_image f B</span></span>
<span id="cb117-20"><a href="#cb117-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb117-21"><a href="#cb117-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">obtain</span> (m : Nat) (h2 : x ∈ rep_image f m B) <span class="kw">from</span> h1</span>
<span id="cb117-22"><a href="#cb117-22" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span>     <span class="co">--Goal : ∃ (n : Nat), f x ∈ rep_image f n B</span></span>
<span id="cb117-23"><a href="#cb117-23" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro (m + 1) <span class="co">--Goal : f x ∈ rep_image f (m + 1) B</span></span>
<span id="cb117-24"><a href="#cb117-24" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [rep_image_step]   <span class="co">--Goal : f x ∈ image f (rep_image f m B)</span></span>
<span id="cb117-25"><a href="#cb117-25" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span>     <span class="co">--Goal : ∃ x_1 ∈ rep_image f m B, f x_1 = f x</span></span>
<span id="cb117-26"><a href="#cb117-26" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro x  <span class="co">--Goal : x ∈ rep_image f m B ∧ f x = f x</span></span>
<span id="cb117-27"><a href="#cb117-27" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> And.intro h2</span>
<span id="cb117-28"><a href="#cb117-28" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rfl</span></span>
<span id="cb117-29"><a href="#cb117-29" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb117-30"><a href="#cb117-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb117-31"><a href="#cb117-31" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that cumul_image f B is smallest</span></span>
<span id="cb117-32"><a href="#cb117-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> D : Set A</span>
<span id="cb117-33"><a href="#cb117-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : D ∈ {D : Set A | B ⊆ D ∧ closed f D}</span>
<span id="cb117-34"><a href="#cb117-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1  <span class="co">--h1 : B ⊆ D ∧ closed f D</span></span>
<span id="cb117-35"><a href="#cb117-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>   <span class="co">--Goal : ∀ ⦃a : A⦄, a ∈ cumul_image f B → a ∈ D</span></span>
<span id="cb117-36"><a href="#cb117-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> x : A</span>
<span id="cb117-37"><a href="#cb117-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : x ∈ cumul_image f B  <span class="co">--Goal : x ∈ D</span></span>
<span id="cb117-38"><a href="#cb117-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h2  <span class="co">--h2: ∃ (n : Nat), x ∈ rep_image f n B</span></span>
<span id="cb117-39"><a href="#cb117-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (m : Nat) (h3 : x ∈ rep_image f m B) <span class="kw">from</span> h2</span>
<span id="cb117-40"><a href="#cb117-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : rep_image f m B ⊆ D :=</span>
<span id="cb117-41"><a href="#cb117-41" aria-hidden="true" tabindex="-1"></a>      rep_image_sub_closed h1.left h1.right m</span>
<span id="cb117-42"><a href="#cb117-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> x ∈ D <span class="kw">from</span> h4 h3</span>
<span id="cb117-43"><a href="#cb117-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb117-44"><a href="#cb117-44" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="exercises-4" class="level3">
<h3 class="anchored" data-anchor-id="exercises-4">Exercises</h3>
<p>1. Recall the following definitions from the exercises of Section 5.4:</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> closed_family {A : <span class="kw">Type</span>} (F : Set (A → A)) (C : Set A) : <span class="kw">Prop</span> :=</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>  ∀ f ∈ F, closed f C</span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> closure_family {A : <span class="kw">Type</span>} (F : Set (A → A)) (B C : Set A) : <span class="kw">Prop</span> :=</span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>  smallestElt (sub A) C {D : Set A | B ⊆ D ∧ closed_family F D}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>These definitions say that a set is closed under a family of functions if it is closed under all of the functions in the family, and the closure of a set <code>B</code> under a family of functions is the smallest set containing <code>B</code> that is closed under the family.</p>
<p>In this exercise we will use the following additional definitions:</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rep_image_family {A : <span class="kw">Type</span>}</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>    (F : Set (A → A)) (n : Nat) (B : Set A) : Set A :=</span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> n <span class="kw">with</span></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; B</span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a>    | k + 1 =&gt; {x : A | ∃ f ∈ F, x ∈ image f (rep_image_family F k B)}</span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cumul_image_family {A : <span class="kw">Type</span>}</span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a>    (F : Set (A → A)) (B : Set A) : Set A :=</span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a>  {x : A | ∃ (n : Nat), x ∈ rep_image_family F n B}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The following theorems establish that if <code>F : Set (A → A)</code> and <code>B : Set A</code>, then <code>cumul_image_family F B</code> is the closure of <code>B</code> under <code>F</code>. The first two are proven by <code>rfl</code>; the other two are for you to prove.</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> rep_image_family_base {A : <span class="kw">Type</span>}</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>    (F : Set (A → A)) (B : Set A) : rep_image_family F 0 B = B := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> rep_image_family_step {A : <span class="kw">Type</span>}</span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a>    (F : Set (A → A)) (n : Nat) (B : Set A) :</span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a>    rep_image_family F (n + 1) B =</span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a>    {x : A | ∃ f ∈ F, x ∈ image f (rep_image_family F n B)} := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> rep_image_family_sub_closed {A : <span class="kw">Type</span>}</span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a>    (F : Set (A → A)) (B D : Set A)</span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true" tabindex="-1"></a>    (h1 : B ⊆ D) (h2 : closed_family F D) :</span>
<span id="cb120-12"><a href="#cb120-12" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), rep_image_family F n B ⊆ D := <span class="cn">sorry</span></span>
<span id="cb120-13"><a href="#cb120-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-14"><a href="#cb120-14" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_5_3 {A : <span class="kw">Type</span>} (F : Set (A → A)) (B : Set A) :</span>
<span id="cb120-15"><a href="#cb120-15" aria-hidden="true" tabindex="-1"></a>    closure_family F B (cumul_image_family F B) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="mdsk">

</div>
<p>The next two exercises concern the following two definitions from Section 5.4:</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> closed2 {A : <span class="kw">Type</span>} (f : A → A → A) (C : Set A) : <span class="kw">Prop</span> :=</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>  ∀ x ∈ C, ∀ y ∈ C, f x y ∈ C</span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> closure2 {A : <span class="kw">Type</span>} (f : A → A → A) (B C : Set A) : <span class="kw">Prop</span> := </span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a>  smallestElt (sub A) C {D : Set A | B ⊆ D ∧ closed2 f D}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>They also use the following definition, which extends the idea of the image of a set under a function to functions of two variables:</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> image2 {A : <span class="kw">Type</span>} (f : A → A → A) (B : Set A) : Set A :=</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>  {z : A | ∃ (x y : A), x ∈ B ∧ y ∈ B ∧ z = f x y}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>2. A natural way to try to find the closure of a set under a function of two variables would be to use the following definitions and theorems:</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rep_image2 {A : <span class="kw">Type</span>}</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>    (f : A → A → A) (n : Nat) (B : Set A) : Set A :=</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> n <span class="kw">with</span></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; B</span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>    | k + 1 =&gt; image2 f (rep_image2 f k B)</span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> rep_image2_base {A : <span class="kw">Type</span>} (f : A → A → A) (B : Set A) :</span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true" tabindex="-1"></a>    rep_image2 f 0 B = B := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb123-9"><a href="#cb123-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-10"><a href="#cb123-10" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> rep_image2_step {A : <span class="kw">Type</span>}</span>
<span id="cb123-11"><a href="#cb123-11" aria-hidden="true" tabindex="-1"></a>    (f : A → A → A) (n : Nat) (B : Set A) :</span>
<span id="cb123-12"><a href="#cb123-12" aria-hidden="true" tabindex="-1"></a>    rep_image2 f (n + 1) B = image2 f (rep_image2 f n B) := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb123-13"><a href="#cb123-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-14"><a href="#cb123-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cumul_image2 {A : <span class="kw">Type</span>} (f : A → A → A) (B : Set A) : Set A :=</span>
<span id="cb123-15"><a href="#cb123-15" aria-hidden="true" tabindex="-1"></a>  {x : A | ∃ (n : Nat), x ∈ rep_image2 f n B}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We could now try to prove that if <code>f : A → A → A</code> and <code>B : Set A</code>, then <code>cumul_image2 f B</code> is the closure of <code>B</code> under <code>f</code>. However, this approach doesn’t work, because <code>cumul_image2 f B</code> might not be closed under <code>f</code>.</p>
<p>Here is an incorrect informal argument that <code>cumul_image2 f B</code> is closed under <code>f</code>. Suppose <code>x</code> and <code>y</code> are elements of <code>cumul_image2 f B</code>. This means that we can choose some natural number <code>n</code> such that <code>x ∈ rep_image2 f n B</code> and <code>y ∈ rep_image2 f n B</code>. This implies that <code>f x y ∈ image2 f (rep_image2 f n B) = rep_image2 f (n + 1) B</code>, so <code>f x y ∈ cumul_image2 f B</code>.</p>
<p>Find the mistake in this informal argument by trying to turn it into a proof in Lean:</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="co">--You won't be able to complete this proof</span></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_5_6 {A : <span class="kw">Type</span>} (f : A → A → A) (B : Set A) :</span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a>    closed2 f (cumul_image2 f B) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>3. In this exercise, we fix the mistake in the attempted proof in the previous exercise. Instead of repeatedly taking the image of a set, we repeatedly take the union of a set with its image:</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> un_image2 {A : <span class="kw">Type</span>} (f : A → A → A) (B : Set A) : Set A :=</span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>  B ∪ (image2 f B)</span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rep_un_image2 {A : <span class="kw">Type</span>}</span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a>    (f : A → A → A) (n : Nat) (B : Set A) : Set A :=</span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> n <span class="kw">with</span></span>
<span id="cb125-7"><a href="#cb125-7" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; B</span>
<span id="cb125-8"><a href="#cb125-8" aria-hidden="true" tabindex="-1"></a>    | k + 1 =&gt; un_image2 f (rep_un_image2 f k B)</span>
<span id="cb125-9"><a href="#cb125-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-10"><a href="#cb125-10" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> rep_un_image2_base {A : <span class="kw">Type</span>} (f : A → A → A) (B : Set A) :</span>
<span id="cb125-11"><a href="#cb125-11" aria-hidden="true" tabindex="-1"></a>    rep_un_image2 f 0 B = B := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb125-12"><a href="#cb125-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-13"><a href="#cb125-13" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> rep_un_image2_step {A : <span class="kw">Type</span>}</span>
<span id="cb125-14"><a href="#cb125-14" aria-hidden="true" tabindex="-1"></a>    (f : A → A → A) (n : Nat) (B : Set A) :</span>
<span id="cb125-15"><a href="#cb125-15" aria-hidden="true" tabindex="-1"></a>    rep_un_image2 f (n + 1) B =</span>
<span id="cb125-16"><a href="#cb125-16" aria-hidden="true" tabindex="-1"></a>    un_image2 f (rep_un_image2 f n B) := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb125-17"><a href="#cb125-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-18"><a href="#cb125-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cumul_un_image2 {A : <span class="kw">Type</span>}</span>
<span id="cb125-19"><a href="#cb125-19" aria-hidden="true" tabindex="-1"></a>    (f : A → A → A) (B : Set A) : Set A :=</span>
<span id="cb125-20"><a href="#cb125-20" aria-hidden="true" tabindex="-1"></a>  {x : A | ∃ (n : Nat), x ∈ rep_un_image2 f n B}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now prove that if <code>f : A → A → A</code> and <code>B : Set A</code>, then <code>cumul_un_image2 f B</code> is the closure of <code>B</code> under <code>f</code> by completing the following proofs:</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_5_8a {A : <span class="kw">Type</span>} (f : A → A → A) (B : Set A) :</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>    ∀ (m n : Nat), m ≤ n →</span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>    rep_un_image2 f m B ⊆ rep_un_image2 f n B := <span class="cn">sorry</span></span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> rep_un_image2_sub_closed {A : <span class="kw">Type</span>} {f : A → A → A} {B D : Set A}</span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a>    (h1 : B ⊆ D) (h2 : closed2 f D) :</span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), rep_un_image2 f n B ⊆ D := <span class="cn">sorry</span></span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-9"><a href="#cb126-9" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> closed_lemma</span>
<span id="cb126-10"><a href="#cb126-10" aria-hidden="true" tabindex="-1"></a>    {A : <span class="kw">Type</span>} {f : A → A → A} {B : Set A} {x y : A} {nx ny n : Nat}</span>
<span id="cb126-11"><a href="#cb126-11" aria-hidden="true" tabindex="-1"></a>    (h1 : x ∈ rep_un_image2 f nx B) (h2 : y ∈ rep_un_image2 f ny B)</span>
<span id="cb126-12"><a href="#cb126-12" aria-hidden="true" tabindex="-1"></a>    (h3 : nx ≤ n) (h4 : ny ≤ n) :</span>
<span id="cb126-13"><a href="#cb126-13" aria-hidden="true" tabindex="-1"></a>    f x y ∈ cumul_un_image2 f B := <span class="cn">sorry</span></span>
<span id="cb126-14"><a href="#cb126-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-15"><a href="#cb126-15" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_5_8b {A : <span class="kw">Type</span>} (f : A → A → A) (B : Set A) :</span>
<span id="cb126-16"><a href="#cb126-16" aria-hidden="true" tabindex="-1"></a>    closure2 f B (cumul_un_image2 f B) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="mdsk">

</div>
<p>The remaining exercises in this section use the following definitions:</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> idExt (A : <span class="kw">Type</span>) : Set (A × A) := {(x, y) : A × A | x = y}</span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rep_comp {A : <span class="kw">Type</span>} (R : Set (A × A)) (n : Nat) : Set (A × A) :=</span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> n <span class="kw">with</span></span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; idExt A</span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a>    | k + 1 =&gt; comp (rep_comp R k) R</span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cumul_comp {A : <span class="kw">Type</span>} (R : Set (A × A)) : Set (A × A) :=</span>
<span id="cb127-9"><a href="#cb127-9" aria-hidden="true" tabindex="-1"></a>  {(x, y) : A × A | ∃ n ≥ 1, (x, y) ∈ rep_comp R n}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb128"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> rep_comp_one {A : <span class="kw">Type</span>} (R : Set (A × A)) :</span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>    rep_comp R 1 = R := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb129"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_5_11 {A : <span class="kw">Type</span>} (R : Set (A × A)) :</span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>    ∀ (m n : Nat), rep_comp R (m + n) =</span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>    comp (rep_comp R m) (rep_comp R n) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="6">
<div class="sourceCode" id="cb130"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> rep_comp_sub_trans {A : <span class="kw">Type</span>} {R S : Set (A × A)}</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>    (h1 : R ⊆ S) (h2 : transitive (RelFromExt S)) :</span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a>    ∀ n ≥ 1, rep_comp R n ⊆ S := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="7">
<div class="sourceCode" id="cb131"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_5_14 {A : <span class="kw">Type</span>} (R : Set (A × A)) :</span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>    smallestElt (sub (A × A)) (cumul_comp R)</span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>    {S : Set (A × A) | R ⊆ S ∧ transitive (RelFromExt S)} := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Chap5.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Functions</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./Chap7.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Number Theory</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
      <div class="nav-footer-center">© 2023-2025 Daniel J. Velleman.<br>Short excerpts from Daniel J. Velleman, <a href="https://doi.org/10.1017/9781108539890"><i>How To Prove It: A Structured Approach, 3rd Edition</i></a><br>© Daniel J. Velleman 2019, published by Cambridge University Press, reprinted with permission.</div>
  </div>
</footer>



</body></html>