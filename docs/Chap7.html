<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.189">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>How To Prove It with Lean - 7&nbsp; Number Theory</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Chap8.html" rel="next">
<link href="./Chap6.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="HTPIwLstyles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Number Theory</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">How To Prove It with Lean</a> 
        <div class="sidebar-tools-main">
    <a href="./How-To-Prove-It-with-Lean.pdf" title="Download PDF" class="sidebar-tool px-1"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Preface</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap1.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Sentential Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap2.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Quantificational Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./IntroLean.html" class="sidebar-item-text sidebar-link">Introduction to Lean</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap3.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Proofs</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap4.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Relations</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap5.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Functions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap6.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Mathematical Induction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap7.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Number Theory</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap8.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Infinite Sets</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Appendix.html" class="sidebar-item-text sidebar-link">Appendix</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">In This Chapter</h2>
   
  <ul class="collapse">
  <li><a href="#greatest-common-divisors" id="toc-greatest-common-divisors" class="nav-link active" data-scroll-target="#greatest-common-divisors">7.1. Greatest Common Divisors</a></li>
  <li><a href="#prime-factorization" id="toc-prime-factorization" class="nav-link" data-scroll-target="#prime-factorization">7.2. Prime Factorization</a></li>
  <li><a href="#modular-arithmetic" id="toc-modular-arithmetic" class="nav-link" data-scroll-target="#modular-arithmetic">7.3. Modular Arithmetic</a></li>
  <li><a href="#eulers-theorem" id="toc-eulers-theorem" class="nav-link" data-scroll-target="#eulers-theorem">7.4. Euler’s Theorem</a></li>
  <li><a href="#public-key-cryptography" id="toc-public-key-cryptography" class="nav-link" data-scroll-target="#public-key-cryptography">7.5. Public-Key Cryptography</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<div class="hidden">
$$
\newcommand{\setmin}{\mathbin{\backslash}}
\newcommand{\symmdiff}{\mathbin{∆}}
$$
</div>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Number Theory</span></h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<section id="greatest-common-divisors" class="level2">
<h2 class="anchored" data-anchor-id="greatest-common-divisors">7.1. Greatest Common Divisors</h2>
<p>The proofs in this chapter and the next are significantly longer than those in previous chapters. As a result, we will skip some details in the text, leaving proofs of a number of theorems as exercises for you. The most interesting of these exercises are included in the exercise lists at the ends of the sections; for the rest, you can compare your solutions to proofs that can be found in the Lean package that accompanies this book. Also, we will occasionally use theorems that we have not used before without explanation. If necessary, you can use <code>#check</code> to look up what they say.</p>
<p>Section 7.1 of <em>HTPI</em> introduces the Euclidean algorithm for computing the greatest common divisor (gcd) of two positive integers <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>. The motivation for the algorithm is the fact that if <span class="math inline">\(r\)</span> is the remainder when <span class="math inline">\(a\)</span> is divided by <span class="math inline">\(b\)</span>, then any natural number that divides both <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> also divides <span class="math inline">\(r\)</span>, and any natural number that divides both <span class="math inline">\(b\)</span> and <span class="math inline">\(r\)</span> also divides <span class="math inline">\(a\)</span>.</p>
<p>Let’s prove these statements in Lean. Recall that in Lean, the remainder when <code>a</code> is divided by <code>b</code> is called <code>a</code> mod <code>b</code>, and it is denoted <code>a % b</code>. We’ll prove the first statement, and leave the second as an exercise for you. It will be convenient for our work with greatest common divisors in Lean to let <code>a</code> and <code>b</code> be natural numbers rather than positive integers (thus allowing either of them to be zero).</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> dvd_mod_of_dvd_a_b {a b d : Nat}</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    (h1 : d ∣ a) (h2 : d ∣ b) : d ∣ (a % b) := <span class="kw">by</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> q : Nat := a / b</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : b * q + a % b = a := Nat.div_add_mod a b</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (j : Nat) (h4 : a = d * j) <span class="kw">from</span> h1</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (k : Nat) (h5 : b = d * k) <span class="kw">from</span> h2</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>    <span class="co">--Goal : ∃ (c : Nat), a % b = d * c</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (j - k * q)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a % b = d * (j - k * q) <span class="kw">from</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> a % b</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>      _ = b * q + a % b - b * q := (Nat.add_sub_cancel_left _ _).symm</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>      _ = a - b * q := <span class="kw">by</span> <span class="kw">rw</span> [h3]</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>      _ = d * j - d * (k * q) := <span class="kw">by</span> <span class="kw">rw</span> [h4, h5, mul_assoc]</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>      _ = d * (j - k * q) := (Nat.mul_sub_left_distrib _ _ _).symm</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> dvd_a_of_dvd_b_mod {a b d : Nat}</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    (h1 : d ∣ b) (h2 : d ∣ (a % b)) : d ∣ a := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>These theorems tell us that the gcd of <code>a</code> and <code>b</code> is the same as the gcd of <code>b</code> and <code>a % b</code>, which suggests that the following recursive definition should compute the gcd of <code>a</code> and <code>b</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="sc">**</span><span class="er">gcd</span><span class="sc">::</span> (a b : Nat) : Nat :=</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> b <span class="kw">with</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; a</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    | n + 1 =&gt; gcd (n + 1) (a % (n + 1))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Unfortunately, Lean puts a red squiggle under <code>gcd</code>, and it displays in the Infoview a long error message that begins <code>fail to show termination</code>. What is Lean complaining about?</p>
<p>The problem is that recursive definitions are dangerous. To understand the danger, consider the following recursive definition:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> loop (n : Nat) : Nat := loop (n + 1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Suppose we try to use this definition to compute <code>loop 3</code>. The definition would lead us to perform the following calculation:</p>
<div class="ind">
<pre><code>loop 3 = loop 4 = loop 5 = loop 6 = ...</code></pre>
</div>
<p>Clearly this calculation will go on forever and will never produce an answer. So the definition of <code>loop</code> does not actually succeed in defining a function from <code>Nat</code> to <code>Nat</code>.</p>
<p>Lean insists that recursive definitions must avoid such nonterminating calculations. Why did it accept all of our previous recursive definitions? The reason is that in each case, the definition of the value of the function at a natural number <code>n</code> referred only to values of the function at numbers smaller than <code>n</code>. Since a decreasing list of natural numbers cannot go on forever, such definitions lead to calculations that are guaranteed to terminate.</p>
<p>What about our recursive definition of <code>gcd a b</code>? This function has two arguments, <code>a</code> and <code>b</code>, and when <code>b = n + 1</code>, the definition asks us to compute <code>gcd (n + 1) (a % (n + 1))</code>. The first argument here could actually be larger than the first argument in the value we are trying to compute, <code>gcd a b</code>. But the second argument will always be smaller, and that will suffice to guarantee that the calculation terminates. We can tell Lean to focus on the second argument <code>b</code> by adding a <code>termination_by</code> clause to the end of our recursive definition:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gcd (a b : Nat) : Nat :=</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> b <span class="kw">with</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; a</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    | n + 1 =&gt; <span class="sc">**</span><span class="er">gcd (n + 1) (a % (n + 1))</span><span class="sc">::</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">termination_by</span> b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Unfortunately, Lean still isn’t satisfied, but the error message this time is more helpful. The message says that Lean failed to prove termination, and at the end of the message it says that the goal it failed to prove is <code>a % (n + 1) &lt; n + 1</code>, which is precisely what is needed to show that the second argument of <code>gcd (n + 1) (a % (n + 1))</code> is smaller than the second argument of <code>gcd a b</code> when <code>b = n + 1</code>. We’ll need to provide a proof of this goal to convince Lean to accept our recursive definition. Fortunately, it’s not hard to prove:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> mod_succ_lt (a n : Nat) : a % (n + 1) &lt; n + 1 := <span class="kw">by</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h : n + 1 &gt; 0 := Nat.succ_pos n</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a % (n + 1) &lt; n + 1 <span class="kw">from</span> Nat.mod_lt a h</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Lean’s error message suggests several ways to fix the problem with our recursive definition. We’ll use the first suggestion: <code>Use `have`-expressions to prove the remaining goals</code>. Here, finally, is the definition of <code>gcd</code> that Lean is willing to accept. (You can ignore the initial line <code>@[semireducible]</code>. For technical reasons that we won’t go into, this line is needed to make this complicated recursive definition work in proofs the same way that our previous, simpler recursive definitions did.)</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">@[semireducible]</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gcd (a b : Nat) : Nat :=</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> b <span class="kw">with</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; a</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    | n + 1 =&gt;</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> : a % (n + 1) &lt; n + 1 := mod_succ_lt a n</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>      gcd (n + 1) (a % (n + 1))</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">termination_by</span> b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Notice that in the <code>have</code> expression, we have not bothered to specify an identifier for the assertion being proven, since we never need to refer to it. Let’s try out our <code>gcd</code> function:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="sc">++</span><span class="do">#eval</span><span class="sc">::</span> gcd 672 161    <span class="co">--Answer: 7.  Note 672 = 7 * 96 and 161 = 7 * 23.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To establish the main properties of <code>gcd a b</code> we’ll need several lemmas. We prove some of them and leave others as exercises.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> gcd_base (a : Nat) : gcd a 0 = a := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> gcd_nonzero (a : Nat) {b : Nat} (h : b ≠ 0) :</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    gcd a b = gcd b (a % b) := <span class="kw">by</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (n : Nat) (h2 : b = n + 1) <span class="kw">from</span> exists_eq_add_one_of_ne_zero h</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h2]   <span class="co">--Goal : gcd a (n + 1) = gcd (n + 1) (a % (n + 1))</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rfl</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> mod_nonzero_lt (a : Nat) {b : Nat} (h : b ≠ 0) : a % b &lt; b := <span class="cn">sorry</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> dvd_self (n : Nat) : n ∣ n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>One of the most important properties of <code>gcd a b</code> is that it divides both <code>a</code> and <code>b</code>. We prove it by strong induction on <code>b</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> gcd_dvd : ∀ (b a : Nat), (gcd a b) ∣ a ∧ (gcd a b) ∣ b := <span class="kw">by</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_strong_induc</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> b : Nat</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> ih : ∀ b_1 &lt; b, ∀ (a : Nat), (gcd a b_1) ∣ a ∧ (gcd a b_1) ∣ b_1</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : Nat</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> h1 : b = 0</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h1 : b = 0</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h1, gcd_base]   <span class="co">--Goal: a ∣ a ∧ a ∣ 0</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro (dvd_self a)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro 0</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h1 : b ≠ 0</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [gcd_nonzero a h1]</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>      <span class="co">--Goal : gcd b (a % b) ∣ a ∧ gcd b (a % b) ∣ b</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : a % b &lt; b := mod_nonzero_lt a h1</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : (gcd b (a % b)) ∣ b ∧ (gcd b (a % b)) ∣ (a % b) :=</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>      ih (a % b) h2 b</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro _ h3.left</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> (gcd b (a % b)) ∣ a <span class="kw">from</span> dvd_a_of_dvd_b_mod h3.left h3.right</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You may wonder why we didn’t start the proof like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> gcd_dvd : ∀ (a b : Nat), (gcd a b) ∣ a ∧ (gcd a b) ∣ b := <span class="kw">by</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : Nat</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_strong_induc</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> b : Nat</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> ih : ∀ b_1 &lt; b, (gcd a b_1) ∣ a ∧ (gcd a b_1) ∣ b_1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In fact, this approach wouldn’t have worked. It is an interesting exercise to try to complete this version of the proof and see why it fails.</p>
<p>Another interesting question is why we asserted both <code>(gcd a b) ∣ a</code> and <code>(gcd a b) ∣ b</code> in the same theorem. Wouldn’t it have been easier to give separate proofs of the statements <code>∀ (b a : Nat), (gcd a b) ∣ a</code> and <code>∀ (b a : Nat), (gcd a b) ∣ b</code>? Again, you might find it enlightening to see why that wouldn’t have worked. However, now that we have proven both divisibility statements, we can state them as separate theorems:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> gcd_dvd_left (a b : Nat) : (gcd a b) ∣ a := (gcd_dvd b a).left</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> gcd_dvd_right (a b : Nat) : (gcd a b) ∣ b := (gcd_dvd b a).right</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Next we turn to Theorem 7.1.4 in <em>HTPI</em>, which says that there are integers <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span> such that <span class="math inline">\(\text{gcd}(a, b) = s a + t b\)</span>. (We say that <span class="math inline">\(\text{gcd}(a, b)\)</span> can be written as a <em>linear combination</em> of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>.) In <em>HTPI</em>, this is proven by using an extended version of the Euclidean algorithm to compute the coefficients <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span>. Here we will use a different recursive procedure to compute <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span>. If <span class="math inline">\(b = 0\)</span>, then <span class="math inline">\(\text{gcd}(a, b) = a = 1 \cdot a + 0 \cdot b\)</span>, so we can use the values <span class="math inline">\(s = 1\)</span> and <span class="math inline">\(t = 0\)</span>. Otherwise, let <span class="math inline">\(q\)</span> and <span class="math inline">\(r\)</span> be the quotient and remainder when <span class="math inline">\(a\)</span> is divided by <span class="math inline">\(b\)</span>. Then <span class="math inline">\(a = bq + r\)</span> and <span class="math inline">\(\text{gcd}(a, b) = \text{gcd}(b, r)\)</span>. Now suppose that we have already computed integers <span class="math inline">\(s'\)</span> and <span class="math inline">\(t'\)</span> such that <span class="math display">\[
\text{gcd}(b, r) = s' b + t' r.
\]</span> Then <span class="math display">\[\begin{align*}
\text{gcd}(a, b) &amp;= \text{gcd}(b, r) = s' b + t' r\\
&amp;= s' b + t' (a - bq) = t' a + (s' - t'q)b.
\end{align*}\]</span> Thus, to write <span class="math inline">\(\text{gcd}(a, b) = s a + t b\)</span> we can use the values <span class="math display">\[\begin{equation}\tag{$*$}
s = t', \qquad t = s' - t'q.
\end{equation}\]</span></p>
<p>We will use these equations as the basis for recursive definitions of Lean functions <code>gcd_c1</code> and <code>gcd_c2</code> such that the required coefficients can be obtained from the formulas <code>s = gcd_c1 a b</code> and <code>t = gcd_c2 a b</code>. Notice that <code>s</code> and <code>t</code> could be negative, so they must have type <code>Int</code>, not <code>Nat</code>. As a result, in definitions and theorems involving <code>gcd_c1</code> and <code>gcd_c2</code> we will sometimes have to deal with coercion of natural numbers to integers.</p>
<p>The functions <code>gcd_c1</code> and <code>gcd_c2</code> will be <em>mutually recursive</em>; in other words, each will be defined not only in terms of itself but also in terms of the other. Fortunately, Lean allows for such mutual recursion. Here are the definitions we will use.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">mutual</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">@[semireducible]</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> gcd_c1 (a b : Nat) : Int :=</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> b <span class="kw">with</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>      | 0 =&gt; 1</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>      | n + 1 =&gt;</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">have</span> : a % (n + 1) &lt; n + 1 := mod_succ_lt a n</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        gcd_c2 (n + 1) (a % (n + 1))</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>          <span class="co">--Corresponds to s = t'</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">termination_by</span> b</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">@[semireducible]</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> gcd_c2 (a b : Nat) : Int :=</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> b <span class="kw">with</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>      | 0 =&gt; 0</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>      | n + 1 =&gt;</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">have</span> : a % (n + 1) &lt; n + 1 := mod_succ_lt a n</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>        gcd_c1 (n + 1) (a % (n + 1)) -</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>          (gcd_c2 (n + 1) (a % (n + 1))) * ↑(a / (n + 1))</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>          <span class="co">--Corresponds to t = s' - t'q</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">termination_by</span> b</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Notice that in the definition of <code>gcd_c2</code>, the quotient <code>a / (n + 1)</code> is computed using natural-number division, but it is then coerced to be an integer so that it can be multiplied by the integer <code>gcd_c2 (n + 1) (a % (n + 1))</code>.</p>
<p>Our main theorem about these functions is that they give the coefficients needed to write <code>gcd a b</code> as a linear combination of <code>a</code> and <code>b</code>. As usual, stating a few lemmas first helps with the proof. We leave the proofs of two of them as exercises for you (hint: imitate the proof of <code>gcd_nonzero</code> above).</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> gcd_c1_base (a : Nat) : gcd_c1 a 0 = 1 := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> gcd_c1_nonzero (a : Nat) {b : Nat} (h : b ≠ 0) :</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    gcd_c1 a b = gcd_c2 b (a % b) := <span class="cn">sorry</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> gcd_c2_base (a : Nat) : gcd_c2 a 0 = 0 := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> gcd_c2_nonzero (a : Nat) {b : Nat} (h : b ≠ 0) :</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    gcd_c2 a b = gcd_c1 b (a % b) - (gcd_c2 b (a % b)) * ↑(a / b) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With that preparation, we are ready to prove that <code>gcd_c1 a b</code> and <code>gcd_c2 a b</code> give coefficients for expressing <code>gcd a b</code> as a linear combination of <code>a</code> and <code>b</code>. Of course, the theorem is proven by strong induction. For clarity, we’ll write the coercions explicitly in this proof. We’ll make a few comments after the proof that may help you follow the details.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> gcd_lin_comb : ∀ (b a : Nat),</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    (gcd_c1 a b) * ↑a + (gcd_c2 a b) * ↑b = ↑(gcd a b) := <span class="kw">by</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_strong_induc</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> b : Nat</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> ih : ∀ b_1 &lt; b, ∀ (a : Nat),</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    (gcd_c1 a b_1) * ↑a + (gcd_c2 a b_1) * ↑b_1 = ↑(gcd a b_1)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : Nat</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> h1 : b = 0</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h1 : b = 0</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h1, gcd_c1_base, gcd_c2_base, gcd_base]</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>      <span class="co">--Goal : 1 * ↑a + 0 * ↑0 = ↑a</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">ring</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h1 : b ≠ 0</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [gcd_c1_nonzero a h1, gcd_c2_nonzero a h1, gcd_nonzero a h1]</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>      <span class="co">--Goal : gcd_c2 b (a % b) * ↑a +</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- (gcd_c1 b (a % b) - gcd_c2 b (a % b) * ↑(a / b)) * ↑b =</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- ↑(gcd b (a % b))</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">set</span> r : Nat := a % b</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">set</span> q : Nat := a / b</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">set</span> s : Int := gcd_c1 b r</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">set</span> t : Int := gcd_c2 b r</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>      <span class="co">--Goal : t * ↑a + (s - t * ↑q) * ↑b = ↑(gcd b r)</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : r &lt; b := mod_nonzero_lt a h1</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : s * ↑b + t * ↑r = ↑(gcd b r) := ih r h2 b</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : b * q + r = a := Nat.div_add_mod a b</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←h3, ←h4]</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [Nat.cast_add, Nat.cast_mul]</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>      <span class="co">--Goal : t * (↑b * ↑q + ↑r) + (s - t * ↑q) * ↑b = s * ↑b + t * ↑r</span></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">ring</span></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In case 2, we have introduced the variables <code>r</code>, <code>q</code>, <code>s</code>, and <code>t</code> to simplify the notation. Notice that the <code>set</code> tactic automatically plugs in this notation in the goal. After the step <code>rewrite [←h3, ←h4]</code>, the goal contains the expression <code>↑(b * q + r)</code>. You can use the <code>#check</code> command to see why <code>Nat.cast_add</code> and <code>Nat.cast_mul</code> convert this expression to first <code>↑(b * q) + ↑r</code> and then <code>↑b * ↑q + ↑r</code>. Without those steps, the <code>ring</code> tactic would not have been able to complete the proof.</p>
<p>We can try out the functions <code>gcd_c1</code> and <code>gcd_c2</code> as follows:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="sc">++</span><span class="do">#eval</span><span class="sc">::</span> gcd_c1 672 161  <span class="co">--Answer: 6</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="sc">++</span><span class="do">#eval</span><span class="sc">::</span> gcd_c2 672 161  <span class="co">--Answer: -25</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">--Note 6 * 672 - 25 * 161 = 4032 - 4025 = 7 = gcd 672 161</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, we turn to Theorem 7.1.6 in <em>HTPI</em>, which expresses one of the senses in which <code>gcd a b</code> is the <em>greatest</em> common divisor of <code>a</code> and <code>b</code>. Our proof follows the strategy of the proof in <em>HTPI</em>, with one additional step: we begin by using the theorem <code>Int.natCast_dvd_natCast</code> to change the goal from <code>d ∣ gcd a b</code> to <code>↑d ∣ ↑(gcd a b)</code> (where the coercions are from <code>Nat</code> to <code>Int</code>), so that the rest of the proof can work with integer algebra rather than natural-number algebra.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_1_6 {d a b : Nat} (h1 : d ∣ a) (h2 : d ∣ b) :</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    d ∣ gcd a b := <span class="kw">by</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←Int.natCast_dvd_natCast]    <span class="co">--Goal : ↑d ∣ ↑(gcd a b)</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> s : Int := gcd_c1 a b</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> t : Int := gcd_c2 a b</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : s * ↑a + t * ↑b = ↑(gcd a b) := gcd_lin_comb b a</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←h3]                 <span class="co">--Goal : ↑d ∣ s * ↑a + t * ↑b</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (j : Nat) (h4 : a = d * j) <span class="kw">from</span> h1</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (k : Nat) (h5 : b = d * k) <span class="kw">from</span> h2</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h4, h5, Nat.cast_mul, Nat.cast_mul]</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">--Goal : ↑d ∣ s * (↑d * ↑j) + t * (↑d * ↑k)</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (s * ↑j + t * ↑k)</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">ring</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We will ask you in the exercises to prove that, among the common divisors of <code>a</code> and <code>b</code>, <code>gcd a b</code> is the greatest with respect to the usual ordering of the natural numbers (as long as <code>gcd a b ≠ 0</code>).</p>
<section id="exercises" class="level3">
<h3 class="anchored" data-anchor-id="exercises">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb18"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> dvd_a_of_dvd_b_mod {a b d : Nat}</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    (h1 : d ∣ b) (h2 : d ∣ (a % b)) : d ∣ a := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb19"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> gcd_comm_lt {a b : Nat} (h : a &lt; b) : gcd a b = gcd b a := <span class="cn">sorry</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> gcd_comm (a b : Nat) : gcd a b = gcd b a := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb20"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_7_1_5 (a b : Nat) (n : Int) :</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    (∃ (s t : Int), s * a + t * b = n) ↔ (↑(gcd a b) : Int) ∣ n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb21"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_7_1_6 (a b c : Nat) :</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    gcd a b = gcd (a + b * c) b := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb22"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> gcd_is_nonzero {a b : Nat} (h : a ≠ 0 ∨ b ≠ 0) :</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    gcd a b ≠ 0 := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="6">
<div class="sourceCode" id="cb23"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> gcd_greatest {a b d : Nat} (h1 : gcd a b ≠ 0)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    (h2 : d ∣ a) (h3 : d ∣ b) : d ≤ gcd a b := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="7">
<div class="sourceCode" id="cb24"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_7_1_10a {a b : Nat}</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    (n : Nat) (h : a ∣ b) : (n * a) ∣ (n * b) := <span class="cn">sorry</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_7_1_10b {a b n : Nat}</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    (h1 : n ≠ 0) (h2 : (n * a) ∣ (n * b)) : a ∣ b := <span class="cn">sorry</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_7_1_10c {a b : Nat}</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    (h1 : a ∣ b) (h2 : b ∣ a) : a = b := <span class="cn">sorry</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_7_1_10 (a b n : Nat) :</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    gcd (n * a) (n * b) = n * gcd a b := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="prime-factorization" class="level2">
<h2 class="anchored" data-anchor-id="prime-factorization">7.2. Prime Factorization</h2>
<p>A natural number <span class="math inline">\(n\)</span> is said to be <em>prime</em> if it is at least 2 and it cannot be written as a product of two smaller natural numbers. Of course, we can write this definition in Lean.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prime (n : Nat) : <span class="kw">Prop</span> :=</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  2 ≤ n ∧ ¬∃ (a b : Nat), a * b = n ∧ a &lt; n ∧ b &lt; n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The main goal of Section 7.2 of <em>HTPI</em> is to prove that every positive integer has a unique prime factorization; that is, it can be written in a unique way as the product of a nondecreasing list of prime numbers. To get started on this goal, we first prove that every number greater than or equal to 2 has a prime factor. We leave one lemma as an exercise for you (it is a natural-number version of <code>Theorem_3_3_7</code>).</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prime_factor (p n : Nat) : <span class="kw">Prop</span> := prime p ∧ p ∣ n</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> dvd_trans {a b c : Nat} (h1 : a ∣ b) (h2 : b ∣ c) : a ∣ c := <span class="cn">sorry</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> exists_prime_factor : ∀ (n : Nat), 2 ≤ n →</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    ∃ (p : Nat), prime_factor p n := <span class="kw">by</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_strong_induc</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> n : Nat</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> ih : ∀ n_1 &lt; n, 2 ≤ n_1 → ∃ (p : Nat), prime_factor p n_1</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : 2 ≤ n</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> h2 : prime n</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h2 : prime n</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro n</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>            <span class="co">--Goal : prime n ∧ n ∣ n</span></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> prime n ∧ n ∣ n <span class="kw">from</span> And.intro h2 (dvd_self n)</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h2 : ¬prime n</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h2</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>      <span class="co">--h2 : ¬(2 ≤ n ∧ ¬∃ (a b : Nat), a * b = n ∧ a &lt; n ∧ b &lt; n)</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">demorgan</span> <span class="kw">at</span> h2</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">disj_syll</span> h2 h1</span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (a : Nat) (h3 : ∃ (b : Nat), a * b = n ∧ a &lt; n ∧ b &lt; n) <span class="kw">from</span> h2</span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (b : Nat) (h4 : a * b = n ∧ a &lt; n ∧ b &lt; n) <span class="kw">from</span> h3</span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h5 : 2 ≤ a := <span class="kw">by</span></span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>      <span class="kw">by_contra</span> h6</span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h7 : a ≤ 1 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h8 : n ≤ b :=</span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true" tabindex="-1"></a>        <span class="kw">calc</span> n</span>
<span id="cb26-29"><a href="#cb26-29" aria-hidden="true" tabindex="-1"></a>          _ = a * b := h4.left.symm</span>
<span id="cb26-30"><a href="#cb26-30" aria-hidden="true" tabindex="-1"></a>          _ ≤ 1 * b := <span class="kw">by</span> <span class="kw">rel</span> [h7]</span>
<span id="cb26-31"><a href="#cb26-31" aria-hidden="true" tabindex="-1"></a>          _ = b := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb26-32"><a href="#cb26-32" aria-hidden="true" tabindex="-1"></a>      <span class="kw">linarith</span>        <span class="co">--n ≤ b contradicts b &lt; n</span></span>
<span id="cb26-33"><a href="#cb26-33" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb26-34"><a href="#cb26-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h6 : ∃ (p : Nat), prime_factor p a := ih a h4.right.left h5</span>
<span id="cb26-35"><a href="#cb26-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (p : Nat) (h7 : prime_factor p a) <span class="kw">from</span> h6</span>
<span id="cb26-36"><a href="#cb26-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro p</span>
<span id="cb26-37"><a href="#cb26-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>            <span class="co">--Goal : prime p ∧ p ∣ n</span></span>
<span id="cb26-38"><a href="#cb26-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h7      <span class="co">--h7 : prime p ∧ p ∣ a</span></span>
<span id="cb26-39"><a href="#cb26-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro h7.left</span>
<span id="cb26-40"><a href="#cb26-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h8 : a ∣ n := <span class="kw">by</span></span>
<span id="cb26-41"><a href="#cb26-41" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro b</span>
<span id="cb26-42"><a href="#cb26-42" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> n = a * b <span class="kw">from</span> (h4.left).symm</span>
<span id="cb26-43"><a href="#cb26-43" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb26-44"><a href="#cb26-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> p ∣ n <span class="kw">from</span> dvd_trans h7.right h8</span>
<span id="cb26-45"><a href="#cb26-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb26-46"><a href="#cb26-46" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Of course, by the well-ordering principle, an immediate consequence of this lemma is that every number greater than or equal to 2 has a <em>smallest</em> prime factor.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> exists_least_prime_factor {n : Nat} (h : 2 ≤ n) :</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    ∃ (p : Nat), prime_factor p n ∧</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    ∀ (q : Nat), prime_factor q n → p ≤ q := <span class="kw">by</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> S : Set Nat := {p : Nat | prime_factor p n}</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : ∃ (p : Nat), p ∈ S := exists_prime_factor n h</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ∃ (p : Nat), prime_factor p n ∧</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    ∀ (q : Nat), prime_factor q n → p ≤ q <span class="kw">from</span> well_ord_princ S h2</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To talk about prime factorizations of positive integers, we’ll need to introduce a new type. If <code>U</code> is any type, then <code>List U</code> is the type of lists of objects of type <code>U</code>. Such a list is written in square brackets, with the entries separated by commas. For example, <code>[3, 7, 1]</code> has type <code>List Nat</code>. The notation <code>[]</code> denotes the empty list, and if <code>a</code> has type <code>U</code> and <code>l</code> has type <code>List U</code>, then <code>a :: l</code> denotes the list consisting of <code>a</code> followed by the entries of <code>l</code>. The empty list is sometimes called the <code>nil</code> list, and the operation of constructing a list <code>a :: l</code> from <code>a</code> and <code>l</code> is called <code>cons</code> (short for <em>construct</em>). Every list can be constructed by applying the <code>cons</code> operation repeatedly, starting with the <code>nil</code> list. For example,</p>
<div class="ind">
<pre><code>[3, 7, 1] = 3 :: [7, 1] = 3 :: (7 :: [1]) = 3 :: (7 :: (1 :: [])).</code></pre>
</div>
<p>If <code>l</code> has type <code>List U</code> and <code>a</code> has type <code>U</code>, then <code>a ∈ l</code> means that <code>a</code> is one of the entries in the list <code>l</code>. For example, <code>7 ∈ [3, 7, 1]</code>. Lean knows several theorems about this notation:</p>
<div class="ind">
<pre><code>@List.not_mem_nil : ∀ {α : Type u_1} {a : α},
                        a ∉ []

@List.mem_cons : ∀ {α : Type u_1} {b : α} {l : List α} {a : α},
                        a ∈ b :: l ↔ a = b ∨ a ∈ l

@List.mem_cons_self : ∀ {α : Type u_1} {a : α} {l : List α},
                        a ∈ a :: l

@List.mem_cons_of_mem : ∀ {α : Type u_1} (y : α) {a : α} {l : List α},
                        a ∈ l → a ∈ y :: l</code></pre>
</div>
<p>The first two theorems give the conditions under which something is a member of the <code>nil</code> list or a list constructed by <code>cons</code>, and the last two are easy consequences of the second.</p>
<p>To define prime factorizations, we must define several concepts first. Some of these concepts are most easily defined recursively.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> all_prime (l : List Nat) : <span class="kw">Prop</span> := ∀ p ∈ l, prime p</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> nondec (l : List Nat) : <span class="kw">Prop</span> :=</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    | [] =&gt; True   <span class="co">--Of course, True is a proposition that is always true</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    | n :: L =&gt; (∀ m ∈ L, n ≤ m) ∧ nondec L</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> nondec_prime_list (l : List Nat) : <span class="kw">Prop</span> := all_prime l ∧ nondec l</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prod (l : List Nat) : Nat :=</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>    | [] =&gt; 1</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>    | n :: L =&gt; n * (prod L)</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prime_factorization (n : Nat) (l : List Nat) : <span class="kw">Prop</span> :=</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>  nondec_prime_list l ∧ prod l = n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>According to these definitions, <code>all_prime l</code> means that every member of the list <code>l</code> is prime, <code>nondec l</code> means that every member of <code>l</code> is less than or equal to all later members, <code>prod l</code> is the product of all members of <code>l</code>, and <code>prime_factorization n l</code> means that <code>l</code> is a nondecreasing list of prime numbers whose product is <code>n</code>. It will be convenient to spell out some consequences of these definitions in several lemmas:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> all_prime_nil : all_prime [] := <span class="kw">by</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>     <span class="co">--Goal : ∀ p ∈ [], prime p</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> p : Nat</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">contrapos</span>  <span class="co">--Goal : ¬prime p → p ∉ []</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : ¬prime p</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> p ∉ [] <span class="kw">from</span> List.not_mem_nil</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> all_prime_cons (n : Nat) (L : List Nat) :</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>    all_prime (n :: L) ↔ prime n ∧ all_prime L := <span class="kw">by</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : all_prime (n :: L)  <span class="co">--Goal : prime n ∧ all_prime L</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1  <span class="co">--h1 : ∀ p ∈ n :: L, prime p</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro (h1 n List.mem_cons_self)</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>        <span class="co">--Goal : ∀ p ∈ L, prime p</span></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> p : Nat</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : p ∈ L</span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> prime p <span class="kw">from</span> h1 p (List.mem_cons_of_mem n h2)</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : prime n ∧ all_prime L  <span class="co">--Goal : all_prime (n :: l)</span></span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> : all_prime L <span class="kw">at</span> h1</span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> p : Nat</span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : p ∈ n :: L</span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [List.mem_cons] <span class="kw">at</span> h2   <span class="co">--h2 : p = n ∨ p ∈ L</span></span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">by_cases</span> <span class="kw">on</span> h2</span>
<span id="cb31-29"><a href="#cb31-29" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 1. h2 : p = n</span></span>
<span id="cb31-30"><a href="#cb31-30" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [h2]</span>
<span id="cb31-31"><a href="#cb31-31" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> prime n <span class="kw">from</span> h1.left</span>
<span id="cb31-32"><a href="#cb31-32" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb31-33"><a href="#cb31-33" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 2. h2 : p ∈ L</span></span>
<span id="cb31-34"><a href="#cb31-34" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> prime p <span class="kw">from</span> h1.right p h2</span>
<span id="cb31-35"><a href="#cb31-35" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb31-36"><a href="#cb31-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb31-37"><a href="#cb31-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb31-38"><a href="#cb31-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-39"><a href="#cb31-39" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> nondec_nil : nondec [] := <span class="kw">by</span></span>
<span id="cb31-40"><a href="#cb31-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>  <span class="co">--Goal : True</span></span>
<span id="cb31-41"><a href="#cb31-41" aria-hidden="true" tabindex="-1"></a>  <span class="kw">trivial</span> <span class="co">--trivial proves some obviously true statements, such as True</span></span>
<span id="cb31-42"><a href="#cb31-42" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb31-43"><a href="#cb31-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-44"><a href="#cb31-44" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> nondec_cons (n : Nat) (L : List Nat) :</span>
<span id="cb31-45"><a href="#cb31-45" aria-hidden="true" tabindex="-1"></a>    nondec (n :: L) ↔ (∀ m ∈ L, n ≤ m) ∧ nondec L := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb31-46"><a href="#cb31-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-47"><a href="#cb31-47" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> prod_nil : prod [] = 1 := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb31-48"><a href="#cb31-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-49"><a href="#cb31-49" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> prod_cons : prod (n :: L) = n * (prod L) := <span class="kw">by</span> <span class="kw">rfl</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Before we can prove the existence of prime factorizations, we will need one more fact: every member of a list of natural numbers divides the product of the list. The proof will be by induction on the length of the list, so we will need to know how to work with lengths of lists in Lean. If <code>l</code> is a list, then the length of <code>l</code> is <code>List.length l</code>, which can also be written more briefly as <code>l.length</code>. We’ll need a few more theorems about lists:</p>
<div class="ind">
<pre><code>@List.length_eq_zero_iff : ∀ {α : Type u_1} {l : List α},
                      l.length = 0 ↔ l = []

@List.length_cons : ∀ {α : Type u_1} {a : α} {as : List α},
                      (a :: as).length = as.length + 1

@List.exists_cons_of_ne_nil : ∀ {α : Type u_1} {l : List α},
                      l ≠ [] → ∃ (b : α) (l' : List α), l = b :: l'</code></pre>
</div>
<p>And we’ll need one more lemma, which follows from the three theorems above; we leave the proof as an exercise for you:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> exists_cons_of_length_eq_succ {A : <span class="kw">Type</span>}</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    {l : List A} {n : Nat} (h : l.length = n + 1) :</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    ∃ (a : A) (L : List A), l = a :: L ∧ L.length = n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We can now prove that every member of a list of natural numbers divides the product of the list. After proving it by induction on the length of the list, we restate the lemma in a more convenient form.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> list_elt_dvd_prod_by_length (a : Nat) : ∀ (n : Nat),</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    ∀ (l : List Nat), l.length = n → a ∈ l → a ∣ prod l := <span class="kw">by</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>  · <span class="co">--Base Case</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> l : List Nat</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : l.length = 0</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [List.length_eq_zero_iff] <span class="kw">at</span> h1     <span class="co">--h1 : l = []</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h1]                            <span class="co">--Goal : a ∈ [] → a ∣ prod []</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">contrapos</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : ¬a ∣ prod []</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> a ∉ [] <span class="kw">from</span> List.not_mem_nil</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> n : Nat</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : ∀ (l : List Nat), l.length = n → a ∈ l → a ∣ prod l</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> l : List Nat</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : l.length = n + 1            <span class="co">--Goal : a ∈ l → a ∣ prod l</span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (b : Nat) (h2 : ∃ (L : List Nat),</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>      l = b :: L ∧ L.length = n) <span class="kw">from</span> exists_cons_of_length_eq_succ h1</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (L : List Nat) (h3 : l = b :: L ∧ L.length = n) <span class="kw">from</span> h2</span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : a ∈ L → a ∣ prod L := ih L h3.right</span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h5 : a ∈ l</span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h3.left, prod_cons]            <span class="co">--Goal : a ∣ b * prod L</span></span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h3.left, List.mem_cons] <span class="kw">at</span> h5  <span class="co">--h5 : a = b ∨ a ∈ L</span></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">by_cases</span> <span class="kw">on</span> h5</span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 1. h5 : a = b</span></span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro (prod L)</span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [h5]</span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rfl</span></span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 2. h5 : a ∈ L</span></span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h6 : a ∣ prod L := h4 h5</span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h7 : prod L ∣ b * prod L := <span class="kw">by</span></span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true" tabindex="-1"></a>        <span class="kw">apply</span> Exists.intro b</span>
<span id="cb34-35"><a href="#cb34-35" aria-hidden="true" tabindex="-1"></a>        <span class="kw">ring</span></span>
<span id="cb34-36"><a href="#cb34-36" aria-hidden="true" tabindex="-1"></a>        <span class="kw">done</span></span>
<span id="cb34-37"><a href="#cb34-37" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> a ∣ b * prod L <span class="kw">from</span> dvd_trans h6 h7</span>
<span id="cb34-38"><a href="#cb34-38" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb34-39"><a href="#cb34-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb34-40"><a href="#cb34-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb34-41"><a href="#cb34-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-42"><a href="#cb34-42" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> list_elt_dvd_prod {a : Nat} {l : List Nat}</span>
<span id="cb34-43"><a href="#cb34-43" aria-hidden="true" tabindex="-1"></a>    (h : a ∈ l) : a ∣ prod l := <span class="kw">by</span></span>
<span id="cb34-44"><a href="#cb34-44" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> n : Nat := l.length</span>
<span id="cb34-45"><a href="#cb34-45" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h1 : l.length = n := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb34-46"><a href="#cb34-46" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a ∣ prod l <span class="kw">from</span> list_elt_dvd_prod_by_length a n l h1 h</span>
<span id="cb34-47"><a href="#cb34-47" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The proof that every positive integer has a prime factorization is now long but straightforward.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> exists_prime_factorization : ∀ (n : Nat), n ≥ 1 →</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    ∃ (l : List Nat), prime_factorization n l := <span class="kw">by</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_strong_induc</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> n : Nat</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> ih : ∀ n_1 &lt; n, n_1 ≥ 1 →</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    ∃ (l : List Nat), prime_factorization n_1 l</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : n ≥ 1</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> h2 : n = 1</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h2 : n = 1</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro []</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof of nondec_prime_list []</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> all_prime [] ∧ nondec [] <span class="kw">from</span></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>        And.intro all_prime_nil nondec_nil</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof of prod [] = n</span></span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [prod_nil, h2]</span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rfl</span></span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h2 : n ≠ 1</span></span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : n ≥ 2 := lt_of_le_of_ne' h1 h2</span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (p : Nat) (h4 : prime_factor p n ∧ ∀ (q : Nat),</span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a>      prime_factor q n → p ≤ q) <span class="kw">from</span> exists_least_prime_factor h3</span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> p_prime_factor : prime_factor p n := h4.left</span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> p_prime_factor</span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> p_prime : prime p := p_prime_factor.left</span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> p_dvd_n : p ∣ n := p_prime_factor.right</span>
<span id="cb35-31"><a href="#cb35-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> p_least : ∀ (q : Nat), prime_factor q n → p ≤ q := h4.right</span>
<span id="cb35-32"><a href="#cb35-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (m : Nat) (n_eq_pm : n = p * m) <span class="kw">from</span> p_dvd_n</span>
<span id="cb35-33"><a href="#cb35-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h5 : m ≠ 0 := <span class="kw">by</span></span>
<span id="cb35-34"><a href="#cb35-34" aria-hidden="true" tabindex="-1"></a>      <span class="kw">contradict</span> h1 <span class="kw">with</span> h6</span>
<span id="cb35-35"><a href="#cb35-35" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h7 : n = 0 :=</span>
<span id="cb35-36"><a href="#cb35-36" aria-hidden="true" tabindex="-1"></a>        <span class="kw">calc</span> n</span>
<span id="cb35-37"><a href="#cb35-37" aria-hidden="true" tabindex="-1"></a>          _ = p * m := n_eq_pm</span>
<span id="cb35-38"><a href="#cb35-38" aria-hidden="true" tabindex="-1"></a>          _ = p * 0 := <span class="kw">by</span> <span class="kw">rw</span> [h6]</span>
<span id="cb35-39"><a href="#cb35-39" aria-hidden="true" tabindex="-1"></a>          _ = 0 := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb35-40"><a href="#cb35-40" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [h7]</span>
<span id="cb35-41"><a href="#cb35-41" aria-hidden="true" tabindex="-1"></a>      <span class="kw">decide</span></span>
<span id="cb35-42"><a href="#cb35-42" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb35-43"><a href="#cb35-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> m_pos : 0 &lt; m := Nat.pos_of_ne_zero h5</span>
<span id="cb35-44"><a href="#cb35-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> m_lt_n : m &lt; n := <span class="kw">by</span></span>
<span id="cb35-45"><a href="#cb35-45" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span> <span class="kw">at</span> p_prime</span>
<span id="cb35-46"><a href="#cb35-46" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> m &lt; n <span class="kw">from</span></span>
<span id="cb35-47"><a href="#cb35-47" aria-hidden="true" tabindex="-1"></a>        <span class="kw">calc</span> m</span>
<span id="cb35-48"><a href="#cb35-48" aria-hidden="true" tabindex="-1"></a>          _ &lt; m + m := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb35-49"><a href="#cb35-49" aria-hidden="true" tabindex="-1"></a>          _ = 2 * m := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb35-50"><a href="#cb35-50" aria-hidden="true" tabindex="-1"></a>          _ ≤ p * m := <span class="kw">by</span> <span class="kw">rel</span> [p_prime.left]</span>
<span id="cb35-51"><a href="#cb35-51" aria-hidden="true" tabindex="-1"></a>          _ = n := n_eq_pm.symm</span>
<span id="cb35-52"><a href="#cb35-52" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb35-53"><a href="#cb35-53" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (L : List Nat) (h6 : prime_factorization m L)</span>
<span id="cb35-54"><a href="#cb35-54" aria-hidden="true" tabindex="-1"></a>      <span class="kw">from</span> ih m m_lt_n m_pos</span>
<span id="cb35-55"><a href="#cb35-55" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h6</span>
<span id="cb35-56"><a href="#cb35-56" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> ndpl_L : nondec_prime_list L := h6.left</span>
<span id="cb35-57"><a href="#cb35-57" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> ndpl_L</span>
<span id="cb35-58"><a href="#cb35-58" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro (p :: L)</span>
<span id="cb35-59"><a href="#cb35-59" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb35-60"><a href="#cb35-60" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro</span>
<span id="cb35-61"><a href="#cb35-61" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof of nondec_prime_list (p :: L)</span></span>
<span id="cb35-62"><a href="#cb35-62" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span></span>
<span id="cb35-63"><a href="#cb35-63" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> And.intro</span>
<span id="cb35-64"><a href="#cb35-64" aria-hidden="true" tabindex="-1"></a>      · <span class="co">-- Proof of all_prime (p :: L)</span></span>
<span id="cb35-65"><a href="#cb35-65" aria-hidden="true" tabindex="-1"></a>        <span class="kw">rewrite</span> [all_prime_cons]</span>
<span id="cb35-66"><a href="#cb35-66" aria-hidden="true" tabindex="-1"></a>        <span class="kw">show</span> prime p ∧ all_prime L <span class="kw">from</span> And.intro p_prime ndpl_L.left</span>
<span id="cb35-67"><a href="#cb35-67" aria-hidden="true" tabindex="-1"></a>        <span class="kw">done</span></span>
<span id="cb35-68"><a href="#cb35-68" aria-hidden="true" tabindex="-1"></a>      · <span class="co">-- Proof of nondec (p :: L)</span></span>
<span id="cb35-69"><a href="#cb35-69" aria-hidden="true" tabindex="-1"></a>        <span class="kw">rewrite</span> [nondec_cons]</span>
<span id="cb35-70"><a href="#cb35-70" aria-hidden="true" tabindex="-1"></a>        <span class="kw">apply</span> And.intro _ ndpl_L.right</span>
<span id="cb35-71"><a href="#cb35-71" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fix</span> q : Nat</span>
<span id="cb35-72"><a href="#cb35-72" aria-hidden="true" tabindex="-1"></a>        <span class="kw">assume</span> q_in_L : q ∈ L</span>
<span id="cb35-73"><a href="#cb35-73" aria-hidden="true" tabindex="-1"></a>        <span class="kw">have</span> h7 : q ∣ prod L := list_elt_dvd_prod q_in_L</span>
<span id="cb35-74"><a href="#cb35-74" aria-hidden="true" tabindex="-1"></a>        <span class="kw">rewrite</span> [h6.right] <span class="kw">at</span> h7   <span class="co">--h7 : q ∣ m</span></span>
<span id="cb35-75"><a href="#cb35-75" aria-hidden="true" tabindex="-1"></a>        <span class="kw">have</span> h8 : m ∣ n := <span class="kw">by</span></span>
<span id="cb35-76"><a href="#cb35-76" aria-hidden="true" tabindex="-1"></a>          <span class="kw">apply</span> Exists.intro p</span>
<span id="cb35-77"><a href="#cb35-77" aria-hidden="true" tabindex="-1"></a>          <span class="kw">rewrite</span> [n_eq_pm]</span>
<span id="cb35-78"><a href="#cb35-78" aria-hidden="true" tabindex="-1"></a>          <span class="kw">ring</span></span>
<span id="cb35-79"><a href="#cb35-79" aria-hidden="true" tabindex="-1"></a>          <span class="kw">done</span></span>
<span id="cb35-80"><a href="#cb35-80" aria-hidden="true" tabindex="-1"></a>        <span class="kw">have</span> q_dvd_n : q ∣ n := dvd_trans h7 h8</span>
<span id="cb35-81"><a href="#cb35-81" aria-hidden="true" tabindex="-1"></a>        <span class="kw">have</span> ap_L : all_prime L := ndpl_L.left</span>
<span id="cb35-82"><a href="#cb35-82" aria-hidden="true" tabindex="-1"></a>        <span class="kw">define</span> <span class="kw">at</span> ap_L</span>
<span id="cb35-83"><a href="#cb35-83" aria-hidden="true" tabindex="-1"></a>        <span class="kw">have</span> q_prime_factor : prime_factor q n :=</span>
<span id="cb35-84"><a href="#cb35-84" aria-hidden="true" tabindex="-1"></a>          And.intro (ap_L q q_in_L) q_dvd_n</span>
<span id="cb35-85"><a href="#cb35-85" aria-hidden="true" tabindex="-1"></a>        <span class="kw">show</span> p ≤ q <span class="kw">from</span> p_least q q_prime_factor</span>
<span id="cb35-86"><a href="#cb35-86" aria-hidden="true" tabindex="-1"></a>        <span class="kw">done</span></span>
<span id="cb35-87"><a href="#cb35-87" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb35-88"><a href="#cb35-88" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof of prod (p :: L) = n</span></span>
<span id="cb35-89"><a href="#cb35-89" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [prod_cons, h6.right, n_eq_pm]</span>
<span id="cb35-90"><a href="#cb35-90" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rfl</span></span>
<span id="cb35-91"><a href="#cb35-91" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb35-92"><a href="#cb35-92" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb35-93"><a href="#cb35-93" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We now turn to the proof that the prime factorization of a positive integer is unique. In preparation for that proof, <em>HTPI</em> defines two numbers to be <em>relatively prime</em> if their greatest common divisor is 1, and then it uses that concept to prove two theorems, 7.2.2 and 7.2.3. Here are similar proofs of those theorems in Lean, with the proof of one lemma left as an exercise. In the proof of Theorem 7.2.2, we begin, as we did in the proof of Theorem 7.1.6, by converting the goal from natural numbers to integers so that we can use integer algebra.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rel_prime (a b : Nat) : <span class="kw">Prop</span> := gcd a b = 1</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_2_2 {a b c : Nat}</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    (h1 : c ∣ a * b) (h2 : rel_prime a c) : c ∣ b := <span class="kw">by</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←Int.natCast_dvd_natCast]  <span class="co">--Goal : ↑c ∣ ↑b</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1; <span class="kw">define</span> <span class="kw">at</span> h2; <span class="kw">define</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (j : Nat) (h3 : a * b = c * j) <span class="kw">from</span> h1</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> s : Int := gcd_c1 a c</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> t : Int := gcd_c2 a c</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : s * ↑a + t * ↑c = ↑(gcd a c) := gcd_lin_comb c a</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h2, Nat.cast_one] <span class="kw">at</span> h4  <span class="co">--h4 : s * ↑a + t * ↑c = (1 : Int)</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (s * ↑j + t * ↑b)</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ↑b = ↑c * (s * ↑j + t * ↑b) <span class="kw">from</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> ↑b</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>      _ = (1 : Int) * ↑b := (one_mul _).symm</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>      _ = (s * ↑a + t * ↑c) * ↑b := <span class="kw">by</span> <span class="kw">rw</span> [h4]</span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>      _ = s * (↑a * ↑b) + t * ↑c * ↑b := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>      _ = s * (↑c * ↑j) + t * ↑c * ↑b := <span class="kw">by</span></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>            <span class="kw">rw</span> [←Nat.cast_mul a b, h3, Nat.cast_mul c j]</span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>      _ = ↑c * (s * ↑j + t * ↑b) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> dvd_prime {a p : Nat}</span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a>    (h1 : prime p) (h2 : a ∣ p) : a = 1 ∨ a = p := <span class="cn">sorry</span></span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> rel_prime_of_prime_not_dvd {a p : Nat}</span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a>    (h1 : prime p) (h2 : ¬p ∣ a) : rel_prime a p := <span class="kw">by</span></span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : gcd a p ∣ a := gcd_dvd_left a p</span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : gcd a p ∣ p := gcd_dvd_right a p</span>
<span id="cb36-30"><a href="#cb36-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : gcd a p = 1 ∨ gcd a p = p := dvd_prime h1 h4</span>
<span id="cb36-31"><a href="#cb36-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : gcd a p ≠ p := <span class="kw">by</span></span>
<span id="cb36-32"><a href="#cb36-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">contradict</span> h2 <span class="kw">with</span> h6</span>
<span id="cb36-33"><a href="#cb36-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h6] <span class="kw">at</span> h3</span>
<span id="cb36-34"><a href="#cb36-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> p ∣ a <span class="kw">from</span> h3</span>
<span id="cb36-35"><a href="#cb36-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb36-36"><a href="#cb36-36" aria-hidden="true" tabindex="-1"></a>  <span class="kw">disj_syll</span> h5 h6</span>
<span id="cb36-37"><a href="#cb36-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> rel_prime a p <span class="kw">from</span> h5</span>
<span id="cb36-38"><a href="#cb36-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb36-39"><a href="#cb36-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-40"><a href="#cb36-40" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_2_3 {a b p : Nat}</span>
<span id="cb36-41"><a href="#cb36-41" aria-hidden="true" tabindex="-1"></a>    (h1 : prime p) (h2 : p ∣ a * b) : p ∣ a ∨ p ∣ b := <span class="kw">by</span></span>
<span id="cb36-42"><a href="#cb36-42" aria-hidden="true" tabindex="-1"></a>  <span class="kw">or_right</span> <span class="kw">with</span> h3</span>
<span id="cb36-43"><a href="#cb36-43" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : rel_prime a p := rel_prime_of_prime_not_dvd h1 h3</span>
<span id="cb36-44"><a href="#cb36-44" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> p ∣ b <span class="kw">from</span> Theorem_7_2_2 h2 h4</span>
<span id="cb36-45"><a href="#cb36-45" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Theorem 7.2.4 in <em>HTPI</em> extends Theorem 7.2.3 to show that if a prime number divides the product of a list of natural numbers, then it divides one of the numbers in the list. (Theorem 7.2.3 is the case of a list of length two.) The proof in <em>HTPI</em> is by induction on the length of the list, and we could use that method to prove the theorem in Lean. But look back at our proof of the lemma <code>list_elt_dvd_prod_by_length</code>, which also used induction on the length of a list. In the base case, we ended up proving that the <code>nil</code> list has the property stated in the lemma, and in the induction step we proved that if a list <code>L</code> has the property, then so does any list of the form <code>b :: L</code>. We could think of this as a kind of “induction on lists.” As we observed earlier, every list can be constructed by starting with the <code>nil</code> list and applying <code>cons</code> finitely many times. It follows that if the <code>nil</code> list has some property, and applying the <code>cons</code> operation to a list with the property produces another list with the property, then all lists have the property. (In fact, a similar principle was at work in our recursive definitions of <code>nondec l</code> and <code>prod l</code>.)</p>
<p>Lean has a theorem called <code>List.rec</code> that can be used to justify induction on lists. This is a little more convenient than induction on the length of a list, so we’ll use it to prove Theorem 7.2.4. The proof uses two lemmas, whose proofs we leave as exercises for you.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> eq_one_of_dvd_one {n : Nat} (h : n ∣ 1) : n = 1 := <span class="cn">sorry</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> prime_not_one {p : Nat} (h : prime p) : p ≠ 1 := <span class="cn">sorry</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_2_4 {p : Nat} (h1 : prime p) :</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    ∀ (l : List Nat), p ∣ prod l → ∃ a ∈ l, p ∣ a := <span class="kw">by</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> List.rec</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case.  Goal : p ∣ prod [] → ∃ a ∈ [], p ∣ a</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [prod_nil]</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : p ∣ 1</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ∃ a ∈ [], p ∣ a <span class="kw">from</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>      absurd (eq_one_of_dvd_one h2) (prime_not_one h1)</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> b : Nat</span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> L : List Nat</span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : p ∣ prod L → ∃ a ∈ L, p ∣ a</span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>      <span class="co">--Goal : p ∣ prod (b :: L) → ∃ a ∈ b :: L, p ∣ a</span></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : p ∣ prod (b :: L)</span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [prod_cons] <span class="kw">at</span> h2</span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : p ∣ b ∨ p ∣ prod L := Theorem_7_2_3 h1 h2</span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">by_cases</span> <span class="kw">on</span> h3</span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 1. h3 : p ∣ b</span></span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro b</span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> b ∈ b :: L ∧ p ∣ b <span class="kw">from</span></span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a>        And.intro List.mem_cons_self h3</span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb37-28"><a href="#cb37-28" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 2. h3 : p ∣ prod L</span></span>
<span id="cb37-29"><a href="#cb37-29" aria-hidden="true" tabindex="-1"></a>      <span class="kw">obtain</span> (a : Nat) (h4 : a ∈ L ∧ p ∣ a) <span class="kw">from</span> ih h3</span>
<span id="cb37-30"><a href="#cb37-30" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro a</span>
<span id="cb37-31"><a href="#cb37-31" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> a ∈ b :: L ∧ p ∣ a <span class="kw">from</span></span>
<span id="cb37-32"><a href="#cb37-32" aria-hidden="true" tabindex="-1"></a>        And.intro (List.mem_cons_of_mem b h4.left) h4.right</span>
<span id="cb37-33"><a href="#cb37-33" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb37-34"><a href="#cb37-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb37-35"><a href="#cb37-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In Theorem 7.2.4, if all members of the list <code>l</code> are prime, then we can conclude not merely that <code>p</code> divides some member of <code>l</code>, but that <code>p</code> is one of the members.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> prime_in_list {p : Nat} {l : List Nat}</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    (h1 : prime p) (h2 : all_prime l) (h3 : p ∣ prod l) : p ∈ l := <span class="kw">by</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : Nat) (h4 : a ∈ l ∧ p ∣ a) <span class="kw">from</span> Theorem_7_2_4 h1 l h3</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : prime a := h2 a h4.left</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : p = 1 ∨ p = a := dvd_prime h5 h4.right</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">disj_syll</span> h6 (prime_not_one h1)</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h6]</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a ∈ l <span class="kw">from</span> h4.left</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The uniqueness of prime factorizations follows from Theorem 7.2.5 of <em>HTPI</em>, which says that if two nondecreasing lists of prime numbers have the same product, then the two lists must be the same. In <em>HTPI</em>, a key step in the proof of Theorem 7.2.5 is to show that if two nondecreasing lists of prime numbers have the same product, then the last entry of one list is less than or equal to the last entry of the other. In Lean, because of the way the <code>cons</code> operation works, it is easier to work with the first entries of the lists.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> first_le_first {p q : Nat} {l m : List Nat}</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    (h1 : nondec_prime_list (p :: l)) (h2 : nondec_prime_list (q :: m))</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    (h3 : prod (p :: l) = prod (q :: m)) : p ≤ q := <span class="kw">by</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1; <span class="kw">define</span> <span class="kw">at</span> h2</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : q ∣ prod (p :: l) := <span class="kw">by</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro (prod m)</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←prod_cons]</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> prod (p :: l) = prod (q :: m) <span class="kw">from</span> h3</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : all_prime (q :: m) := h2.left</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [all_prime_cons] <span class="kw">at</span> h5</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : q ∈ p :: l := prime_in_list h5.left h1.left h4</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h7 : nondec (p :: l) := h1.right</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [nondec_cons] <span class="kw">at</span> h7</span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [List.mem_cons] <span class="kw">at</span> h6</span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> <span class="kw">on</span> h6</span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h6 : q = p</span></span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">linarith</span></span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h6 : q ∈ l</span></span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h8 : ∀ m ∈ l, p ≤ m := h7.left</span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> p ≤ q <span class="kw">from</span> h8 q h6</span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The proof of Theorem 7.2.5 is another proof by induction on lists. It uses a few more lemmas whose proofs we leave as exercises.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> nondec_prime_list_tail {p : Nat} {l : List Nat}</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    (h : nondec_prime_list (p :: l)) : nondec_prime_list l := <span class="cn">sorry</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> cons_prod_not_one {p : Nat} {l : List Nat}</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    (h : nondec_prime_list (p :: l)) : prod (p :: l) ≠ 1 := <span class="cn">sorry</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> list_nil_iff_prod_one {l : List Nat} (h : nondec_prime_list l) :</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>    l = [] ↔ prod l = 1 := <span class="cn">sorry</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> prime_pos {p : Nat} (h : prime p) : p &gt; 0 := <span class="cn">sorry</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_2_5 : ∀ (l1 l2 : List Nat),</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>    nondec_prime_list l1 → nondec_prime_list l2 →</span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>    prod l1 = prod l2 → l1 = l2 := <span class="kw">by</span></span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> List.rec</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case.  Goal : ∀ (l2 : List Nat), nondec_prime_list [] →</span></span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- nondec_prime_list l2 → prod [] = prod l2 → [] = l2</span></span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> l2 : List Nat</span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : nondec_prime_list []</span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : nondec_prime_list l2</span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h3 : prod [] = prod l2</span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [prod_nil, eq_comm, ←list_nil_iff_prod_one h2] <span class="kw">at</span> h3</span>
<span id="cb40-23"><a href="#cb40-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> [] = l2 <span class="kw">from</span> h3.symm</span>
<span id="cb40-24"><a href="#cb40-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb40-25"><a href="#cb40-25" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb40-26"><a href="#cb40-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> p : Nat</span>
<span id="cb40-27"><a href="#cb40-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> L1 : List Nat</span>
<span id="cb40-28"><a href="#cb40-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : ∀ (L2 : List Nat), nondec_prime_list L1 →</span>
<span id="cb40-29"><a href="#cb40-29" aria-hidden="true" tabindex="-1"></a>      nondec_prime_list L2 → prod L1 = prod L2 → L1 = L2</span>
<span id="cb40-30"><a href="#cb40-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Goal : ∀ (l2 : List Nat), nondec_prime_list (p :: L1) →</span></span>
<span id="cb40-31"><a href="#cb40-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- nondec_prime_list l2 → prod (p :: L1) = prod l2 → p :: L1 = l2</span></span>
<span id="cb40-32"><a href="#cb40-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> l2 : List Nat</span>
<span id="cb40-33"><a href="#cb40-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : nondec_prime_list (p :: L1)</span>
<span id="cb40-34"><a href="#cb40-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : nondec_prime_list l2</span>
<span id="cb40-35"><a href="#cb40-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h3 : prod (p :: L1) = prod l2</span>
<span id="cb40-36"><a href="#cb40-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : ¬prod (p :: L1) = 1 := cons_prod_not_one h1</span>
<span id="cb40-37"><a href="#cb40-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h3, ←list_nil_iff_prod_one h2] <span class="kw">at</span> h4</span>
<span id="cb40-38"><a href="#cb40-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (q : Nat) (h5 : ∃ (L : List Nat), l2 = q :: L) <span class="kw">from</span></span>
<span id="cb40-39"><a href="#cb40-39" aria-hidden="true" tabindex="-1"></a>      List.exists_cons_of_ne_nil h4</span>
<span id="cb40-40"><a href="#cb40-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (L2 : List Nat) (h6 : l2 = q :: L2) <span class="kw">from</span> h5</span>
<span id="cb40-41"><a href="#cb40-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h6] <span class="kw">at</span> h2    <span class="co">--h2 : nondec_prime_list (q :: L2)</span></span>
<span id="cb40-42"><a href="#cb40-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h6] <span class="kw">at</span> h3    <span class="co">--h3 : prod (p :: L1) = prod (q :: L2)</span></span>
<span id="cb40-43"><a href="#cb40-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h7 : p ≤ q := first_le_first h1 h2 h3</span>
<span id="cb40-44"><a href="#cb40-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h8 : q ≤ p := first_le_first h2 h1 h3.symm</span>
<span id="cb40-45"><a href="#cb40-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h9 : p = q := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb40-46"><a href="#cb40-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h9, prod_cons, prod_cons] <span class="kw">at</span> h3</span>
<span id="cb40-47"><a href="#cb40-47" aria-hidden="true" tabindex="-1"></a>      <span class="co">--h3 : q * prod L1 = q * prod L2</span></span>
<span id="cb40-48"><a href="#cb40-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h10 : nondec_prime_list L1 := nondec_prime_list_tail h1</span>
<span id="cb40-49"><a href="#cb40-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h11 : nondec_prime_list L2 := nondec_prime_list_tail h2</span>
<span id="cb40-50"><a href="#cb40-50" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h2</span>
<span id="cb40-51"><a href="#cb40-51" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h12 : all_prime (q :: L2) := h2.left</span>
<span id="cb40-52"><a href="#cb40-52" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [all_prime_cons] <span class="kw">at</span> h12</span>
<span id="cb40-53"><a href="#cb40-53" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h13 : q &gt; 0 := prime_pos h12.left</span>
<span id="cb40-54"><a href="#cb40-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h14 : prod L1 = prod L2 := Nat.eq_of_mul_eq_mul_left h13 h3</span>
<span id="cb40-55"><a href="#cb40-55" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h15 : L1 = L2 := ih L2 h10 h11 h14</span>
<span id="cb40-56"><a href="#cb40-56" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h6, h9, h15]</span>
<span id="cb40-57"><a href="#cb40-57" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb40-58"><a href="#cb40-58" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb40-59"><a href="#cb40-59" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Putting it all together, we can finally prove the fundamental theorem of arithmetic, which is stated as Theorem 7.2.6 in <em>HTPI</em>:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> fund_thm_arith (n : Nat) (h : n ≥ 1) :</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    ∃! (l : List Nat), prime_factorization n l := <span class="kw">by</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">exists_unique</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Existence</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ∃ (l : List Nat), prime_factorization n l <span class="kw">from</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>      exists_prime_factorization n h</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Uniqueness</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> l1 : List Nat; <span class="kw">fix</span> l2 : List Nat</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : prime_factorization n l1</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : prime_factorization n l2</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1; <span class="kw">define</span> <span class="kw">at</span> h2</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : prod l1 = n := h1.right</span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←h2.right] <span class="kw">at</span> h3</span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> l1 = l2 <span class="kw">from</span> Theorem_7_2_5 l1 l2 h1.left h2.left h3</span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="exercises-1" class="level3">
<h3 class="anchored" data-anchor-id="exercises-1">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb42"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> dvd_prime {a p : Nat}</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    (h1 : prime p) (h2 : a ∣ p) : a = 1 ∨ a = p := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb43"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Hints:  Start with apply List.rec.</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="co">--You may find the theorem mul_ne_zero useful.</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> prod_nonzero_nonzero : ∀ (l : List Nat),</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    (∀ a ∈ l, a ≠ 0) → prod l ≠ 0 := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb44"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> rel_prime_iff_no_common_factor (a b : Nat) :</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    rel_prime a b ↔ ¬∃ (p : Nat), prime p ∧ p ∣ a ∧ p ∣ b := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb45"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> rel_prime_symm {a b : Nat} (h : rel_prime a b) :</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>    rel_prime b a := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb46"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> in_prime_factorization_iff_prime_factor {a : Nat} {l : List Nat}</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    (h1 : prime_factorization a l) (p : Nat) :</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    p ∈ l ↔ prime_factor p a := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="6">
<div class="sourceCode" id="cb47"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_7_2_5 {a b : Nat} {l m : List Nat}</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    (h1 : prime_factorization a l) (h2 : prime_factorization b m) :</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    rel_prime a b ↔ (¬∃ (p : Nat), p ∈ l ∧ p ∈ m) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="7">
<div class="sourceCode" id="cb48"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_7_2_6 (a b : Nat) :</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    rel_prime a b ↔ ∃ (s t : Int), s * a + t * b = 1 := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="8">
<div class="sourceCode" id="cb49"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_7_2_7 {a b a' b' : Nat}</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    (h1 : rel_prime a b) (h2 : a' ∣ a) (h3 : b' ∣ b) :</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>    rel_prime a' b' := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="9">
<div class="sourceCode" id="cb50"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_7_2_9 {a b j k : Nat}</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    (h1 : gcd a b ≠ 0) (h2 : a = j * gcd a b) (h3 : b = k * gcd a b) :</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    rel_prime j k := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="10">
<div class="sourceCode" id="cb51"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_7_2_17a (a b c : Nat) :</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    gcd a (b * c) ∣ gcd a b * gcd a c := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="modular-arithmetic" class="level2">
<h2 class="anchored" data-anchor-id="modular-arithmetic">7.3. Modular Arithmetic</h2>
<p>If <span class="math inline">\(m\)</span> is a positive integer and <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are integers, then <em>HTPI</em> uses the notation <span class="math inline">\(a \equiv b\pmod m\)</span>, or sometimes <span class="math inline">\(a \equiv_m b\)</span>, to indicate that <span class="math inline">\(a\)</span> is congruent to <span class="math inline">\(b\)</span> modulo <span class="math inline">\(m\)</span>, which is defined to mean <span class="math inline">\(m \mid (a - b)\)</span>. Congruence modulo <span class="math inline">\(m\)</span> is an equivalence relation on the integers, and therefore it induces a partition <span class="math inline">\(\mathbb{Z}/{\equiv_m}\)</span> of the integers, as shown in Section 4.5 of <em>HTPI</em>. The elements of this partition are the equivalence classes <span class="math inline">\([a]_m\)</span> for <span class="math inline">\(a \in \mathbb{Z}\)</span>; we will call these <em>congruence classes modulo <span class="math inline">\(m\)</span></em>. Section 7.3 of <em>HTPI</em> defines operations of addition and multiplication of congruence classes and proves algebraic properties of those operations.</p>
<p>For the purpose of working out the rules of modular arithmetic, the only important properties of congruence classes are the following:</p>
<ol type="1">
<li>For every integer <span class="math inline">\(a\)</span>, there is a corresponding congruence class <span class="math inline">\([a]_m \in \mathbb{Z}/{\equiv_m}\)</span>.</li>
<li>For every congruence class <span class="math inline">\(X \in \mathbb{Z}/{\equiv_m}\)</span>, there is some integer <span class="math inline">\(a\)</span> such that <span class="math inline">\(X = [a]_m\)</span>.</li>
<li>For all integers <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, <span class="math inline">\([a]_m = [b]_m\)</span> if and only if <span class="math inline">\(a \equiv_m b\)</span>.</li>
<li>For all integers <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, <span class="math inline">\([a]_m + [b]_m = [a + b]_m\)</span>.</li>
<li>For all integers <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, <span class="math inline">\([a]_m \cdot [b]_m = [ab]_m\)</span>.</li>
</ol>
<p>To study congruence modulo <code>m</code> in Lean, we will declare <code>m</code> to have type <code>Nat</code>, which allows for the possibility that <code>m = 0</code>, but we will mostly focus on the case <code>m ≠ 0</code>. For <code>a</code> and <code>b</code> of type <code>Int</code>, we define <code>congr_mod m a b</code> to mean that <code>a</code> is congruent to <code>b</code> modulo <code>m</code>. Notice that to define this relation in Lean, we must coerce <code>m</code> to be an integer so that we can use it in the divisibility relation on the integers.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> congr_mod (m : Nat) (a b : Int) : <span class="kw">Prop</span> := (↑m : Int) ∣ (a - b)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We can teach Lean to use more familiar notation for congruence modulo <code>m</code> by giving the following command:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">notation</span>:50 a <span class="st">" ≡ "</span> b <span class="st">" (MOD "</span> m <span class="st">")"</span> =&gt; congr_mod m a b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This tells Lean that if we type <code>a ≡ b (MOD m)</code>, then Lean should interpret it as <code>congr_mod m a b</code>. (To enter the symbol <code>≡</code>, type <code>\==</code>. Don’t worry about the <code>:50</code> in the <code>notation</code> command above. It is there to help Lean parse this new notation when it occurs together with other notation.)</p>
<p>We can now prove that congruence modulo <code>m</code> is reflexive, symmetric, and transitive. In these proofs, we leave it to Lean to fill in coercions when they are necessary, and as usual, we leave some details as exercises.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> congr_refl (m : Nat) : ∀ (a : Int), a ≡ a (MOD m) := <span class="cn">sorry</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> congr_symm {m : Nat} : ∀ {a b : Int},</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>    a ≡ b (MOD m) → b ≡ a (MOD m) := <span class="kw">by</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a : Int; <span class="kw">fix</span> b : Int</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : a ≡ b (MOD m)</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1                 <span class="co">--h1 : ∃ (c : Int), a - b = ↑m * c</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>                       <span class="co">--Goal : ∃ (c : Int), b - a = ↑m * c</span></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (c : Int) (h2 : a - b = m * c) <span class="kw">from</span> h1</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (-c)</span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> b - a = m * (-c) <span class="kw">from</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> b - a</span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>      _ = -(a - b) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a>      _ = -(m * c) := <span class="kw">by</span> <span class="kw">rw</span> [h2]</span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>      _ = m * (-c) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> congr_trans {m : Nat} : ∀ {a b c : Int},</span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true" tabindex="-1"></a>    a ≡ b (MOD m) → b ≡ c (MOD m) → a ≡ c (MOD m) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We could now repeat the entire development of <span class="math inline">\(\mathbb{Z}/{\equiv_m}\)</span> in Lean, but there is no need to do so; such a development is already included in Lean’s library of definitions and theorems. For each natural number <code>m</code>, Lean has a type <code>ZMod m</code>, and the objects of that type are Lean’s version of the congruence classes modulo <code>m</code>. We should warn you that Lean’s way of defining <code>ZMod m</code> differs in some ways from <em>HTPI</em>’s definition of <span class="math inline">\(\mathbb{Z}/{\equiv_m}\)</span>. In particular, objects of type <code>ZMod m</code> are not sets of integers. Thus, if <code>X</code> has type <code>ZMod m</code> and <code>a</code> has type <code>Int</code>, then Lean will not understand what you mean if you write <code>a ∈ X</code>. However, Lean’s congruence classes have the properties 1–5 listed above, and that’s all that will matter to us.</p>
<p>Property 1 says that if <code>a</code> has type <code>Int</code>, then there should be a corresponding congruence class in <code>ZMod m</code>. In fact, you can find the corresponding congruence class by simply coercing <code>a</code> to have type <code>ZMod m</code>. But for the sake of clarity, we will introduce a function for computing the congruence class modulo <code>m</code> of <code>a</code>:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cc (m : Nat) (a : Int) : ZMod m := (↑a : ZMod m)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Thus, <code>cc m a</code> is the congruence class modulo <code>m</code> of <code>a</code>. Once again, it will be convenient to teach Lean to use more familiar notation for congruence classes, so we give the command:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">notation</span>:max <span class="st">"["</span>a<span class="st">"]_"</span>m:max =&gt; cc m a</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now if we type <code>[a]_m</code>, then Lean will interpret it as <code>cc m a</code>. Thus, from now on, <code>[a]_m</code> will be our notation in Lean for the congruence class modulo <code>m</code> of <code>a</code>; it corresponds to the <em>HTPI</em> notation <span class="math inline">\([a]_m\)</span>. (Once again, you can ignore the two occurrences of <code>:max</code> in the <code>notation</code> command above.)</p>
<p>Properties 2–5 of congruence classes are established by the following theorems:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> cc_rep {m : Nat} (X : ZMod m) : ∃ (a : Int), X = [a]_m</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> cc_eq_iff_congr (m : Nat) (a b : Int) :</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    [a]_m = [b]_m ↔ a ≡ b (MOD m)</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> add_class (m : Nat) (a b : Int) :</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>    [a]_m + [b]_m = [a + b]_m</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> mul_class (m : Nat) (a b : Int) :</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>    [a]_m * [b]_m = [a * b]_m</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We won’t discuss the proofs of these theorems, since they depend on details of Lean’s representation of objects of type <code>ZMod m</code> that are beyond the scope of this book. But these theorems are all we will need to use to develop the theory of modular arithmetic.</p>
<p>In many of our theorems about <code>ZMod m</code>, we will need to include a hypothesis that <code>m ≠ 0</code>. We will usually state this hypothesis in the form <code>NeZero m</code>, which is a proposition that is equivalent to <code>m ≠ 0</code>. Indeed, there is a theorem in Lean’s library that asserts this equivalence:</p>
<div class="ind">
<pre><code>@neZero_iff : ∀ {R : Type u_1} [inst : Zero R] {n : R},
              NeZero n ↔ n ≠ 0</code></pre>
</div>
<p>What distinguishes <code>NeZero m</code> from <code>m ≠ 0</code> is that <code>NeZero m</code> is what is called a <em>type class</em>. What this means is that, once Lean has a proof of <code>NeZero m</code> for some natural number <code>m</code>, it will remember that proof and be able to recall it when necessary. As a result, <code>NeZero m</code> can be used as a new kind of implicit argument in the statement of a theorem. To make it an implicit argument, we write it in square brackets, like this: <code>[NeZero m]</code>. When applying a theorem that includes this hypothesis, there is no need to supply a proof that <code>m ≠ 0</code>; as long as Lean knows about such a proof, it will recall that proof on its own. When you are proving a theorem that includes the hypothesis <code>[NeZero m]</code>, Lean will recognize <code>NeZero.ne m</code> as a proof that <code>m ≠ 0</code>.</p>
<p>The first theorem in Section 7.3 of <em>HTPI</em>, Theorem 7.3.1, says that if <code>m ≠ 0</code>, then every integer <code>a</code> is congruent modulo <code>m</code> to exactly one integer <code>r</code> satisfying <code>0 ≤ r &lt; m</code>. As explained in <em>HTPI</em>, we say that <code>{0, 1, ..., m - 1}</code> is a <em>complete residue system modulo <code>m</code></em>. This implies that the objects of type <code>ZMod m</code> are precisely the congruence classes <code>[0]_m</code>, <code>[1]_m</code>, …, <code>[m - 1]_m</code>.</p>
<p>The proof of Theorem 7.3.1 makes use of the quotient and remainder when <code>a</code> is divided by <code>m</code>. In Section 6.4, we learned about the Lean theorems <code>Nat.div_add_mod</code> and <code>Nat.mod_lt</code>, but those theorems concerned quotients and remainders when dividing <em>natural numbers</em>. Fortunately, Lean has similar theorems for dealing with division of integers:</p>
<div class="ind">
<pre><code>Int.ediv_add_emod : ∀ (a b : ℤ), b * (a / b) + a % b = a

Int.emod_lt_of_pos : ∀ (a : ℤ) {b : ℤ}, 0 &lt; b → a % b &lt; b

Int.emod_nonneg : ∀ (a : ℤ) {b : ℤ}, b ≠ 0 → 0 ≤ a % b</code></pre>
</div>
<p>We now have all the background we need to prove Theorem 7.3.1 in Lean. We begin with a few lemmas, some of which require the hypothesis <code>[NeZero m]</code>. The proof of the theorem closely follows the proof in <em>HTPI</em>. Note that all of the proofs below involve the expression <code>a % m</code>. Since <code>a</code> is an integer, the operator <code>%</code> in this expression must be the integer version of the mod operator, and therefore <code>m</code> must be coerced to be an integer. Thus, Lean interprets <code>a % m</code> as <code>a % ↑m</code></p>
<div class="sourceCode" id="cb60"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> mod_nonneg (m : Nat) [NeZero m] (a : Int) : 0 ≤ a % m := <span class="kw">by</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h1 : (↑m : Int) ≠ 0 := (Nat.cast_ne_zero).rtl (NeZero.ne m)</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> 0 ≤ a % m <span class="kw">from</span> Int.emod_nonneg a h1</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> mod_lt (m : Nat) [NeZero m] (a : Int) : a % m &lt; m := <span class="cn">sorry</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> congr_mod_mod (m : Nat) (a : Int) : a ≡ a % m (MOD m) := <span class="kw">by</span></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h1 : m * (a / m) + a % m = a := Int.ediv_add_emod a m</span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (a / m)</span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a - a % m = m * (a / m) <span class="kw">from</span></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> a - (a % m)</span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a>      _ = m * (a / m) + a % m - a % m := <span class="kw">by</span> <span class="kw">rw</span> [h1]</span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a>      _ = m * (a / m) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-18"><a href="#cb60-18" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> mod_cmpl_res (m : Nat) [NeZero m] (a : Int) :</span>
<span id="cb60-19"><a href="#cb60-19" aria-hidden="true" tabindex="-1"></a>    0 ≤ a % m ∧ a % m &lt; m ∧ a ≡ a % m (MOD m) :=</span>
<span id="cb60-20"><a href="#cb60-20" aria-hidden="true" tabindex="-1"></a>  And.intro (mod_nonneg m a) (And.intro (mod_lt m a) (congr_mod_mod m a))</span>
<span id="cb60-21"><a href="#cb60-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-22"><a href="#cb60-22" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_3_1 (m : Nat) [NeZero m] (a : Int) :</span>
<span id="cb60-23"><a href="#cb60-23" aria-hidden="true" tabindex="-1"></a>    ∃! (r : Int), 0 ≤ r ∧ r &lt; m ∧ a ≡ r (MOD m) := <span class="kw">by</span></span>
<span id="cb60-24"><a href="#cb60-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">exists_unique</span></span>
<span id="cb60-25"><a href="#cb60-25" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Existence</span></span>
<span id="cb60-26"><a href="#cb60-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro (a % m)</span>
<span id="cb60-27"><a href="#cb60-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> 0 ≤ a % m ∧ a % m &lt; m ∧ a ≡ a % m (MOD m)</span>
<span id="cb60-28"><a href="#cb60-28" aria-hidden="true" tabindex="-1"></a>      <span class="kw">from</span> mod_cmpl_res m a</span>
<span id="cb60-29"><a href="#cb60-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb60-30"><a href="#cb60-30" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Uniqueness</span></span>
<span id="cb60-31"><a href="#cb60-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> r1 : Int; <span class="kw">fix</span> r2 : Int</span>
<span id="cb60-32"><a href="#cb60-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : 0 ≤ r1 ∧ r1 &lt; m ∧ a ≡ r1 (MOD m)</span>
<span id="cb60-33"><a href="#cb60-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : 0 ≤ r2 ∧ r2 &lt; m ∧ a ≡ r2 (MOD m)</span>
<span id="cb60-34"><a href="#cb60-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : r1 ≡ r2 (MOD m) :=</span>
<span id="cb60-35"><a href="#cb60-35" aria-hidden="true" tabindex="-1"></a>      congr_trans (congr_symm h1.right.right) h2.right.right</span>
<span id="cb60-36"><a href="#cb60-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (d : Int) (h4 : r1 - r2 = m * d) <span class="kw">from</span> h3</span>
<span id="cb60-37"><a href="#cb60-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h5 : r1 - r2 &lt; m * 1 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb60-38"><a href="#cb60-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h6 : m * (-1) &lt; r1 - r2 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb60-39"><a href="#cb60-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h4] <span class="kw">at</span> h5   <span class="co">--h5 : m * d &lt; m * 1</span></span>
<span id="cb60-40"><a href="#cb60-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h4] <span class="kw">at</span> h6   <span class="co">--h6 : m * -1 &lt; m * d</span></span>
<span id="cb60-41"><a href="#cb60-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h7 : (↑m : Int) ≥ 0 := Nat.cast_nonneg m</span>
<span id="cb60-42"><a href="#cb60-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h8 : d &lt; 1 := lt_of_mul_lt_mul_of_nonneg_left h5 h7</span>
<span id="cb60-43"><a href="#cb60-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h9 : -1 &lt; d := lt_of_mul_lt_mul_of_nonneg_left h6 h7</span>
<span id="cb60-44"><a href="#cb60-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h10 : d = 0 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb60-45"><a href="#cb60-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> r1 = r2 <span class="kw">from</span></span>
<span id="cb60-46"><a href="#cb60-46" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> r1</span>
<span id="cb60-47"><a href="#cb60-47" aria-hidden="true" tabindex="-1"></a>        _ = r1 - r2 + r2 := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb60-48"><a href="#cb60-48" aria-hidden="true" tabindex="-1"></a>        _ = m * 0 + r2 := <span class="kw">by</span> <span class="kw">rw</span> [h4, h10]</span>
<span id="cb60-49"><a href="#cb60-49" aria-hidden="true" tabindex="-1"></a>        _ = r2 := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb60-50"><a href="#cb60-50" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb60-51"><a href="#cb60-51" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The lemma <code>mod_cmpl_res</code> above says that <code>a % m</code> is an element of the complete residue system <code>{0, 1, ..., m - 1}</code> that is congruent to <code>a</code> modulo <code>m</code>. The lemma requires the hypothesis <code>[NeZero m]</code>, because its proof appeals to two previous lemmas, <code>mod_nonneg</code> and <code>mod_lt</code>, that require that hypothesis. But when the proof invokes those previous lemmas, this hypothesis is not mentioned, because it is an implicit argument.</p>
<p>An immediate consequence of the lemma <code>congr_mod_mod</code> is the following lemma, which will be useful to us later.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> cc_eq_mod (m : Nat) (a : Int) : [a]_m = [a % m]_m := </span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>  (cc_eq_iff_congr m a (a % m)).rtl (congr_mod_mod m a)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Theorem 7.3.6 in <em>HTPI</em> states a number of algebraic properties of modular arithmetic. These properties all follow easily from the theorems we have already stated. To illustrate this, we prove two parts of the theorem.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_3_6_1 {m : Nat} (X Y : ZMod m) : X + Y = Y + X := <span class="kw">by</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : Int) (h1 : X = [a]_m) <span class="kw">from</span> cc_rep X</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (b : Int) (h2 : Y = [b]_m) <span class="kw">from</span> cc_rep Y</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h1, h2]</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : a + b = b + a := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> [a]_m + [b]_m = [b]_m + [a]_m <span class="kw">from</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> [a]_m + [b]_m</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>      _ = [a + b]_m := add_class m a b</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>      _ = [b + a]_m := <span class="kw">by</span> <span class="kw">rw</span> [h3]</span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>      _ = [b]_m + [a]_m := (add_class m b a).symm</span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_3_6_7 {m : Nat} (X : ZMod m) : X * [1]_m = X := <span class="kw">by</span></span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : Int) (h1 : X = [a]_m) <span class="kw">from</span> cc_rep X</span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h1]</span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : a * 1 = a := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> [a]_m * [1]_m = [a]_m <span class="kw">from</span></span>
<span id="cb62-18"><a href="#cb62-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> [a]_m * [1]_m</span>
<span id="cb62-19"><a href="#cb62-19" aria-hidden="true" tabindex="-1"></a>      _ = [a * 1]_m := mul_class m a 1</span>
<span id="cb62-20"><a href="#cb62-20" aria-hidden="true" tabindex="-1"></a>      _ = [a]_m := <span class="kw">by</span> <span class="kw">rw</span> [h2]</span>
<span id="cb62-21"><a href="#cb62-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>Theorem_7_3_6_7</code> shows that <code>[1]_m</code> is the multiplicative identity element for <code>ZMod m</code>. We say that a congruence class <code>Y</code> is a <em>multiplicative inverse</em> of another class <code>X</code> if <code>X * Y = [1]_m</code>, and a congruence class is <em>invertible</em> if it has a multiplicative inverse:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> invertible {m : Nat} (X : ZMod m) : <span class="kw">Prop</span> :=</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>  ∃ (Y : ZMod m), X * Y = [1]_m</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Which congruence classes are invertible? The answer is given by Theorem 7.3.7 in <em>HTPI</em>, which says that if <span class="math inline">\(a\)</span> is a positive integer, then <span class="math inline">\([a]_m\)</span> is invertible if and only if <span class="math inline">\(m\)</span> and <span class="math inline">\(a\)</span> are relatively prime. The proof uses an exercise from the last section. Here is the Lean version of the proof.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_7_2_6 (a b : Nat) :</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>    rel_prime a b ↔ ∃ (s t : Int), s * a + t * b = 1 := <span class="cn">sorry</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> gcd_c2_inv {m a : Nat} (h1 : rel_prime m a) :</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>    [a]_m * [gcd_c2 m a]_m = [1]_m := <span class="kw">by</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> s : Int := gcd_c1 m a</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : s * m + (gcd_c2 m a) * a = gcd m a := gcd_lin_comb a m</span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h1, Nat.cast_one] <span class="kw">at</span> h2  <span class="co">--h2 : s * ↑m + gcd_c2 m a * ↑a = 1</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [mul_class, cc_eq_iff_congr]</span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>     <span class="co">--Goal : ∃ (c : Int), ↑a * gcd_c2 m a - 1 = ↑m * c</span></span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (-s)</span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a * (gcd_c2 m a) - 1 = m * (-s) <span class="kw">from</span></span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> a * (gcd_c2 m a) - 1</span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>      _ = s * m + (gcd_c2 m a) * a + m * (-s) - 1 := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a>      _ = 1 + m * (-s) - 1 := <span class="kw">by</span> <span class="kw">rw</span> [h2]</span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a>      _ = m * (-s) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_3_7 (m a : Nat) :</span>
<span id="cb64-21"><a href="#cb64-21" aria-hidden="true" tabindex="-1"></a>    invertible [a]_m ↔ rel_prime m a := <span class="kw">by</span></span>
<span id="cb64-22"><a href="#cb64-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb64-23"><a href="#cb64-23" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb64-24"><a href="#cb64-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : invertible [a]_m</span>
<span id="cb64-25"><a href="#cb64-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb64-26"><a href="#cb64-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (Y : ZMod m) (h2 : [a]_m * Y = [1]_m) <span class="kw">from</span> h1</span>
<span id="cb64-27"><a href="#cb64-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (b : Int) (h3 : Y = [b]_m) <span class="kw">from</span> cc_rep Y</span>
<span id="cb64-28"><a href="#cb64-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h3, mul_class, cc_eq_iff_congr] <span class="kw">at</span> h2</span>
<span id="cb64-29"><a href="#cb64-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h2</span>
<span id="cb64-30"><a href="#cb64-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (c : Int) (h4 : a * b - 1 = m * c) <span class="kw">from</span> h2</span>
<span id="cb64-31"><a href="#cb64-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [Exercise_7_2_6]</span>
<span id="cb64-32"><a href="#cb64-32" aria-hidden="true" tabindex="-1"></a>      <span class="co">--Goal : ∃ (s t : Int), s * ↑m + t * ↑a = 1</span></span>
<span id="cb64-33"><a href="#cb64-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro (-c)</span>
<span id="cb64-34"><a href="#cb64-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro b</span>
<span id="cb64-35"><a href="#cb64-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> (-c) * m + b * a = 1 <span class="kw">from</span></span>
<span id="cb64-36"><a href="#cb64-36" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> (-c) * m + b * a</span>
<span id="cb64-37"><a href="#cb64-37" aria-hidden="true" tabindex="-1"></a>        _ = (-c) * m + (a * b - 1) + 1 := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb64-38"><a href="#cb64-38" aria-hidden="true" tabindex="-1"></a>        _ = (-c) * m + m * c + 1 := <span class="kw">by</span> <span class="kw">rw</span> [h4]</span>
<span id="cb64-39"><a href="#cb64-39" aria-hidden="true" tabindex="-1"></a>        _ = 1 := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb64-40"><a href="#cb64-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb64-41"><a href="#cb64-41" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb64-42"><a href="#cb64-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : rel_prime m a</span>
<span id="cb64-43"><a href="#cb64-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb64-44"><a href="#cb64-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ∃ (Y : ZMod m), [a]_m * Y = [1]_m <span class="kw">from</span></span>
<span id="cb64-45"><a href="#cb64-45" aria-hidden="true" tabindex="-1"></a>      Exists.intro [gcd_c2 m a]_m (gcd_c2_inv h1)</span>
<span id="cb64-46"><a href="#cb64-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb64-47"><a href="#cb64-47" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="exercises-2" class="level3">
<h3 class="anchored" data-anchor-id="exercises-2">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb65"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> congr_trans {m : Nat} : ∀ {a b c : Int},</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    a ≡ b (MOD m) → b ≡ c (MOD m) → a ≡ c (MOD m) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb66"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_3_6_3 {m : Nat} (X : ZMod m) : X + [0]_m = X := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb67"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_3_6_4 {m : Nat} (X : ZMod m) :</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>    ∃ (Y : ZMod m), X + Y = [0]_m := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb68"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_7_3_4a {m : Nat} (Z1 Z2 : ZMod m)</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ (X : ZMod m), X + Z1 = X)</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ∀ (X : ZMod m), X + Z2 = X) : Z1 = Z2 := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb69"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_7_3_4b {m : Nat} (X Y1 Y2 : ZMod m)</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>    (h1 : X + Y1 = [0]_m) (h2 : X + Y2 = [0]_m) : Y1 = Y2 := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="6">
<div class="sourceCode" id="cb70"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_3_10 (m a : Nat) (b : Int) :</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>    ¬(↑(gcd m a) : Int) ∣ b → ¬∃ (x : Int), a * x ≡ b (MOD m) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="7">
<div class="sourceCode" id="cb71"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_3_11 (m n : Nat) (a b : Int) (h1 : n ≠ 0) :</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>    n * a ≡ n * b (MOD n * m) ↔ a ≡ b (MOD m) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="8">
<div class="sourceCode" id="cb72"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_7_3_16 {m : Nat} {a b : Int} (h : a ≡ b (MOD m)) :</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), a ^ n ≡ b ^ n (MOD m) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="9">
<div class="sourceCode" id="cb73"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {m : Nat} [NeZero m] (X : ZMod m) :</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>    ∃! (a : Int), 0 ≤ a ∧ a &lt; m ∧ X = [a]_m := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="10">
<div class="sourceCode" id="cb74"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> congr_rel_prime {m a b : Nat} (h1 : a ≡ b (MOD m)) :</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>    rel_prime m a ↔ rel_prime m b := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="11">
<div class="sourceCode" id="cb75"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint: You may find the theorem Int.ofNat_mod_ofNat useful.</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> rel_prime_mod (m a : Nat) :</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>    rel_prime m (a % m) ↔ rel_prime m a := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="12">
<div class="sourceCode" id="cb76"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> congr_iff_mod_eq_Int (m : Nat) (a b : Int) [NeZero m] :</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>    a ≡ b (MOD m) ↔ a % ↑m = b % ↑m := <span class="cn">sorry</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint for next theorem: Use the lemma above,</span></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a><span class="co">--together with the theorems Int.ofNat_mod_ofNat and Nat.cast_inj.</span></span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> congr_iff_mod_eq_Nat (m a b : Nat) [NeZero m] :</span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>    ↑a ≡ ↑b (MOD m) ↔ a % m = b % m := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="eulers-theorem" class="level2">
<h2 class="anchored" data-anchor-id="eulers-theorem">7.4. Euler’s Theorem</h2>
<p>The main result of Section 7.4 of <em>HTPI</em> is Euler’s theorem. The statement of the theorem involves Euler’s totient function <span class="math inline">\(\varphi\)</span>. For any positive integer <span class="math inline">\(m\)</span>, <em>HTPI</em> defines <span class="math inline">\(\varphi(m)\)</span> to be the number of elements of <span class="math inline">\(\mathbb{Z}/{\equiv_m}\)</span> that have multiplicative inverses. In order to state and prove Euler’s theorem in Lean, our first task is to define a Lean function <code>phi : Nat → Nat</code> that computes the totient function.</p>
<p>Since <code>{0, 1, ..., m - 1}</code> is a complete residue system modulo <code>m</code>, <code>phi m</code> can be described as the number of natural numbers <code>a &lt; m</code> such that <code>[a]_m</code> is invertible. According to <code>Theorem_7_3_7</code>, <code>[a]_m</code> is invertible if and only if <code>m</code> and <code>a</code> are relatively prime, so <code>phi m</code> is also equal to the number of natural numbers <code>a &lt; m</code> that are relatively prime to <code>m</code>. We begin by defining a function <code>num_rp_below m k</code> that counts the number of natural numbers less than <code>k</code> that are relatively prime to <code>m</code>.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> num_rp_below (m k : Nat) : Nat :=</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> k <span class="kw">with</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; 0</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>    | j + 1 =&gt; if gcd m j = 1 then (num_rp_below m j) + 1</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>                else num_rp_below m j</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This is the first time we have used an <code>if ... then ... else</code> expression in a Lean definition. To prove theorems about such expressions, we will need two theorems from Lean’s library, <code>if_pos</code> and <code>if_neg</code>. The <code>#check</code> command tells us what they say:</p>
<div class="ind">
<pre><code>@if_pos : ∀ {c : Prop} {h : Decidable c},
          c → ∀ {α : Sort u_1} {t e : α}, (if c then t else e) = t
          
@if_neg : ∀ {c : Prop} {h : Decidable c},
          ¬c → ∀ {α : Sort u_1} {t e : α}, (if c then t else e) = e</code></pre>
</div>
<p>Ignoring the implicit arguments, this tells us that if <code>hc</code> is a proof of a proposition <code>c</code>, then <code>if_pos hc</code> is a proof of <code>(if c then t else e) = t</code>, and if <code>hnc</code> is a proof of <code>¬c</code>, then <code>if_neg hnc</code> is a proof of <code>(if c then t else e) = e</code>. (Technically, the implicit arguments say that <code>c</code> must be a “decidable” proposition, but we won’t worry about that detail.) We often use these theorems to evaluate an expression of the form <code>if c then t else e</code> as either <code>t</code> or <code>e</code>, depending on whether <code>c</code> is true or false.</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> num_rp_below_base {m : Nat} :</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>    num_rp_below m 0 = 0 := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> num_rp_below_step_rp {m j : Nat} (h : rel_prime m j) :</span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>    num_rp_below m (j + 1) = (num_rp_below m j) + 1 := if_pos h</span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> num_rp_below_step_not_rp {m j : Nat} (h : ¬rel_prime m j) :</span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>    num_rp_below m (j + 1) = num_rp_below m j := if_neg h</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We can now use <code>num_rp_below</code> to define the totient function.</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> phi (m : Nat) : Nat := num_rp_below m m</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> phi_def (m : Nat) : phi m = num_rp_below m m := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a><span class="kw">#eval</span> phi 10   <span class="co">--Answer: 4</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With this preparation, we can now state the theorem we will prove:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_4_2 {m a : Nat} [NeZero m] (h1 : rel_prime m a) :</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>    [a]_m ^ (phi m) = [1]_m</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In preparation for proving this theorem, <em>HTPI</em> first shows that the set of invertible congruence classes is closed under inverses and multiplication. For our purposes, we will find it useful to prove a slightly different lemma. Note that Lean knows all of the basic algebraic laws of addition and multiplication of congruence classes, and as a result the <code>ring</code> tactic can be used to do algebraic reasoning in <code>ZMod m</code>, as illustrated in the proof below.</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> prod_inv_iff_inv {m : Nat} {X : ZMod m}</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>    (h1 : invertible X) (Y : ZMod m) :</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>    invertible (X * Y) ↔ invertible Y := <span class="kw">by</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : invertible (X * Y)</span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (Z : ZMod m) (h3 : X * Y * Z = [1]_m) <span class="kw">from</span> h2</span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro (X * Z)</span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←h3]  <span class="co">--Goal : Y * (X * Z) = X * Y * Z</span></span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">ring</span>     <span class="co">--Note that ring can do algebra in ZMod m</span></span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : invertible Y</span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (Xi : ZMod m) (h3 : X * Xi = [1]_m) <span class="kw">from</span> h1</span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (Yi : ZMod m) (h4 : Y * Yi = [1]_m) <span class="kw">from</span> h2</span>
<span id="cb82-16"><a href="#cb82-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro (Xi * Yi)</span>
<span id="cb82-17"><a href="#cb82-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> (X * Y) * (Xi * Yi) = [1]_m <span class="kw">from</span></span>
<span id="cb82-18"><a href="#cb82-18" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> X * Y * (Xi * Yi)</span>
<span id="cb82-19"><a href="#cb82-19" aria-hidden="true" tabindex="-1"></a>        _ = (X * Xi) * (Y * Yi) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb82-20"><a href="#cb82-20" aria-hidden="true" tabindex="-1"></a>        _ = [1]_m * [1]_m := <span class="kw">by</span> <span class="kw">rw</span> [h3, h4]</span>
<span id="cb82-21"><a href="#cb82-21" aria-hidden="true" tabindex="-1"></a>        _ = [1]_m := Theorem_7_3_6_7 [1]_m</span>
<span id="cb82-22"><a href="#cb82-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb82-23"><a href="#cb82-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>One of the key ideas in the proof of Theorem 7.4.2 in <em>HTPI</em> involves computing the product of all invertible congruence classes. To compute this product in Lean, we begin by defining a function <code>F m : Nat → ZMod m</code> as follows:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> F (m i : Nat) : ZMod m := if gcd m i = 1 then [i]_m else [1]_m</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> F_rp_def {m i : Nat} (h : rel_prime m i) :</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>    F m i = [i]_m := if_pos h</span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> F_not_rp_def {m i : Nat} (h : ¬rel_prime m i) :</span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>    F m i = [1]_m := if_neg h</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Note that <code>F</code> is defined as a function of two natural numbers, <code>m</code> and <code>i</code>, but as we discussed in Section 5.4, it follows that the partial application <code>F m</code> is a function from <code>Nat</code> to <code>ZMod m</code>.</p>
<p>Now consider the product <code>(F m 0) * (F m 1) * ... * (F m (m - 1))</code>; we will call this the <em><code>F</code>-product</em>. If <code>m</code> and <code>i</code> are not relatively prime, then <code>F m i = [1]_m</code>, and since <code>[1]_m</code> is the multiplicative identity element of <code>ZMod m</code>, the factor <code>F m i</code> contributes nothing to the product. Thus, the <code>F</code>-product is equal to the product of the factors <code>F m i</code> for which <code>m</code> and <code>i</code> are relatively prime. But for those values of <code>i</code>, <code>F m i = [i]_m</code>, so the product is equal to the product of all congruence classes <code>[i]_m</code> with <code>m</code> and <code>i</code> relatively prime. By <code>Theorem_7_3_7</code>, that is the product of all invertible congruence classes.</p>
<p>To express the <code>F</code>-product in Lean, we imitate our approach to summations, as described in Chapter 6. We begin by defining <code>prod_seq j k f</code> to be the product of a sequence of <code>j</code> consecutive values of the function <code>f</code>, starting with <code>f k</code>:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prod_seq {m : Nat}</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>    (j k : Nat) (f : Nat → ZMod m) : ZMod m :=</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> j <span class="kw">with</span></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; [1]_m</span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>    | n + 1 =&gt; prod_seq n k f * f (k + n)</span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> prod_seq_base {m : Nat}</span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a>    (k : Nat) (f : Nat → ZMod m) : prod_seq 0 k f = [1]_m := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> prod_seq_step {m : Nat}</span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a>    (n k : Nat) (f : Nat → ZMod m) :</span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a>    prod_seq (n + 1) k f = prod_seq n k f * f (k + n) := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-14"><a href="#cb84-14" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> prod_seq_zero_step {m : Nat}</span>
<span id="cb84-15"><a href="#cb84-15" aria-hidden="true" tabindex="-1"></a>    (n : Nat) (f : Nat → ZMod m) :</span>
<span id="cb84-16"><a href="#cb84-16" aria-hidden="true" tabindex="-1"></a>    prod_seq (n + 1) 0 f = prod_seq n 0 f * f n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Using this notation, the expression <code>prod_seq m 0 (F m)</code> denotes the <code>F</code>-product, which, as we saw earlier, is equal to the product of the invertible congruence classes.</p>
<p>Now suppose <code>a</code> is a natural number that is relatively prime to <code>m</code>. The next step in the proof in <em>HTPI</em> is to multiply each factor in the product of the invertible congruence classes by <code>[a]_m</code>. To do this, we define a function <code>G</code> as follows:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> G (m a i : Nat) : Nat := (a * i) % m</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Consider the following product, which we will call the <em><code>FG</code>-product</em>:</p>
<div class="ind">
<pre><code>(F m (G m a 0)) * (F m (G m a 1)) * ... * (F m (G m a (m - 1))).</code></pre>
</div>
<p>Using the partial application <code>G m a</code>, which is a function from <code>Nat</code> to <code>Nat</code>, we can express this in Lean as <code>prod_seq m 0 ((F m) ∘ (G m a))</code>. To understand this product we will need two facts about <code>G</code>.</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> cc_G (m a i : Nat) : [G m a i]_m = [a]_m * [i]_m :=</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">calc</span> [G m a i]_m</span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>    _ = [(a * i) % m]_m := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>    _ = [a * i]_m := (cc_eq_mod m (a * i)).symm</span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>    _ = [a]_m * [i]_m := (mul_class m a i).symm</span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> G_rp_iff {m a : Nat} (h1 : rel_prime m a) (i : Nat) :</span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>    rel_prime m (G m a i) ↔ rel_prime m i := <span class="kw">by</span></span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : invertible [a]_m := (Theorem_7_3_7 m a).rtl h1</span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> rel_prime m (G m a i) ↔ rel_prime m i <span class="kw">from</span></span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> rel_prime m (G m a i)</span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a>      _ ↔ invertible [G m a i]_m := (Theorem_7_3_7 m (G m a i)).symm</span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a>      _ ↔ invertible ([a]_m * [i]_m) := <span class="kw">by</span> <span class="kw">rw</span> [cc_G]</span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a>      _ ↔ invertible [i]_m := prod_inv_iff_inv h2 ([i]_m)</span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a>      _ ↔ rel_prime m i := Theorem_7_3_7 m i</span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now let’s analyze the <code>FG</code>-product. If <code>i</code> is not relatively prime to <code>m</code>, then by <code>G_rp_iff</code>, <code>G m a i</code> is also not relatively prime to <code>m</code>, so <code>F m (G m a i) = [1]_m</code>. As before, this means that these terms contribute nothing to the <code>FG</code>-product. If <code>i</code> is relatively prime to <code>m</code>, then so is <code>G m a i</code>, and therefore, by <code>cc_G</code>,</p>
<div class="ind">
<pre><code>F m (G m a i) = [G m a i]_m = [a]_m * [i]_m = [a]_m * (F m i).</code></pre>
</div>
<p>This means that, in the <code>FG</code>-product, each factor contributed by a value of <code>i</code> that is relatively prime to <code>m</code> is <code>[a]_m</code> times the corresponding factor in the <code>F</code>-product. Since the number of such factors is <code>phi m</code>, it follows that the <code>FG</code>-product is <code>[a]_m ^ (phi m)</code> times the <code>F</code>-product.</p>
<p>Let’s see if we can prove this in Lean.</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> FG_rp {m a i : Nat} (h1 : rel_prime m a) (h2 : rel_prime m i) :</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>    F m (G m a i) = [a]_m * F m i := <span class="kw">by</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : rel_prime m (G m a i) := (G_rp_iff h1 i).rtl h2</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> F m (G m a i) = [a]_m * F m i <span class="kw">from</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> F m (G m a i)</span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>      _ = [G m a i]_m := F_rp_def h3</span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a>      _ = [a]_m * [i]_m := cc_G m a i</span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a>      _ = [a]_m * F m i := <span class="kw">by</span> <span class="kw">rw</span> [F_rp_def h2]</span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> FG_not_rp {m a i : Nat} (h1 : rel_prime m a) (h2 : ¬rel_prime m i) :</span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a>    F m (G m a i) = [1]_m := <span class="cn">sorry</span></span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-14"><a href="#cb89-14" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> FG_prod {m a : Nat} (h1 : rel_prime m a) :</span>
<span id="cb89-15"><a href="#cb89-15" aria-hidden="true" tabindex="-1"></a>    ∀ (k : Nat), prod_seq k 0 ((F m) ∘ (G m a)) =</span>
<span id="cb89-16"><a href="#cb89-16" aria-hidden="true" tabindex="-1"></a>      [a]_m ^ (num_rp_below m k) * prod_seq k 0 (F m) := <span class="kw">by</span></span>
<span id="cb89-17"><a href="#cb89-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb89-18"><a href="#cb89-18" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb89-19"><a href="#cb89-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> prod_seq 0 0 ((F m) ∘ (G m a)) =</span>
<span id="cb89-20"><a href="#cb89-20" aria-hidden="true" tabindex="-1"></a>          [a]_m ^ (num_rp_below m 0) * prod_seq 0 0 (F m) <span class="kw">from</span></span>
<span id="cb89-21"><a href="#cb89-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> prod_seq 0 0 ((F m) ∘ (G m a))</span>
<span id="cb89-22"><a href="#cb89-22" aria-hidden="true" tabindex="-1"></a>        _ = [1]_m := prod_seq_base _ _</span>
<span id="cb89-23"><a href="#cb89-23" aria-hidden="true" tabindex="-1"></a>        _ = [a]_m ^ 0 * [1]_m := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb89-24"><a href="#cb89-24" aria-hidden="true" tabindex="-1"></a>        _ = [a]_m ^ (num_rp_below m 0) * prod_seq 0 0 (F m) := <span class="kw">by</span></span>
<span id="cb89-25"><a href="#cb89-25" aria-hidden="true" tabindex="-1"></a>              <span class="kw">rw</span> [num_rp_below_base, prod_seq_base]</span>
<span id="cb89-26"><a href="#cb89-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb89-27"><a href="#cb89-27" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb89-28"><a href="#cb89-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> k : Nat</span>
<span id="cb89-29"><a href="#cb89-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : prod_seq k 0 ((F m) ∘ (G m a)) =</span>
<span id="cb89-30"><a href="#cb89-30" aria-hidden="true" tabindex="-1"></a>      [a]_m ^ (num_rp_below m k) * prod_seq k 0 (F m)</span>
<span id="cb89-31"><a href="#cb89-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">by_cases</span> h2 : rel_prime m k</span>
<span id="cb89-32"><a href="#cb89-32" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 1. h2 : rel_prime m k</span></span>
<span id="cb89-33"><a href="#cb89-33" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> prod_seq (k + 1) 0 ((F m) ∘ (G m a)) =</span>
<span id="cb89-34"><a href="#cb89-34" aria-hidden="true" tabindex="-1"></a>          [a]_m ^ (num_rp_below m (k + 1)) *</span>
<span id="cb89-35"><a href="#cb89-35" aria-hidden="true" tabindex="-1"></a>          prod_seq (k + 1) 0 (F m) <span class="kw">from</span></span>
<span id="cb89-36"><a href="#cb89-36" aria-hidden="true" tabindex="-1"></a>        <span class="kw">calc</span> prod_seq (k + 1) 0 ((F m) ∘ (G m a))</span>
<span id="cb89-37"><a href="#cb89-37" aria-hidden="true" tabindex="-1"></a>          _ = prod_seq k 0 ((F m) ∘ (G m a)) *</span>
<span id="cb89-38"><a href="#cb89-38" aria-hidden="true" tabindex="-1"></a>              F m (G m a k) := prod_seq_zero_step _ _</span>
<span id="cb89-39"><a href="#cb89-39" aria-hidden="true" tabindex="-1"></a>          _ = [a]_m ^ (num_rp_below m k) * prod_seq k 0 (F m) *</span>
<span id="cb89-40"><a href="#cb89-40" aria-hidden="true" tabindex="-1"></a>              F m (G m a k) := <span class="kw">by</span> <span class="kw">rw</span> [ih]</span>
<span id="cb89-41"><a href="#cb89-41" aria-hidden="true" tabindex="-1"></a>          _ = [a]_m ^ (num_rp_below m k) * prod_seq k 0 (F m) *</span>
<span id="cb89-42"><a href="#cb89-42" aria-hidden="true" tabindex="-1"></a>              ([a]_m * F m k) := <span class="kw">by</span> <span class="kw">rw</span> [FG_rp h1 h2]</span>
<span id="cb89-43"><a href="#cb89-43" aria-hidden="true" tabindex="-1"></a>          _ = [a]_m ^ ((num_rp_below m k) + 1) *</span>
<span id="cb89-44"><a href="#cb89-44" aria-hidden="true" tabindex="-1"></a>              ((prod_seq k 0 (F m)) * F m k) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb89-45"><a href="#cb89-45" aria-hidden="true" tabindex="-1"></a>          _ = [a]_m ^ (num_rp_below m (k + 1)) *</span>
<span id="cb89-46"><a href="#cb89-46" aria-hidden="true" tabindex="-1"></a>              prod_seq (k + 1) 0 (F m) := <span class="kw">by</span></span>
<span id="cb89-47"><a href="#cb89-47" aria-hidden="true" tabindex="-1"></a>                <span class="kw">rw</span> [num_rp_below_step_rp h2, prod_seq_zero_step]</span>
<span id="cb89-48"><a href="#cb89-48" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb89-49"><a href="#cb89-49" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 2. h2 : ¬rel_prime m k</span></span>
<span id="cb89-50"><a href="#cb89-50" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> prod_seq (k + 1) 0 ((F m) ∘ (G m a)) =</span>
<span id="cb89-51"><a href="#cb89-51" aria-hidden="true" tabindex="-1"></a>          [a]_m ^ (num_rp_below m (k + 1)) *</span>
<span id="cb89-52"><a href="#cb89-52" aria-hidden="true" tabindex="-1"></a>          prod_seq (k + 1) 0 (F m) <span class="kw">from</span></span>
<span id="cb89-53"><a href="#cb89-53" aria-hidden="true" tabindex="-1"></a>        <span class="kw">calc</span> prod_seq (k + 1) 0 ((F m) ∘ (G m a))</span>
<span id="cb89-54"><a href="#cb89-54" aria-hidden="true" tabindex="-1"></a>          _ = prod_seq k 0 ((F m) ∘ (G m a)) *</span>
<span id="cb89-55"><a href="#cb89-55" aria-hidden="true" tabindex="-1"></a>              F m (G m a k) := prod_seq_zero_step _ _</span>
<span id="cb89-56"><a href="#cb89-56" aria-hidden="true" tabindex="-1"></a>          _ = [a]_m ^ (num_rp_below m k) * prod_seq k 0 (F m) *</span>
<span id="cb89-57"><a href="#cb89-57" aria-hidden="true" tabindex="-1"></a>              F m (G m a k) := <span class="kw">by</span> <span class="kw">rw</span> [ih]</span>
<span id="cb89-58"><a href="#cb89-58" aria-hidden="true" tabindex="-1"></a>          _ = [a]_m ^ (num_rp_below m k) * prod_seq k 0 (F m) *</span>
<span id="cb89-59"><a href="#cb89-59" aria-hidden="true" tabindex="-1"></a>              ([1]_m) := <span class="kw">by</span> <span class="kw">rw</span> [FG_not_rp h1 h2]</span>
<span id="cb89-60"><a href="#cb89-60" aria-hidden="true" tabindex="-1"></a>          _ = [a]_m ^ (num_rp_below m k) *</span>
<span id="cb89-61"><a href="#cb89-61" aria-hidden="true" tabindex="-1"></a>              (prod_seq k 0 (F m) * ([1]_m)) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb89-62"><a href="#cb89-62" aria-hidden="true" tabindex="-1"></a>          _ = [a]_m ^ (num_rp_below m (k + 1)) *</span>
<span id="cb89-63"><a href="#cb89-63" aria-hidden="true" tabindex="-1"></a>              prod_seq (k + 1) 0 (F m) := <span class="kw">by</span></span>
<span id="cb89-64"><a href="#cb89-64" aria-hidden="true" tabindex="-1"></a>                <span class="kw">rw</span> [num_rp_below_step_not_rp h2, prod_seq_zero_step,</span>
<span id="cb89-65"><a href="#cb89-65" aria-hidden="true" tabindex="-1"></a>                F_not_rp_def h2]</span>
<span id="cb89-66"><a href="#cb89-66" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb89-67"><a href="#cb89-67" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb89-68"><a href="#cb89-68" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The lemma <code>FG_prod</code>, in the case <code>k = m</code>, tells us that</p>
<div class="ind">
<pre><code>prod_seq m 0 ((F m) ∘ (G m a)) = [a]_m ^ (phi m) * prod_seq m 0 (F m).</code></pre>
</div>
<p>In other words, we have proven that the <code>FG</code>-product is <code>[a]_m ^ (phi m)</code> times the <code>F</code>-product.</p>
<p>And now we come to the central idea in the proof of <code>Theorem_7_4_2</code>: the congruence classes that are multiplied in the <code>FG</code>-product are exactly the same as the congruence classes multiplied in the <code>F</code>-product, but listed in a different order. The reason for this is that the function <code>G m a</code> permutes the natural numbers less than <code>m</code>. Since multiplication of congruence classes is commutative and associative, it follows that the <code>FG</code>-product and the <code>F</code>-product are equal.</p>
<p>To prove these claims, we first define what it means for a function to permute the natural numbers less than a natural number <code>n</code>.</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maps_below (n : Nat) (g : Nat → Nat) : <span class="kw">Prop</span> := ∀ i &lt; n, g i &lt; n</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> one_one_below (n : Nat) (g : Nat → Nat) : <span class="kw">Prop</span> :=</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>  ∀ i1 &lt; n, ∀ i2 &lt; n, g i1 = g i2 → i1 = i2</span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> onto_below (n : Nat) (g : Nat → Nat) : <span class="kw">Prop</span> :=</span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a>  ∀ k &lt; n, ∃ i &lt; n, g i = k</span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> perm_below (n : Nat) (g : Nat → Nat) : <span class="kw">Prop</span> :=</span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a>  maps_below n g ∧ one_one_below n g ∧ onto_below n g</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The proofs of our next two lemmas are somewhat long. We state them now, but put off discussion of their proofs until the end of the section. The first lemma says that, if <code>m</code> and <code>a</code> are relatively prime, then <code>G m a</code> permutes the natural numbers less than <code>m</code>, and the second says that permuting the terms of a product does not change the value of the product.</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> G_perm_below {m a : Nat} [NeZero m]</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>    (h1 : rel_prime m a) : perm_below m (G m a)</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> perm_prod {m : Nat} (f : Nat → ZMod m) :</span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), ∀ (g : Nat → Nat), perm_below n g →</span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>      prod_seq n 0 f = prod_seq n 0 (f ∘ g)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>There is just one more fact we need before we can prove <code>Theorem_7_4_2</code>: all of the factors in the <code>F</code>-product are invertible, and therefore the <code>F</code>-product is invertible:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> F_invertible (m i : Nat) : invertible (F m i) := <span class="kw">by</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> h : rel_prime m i</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h : rel_prime m i</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [F_rp_def h]</span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> invertible [i]_m <span class="kw">from</span> (Theorem_7_3_7 m i).rtl h</span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h : ¬rel_prime m i</span></span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [F_not_rp_def h]</span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro [1]_m</span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> [1]_m * [1]_m = [1]_m <span class="kw">from</span> Theorem_7_3_6_7 [1]_m</span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb93-13"><a href="#cb93-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-14"><a href="#cb93-14" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Fprod_invertible (m : Nat) :</span>
<span id="cb93-15"><a href="#cb93-15" aria-hidden="true" tabindex="-1"></a>    ∀ (k : Nat), invertible (prod_seq k 0 (F m)) := <span class="kw">by</span></span>
<span id="cb93-16"><a href="#cb93-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb93-17"><a href="#cb93-17" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb93-18"><a href="#cb93-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro [1]_m</span>
<span id="cb93-19"><a href="#cb93-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> prod_seq 0 0 (F m) * [1]_m = [1]_m <span class="kw">from</span></span>
<span id="cb93-20"><a href="#cb93-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> prod_seq 0 0 (F m) * [1]_m</span>
<span id="cb93-21"><a href="#cb93-21" aria-hidden="true" tabindex="-1"></a>        _ = [1]_m * [1]_m := <span class="kw">by</span> <span class="kw">rw</span> [prod_seq_base]</span>
<span id="cb93-22"><a href="#cb93-22" aria-hidden="true" tabindex="-1"></a>        _ = [1]_m := Theorem_7_3_6_7 ([1]_m)</span>
<span id="cb93-23"><a href="#cb93-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb93-24"><a href="#cb93-24" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb93-25"><a href="#cb93-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> k : Nat</span>
<span id="cb93-26"><a href="#cb93-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : invertible (prod_seq k 0 (F m))</span>
<span id="cb93-27"><a href="#cb93-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [prod_seq_zero_step]</span>
<span id="cb93-28"><a href="#cb93-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> invertible (prod_seq k 0 (F m) * (F m k)) <span class="kw">from</span></span>
<span id="cb93-29"><a href="#cb93-29" aria-hidden="true" tabindex="-1"></a>      (prod_inv_iff_inv ih (F m k)).rtl (F_invertible m k)</span>
<span id="cb93-30"><a href="#cb93-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb93-31"><a href="#cb93-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We now have everything we need to prove <code>Theorem_7_4_2</code>:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_4_2 {m a : Nat} [NeZero m] (h1 : rel_prime m a) :</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>    [a]_m ^ (phi m) = [1]_m := <span class="kw">by</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : invertible (prod_seq m 0 (F m)) := Fprod_invertible m m</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (Y : ZMod m) (h3 : prod_seq m 0 (F m) * Y = [1]_m) <span class="kw">from</span> h2</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> [a]_m ^ (phi m) = [1]_m <span class="kw">from</span></span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> [a]_m ^ (phi m)</span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a>      _ = [a]_m ^ (phi m) * [1]_m := (Theorem_7_3_6_7 _).symm</span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a>      _ = [a]_m ^ (phi m) * (prod_seq m 0 (F m) * Y) := <span class="kw">by</span> <span class="kw">rw</span> [h3]</span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a>      _ = ([a]_m ^ (phi m) * prod_seq m 0 (F m)) * Y := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb94-10"><a href="#cb94-10" aria-hidden="true" tabindex="-1"></a>      _ = prod_seq m 0 (F m ∘ G m a) * Y := <span class="kw">by</span> <span class="kw">rw</span> [FG_prod h1 m, phi_def]</span>
<span id="cb94-11"><a href="#cb94-11" aria-hidden="true" tabindex="-1"></a>      _ = prod_seq m 0 (F m) * Y := <span class="kw">by</span></span>
<span id="cb94-12"><a href="#cb94-12" aria-hidden="true" tabindex="-1"></a>            <span class="kw">rw</span> [perm_prod (F m) m (G m a) (G_perm_below h1)]</span>
<span id="cb94-13"><a href="#cb94-13" aria-hidden="true" tabindex="-1"></a>      _ = [1]_m := <span class="kw">by</span> <span class="kw">rw</span> [h3]</span>
<span id="cb94-14"><a href="#cb94-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Rephrasing this theorem in terms of numbers gives us the usual statement of Euler’s theorem:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Exercise_7_4_5_Int (m : Nat) (a : Int) :</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), [a]_m ^ n = [a ^ n]_m := <span class="cn">sorry</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Exercise_7_4_5_Nat (m a n : Nat) :</span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>    [a]_m ^ n = [a ^ n]_m := <span class="kw">by</span></span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [Exercise_7_4_5_Int]</span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rfl</span></span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb95-9"><a href="#cb95-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-10"><a href="#cb95-10" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Euler's_theorem {m a : Nat} [NeZero m]</span>
<span id="cb95-11"><a href="#cb95-11" aria-hidden="true" tabindex="-1"></a>    (h1 : rel_prime m a) : a ^ (phi m) ≡ 1 (MOD m) := <span class="kw">by</span></span>
<span id="cb95-12"><a href="#cb95-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : [a]_m ^ (phi m) = [1]_m := Theorem_7_4_2 h1</span>
<span id="cb95-13"><a href="#cb95-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [Exercise_7_4_5_Nat m a (phi m)] <span class="kw">at</span> h2</span>
<span id="cb95-14"><a href="#cb95-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">--h2 : [a ^ phi m]_m = [1]_m</span></span>
<span id="cb95-15"><a href="#cb95-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a ^ (phi m) ≡ 1 (MOD m) <span class="kw">from</span> (cc_eq_iff_congr _ _ _).ltr h2</span>
<span id="cb95-16"><a href="#cb95-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb95-17"><a href="#cb95-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-18"><a href="#cb95-18" aria-hidden="true" tabindex="-1"></a><span class="kw">#eval</span> gcd 10 7     <span class="co">--Answer: 1.  So 10 and 7 are relatively prime</span></span>
<span id="cb95-19"><a href="#cb95-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-20"><a href="#cb95-20" aria-hidden="true" tabindex="-1"></a><span class="kw">#eval</span> 7 ^ phi 10   <span class="co">--Answer: 2401, which is congruent to 1 mod 10.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We now turn to the two lemmas whose proofs we skipped over, <code>G_perm_below</code> and <code>perm_prod</code>. To prove <code>G_perm_below</code>, we must prove three facts: <code>maps_below m (G m a)</code>, <code>one_one_below m (G m a)</code>, and <code>onto_below m (G m a)</code>. The first is straightforward:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> G_maps_below (m a : Nat) [NeZero m] : maps_below m (G m a) := <span class="kw">by</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>             <span class="co">--Goal : ∀ i &lt; m, G m a i &lt; m</span></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> i : Nat</span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : i &lt; m</span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [G_def]    <span class="co">--Goal : a * i % m &lt; m</span></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a * i % m &lt; m <span class="kw">from</span> mod_nonzero_lt (a * i) (NeZero.ne m)</span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For the second and third, we start with lemmas that are reminiscent of Theorem 5.3.3.</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> right_inv_onto_below {n : Nat} {g g' : Nat → Nat}</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ i &lt; n, g (g' i) = i) (h2 : maps_below n g') :</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>    onto_below n g := <span class="kw">by</span></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2; <span class="kw">define</span></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> k : Nat</span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : k &lt; n</span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (g' k)</span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> g' k &lt; n ∧ g (g' k) = k <span class="kw">from</span> And.intro (h2 k h3) (h1 k h3)</span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-11"><a href="#cb97-11" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> left_inv_one_one_below {n : Nat} {g g' : Nat → Nat}</span>
<span id="cb97-12"><a href="#cb97-12" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ i &lt; n, g' (g i) = i) : one_one_below n g := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To apply these lemmas with <code>g = G m a</code>, we need a function to play the role of <code>g'</code>. A natural choice is <code>G m a'</code>, where <code>a'</code> is chosen so that <code>[a']_m</code> is the multiplicative inverse of <code>[a]_m</code>. We know from earlier work that if <code>m</code> and <code>a</code> are relatively prime then the multiplicative inverse of <code>[a]_m</code> is <code>[gcd_c2 m a]_m</code>. However, in the notation <code>G m a'</code>, we can’t let <code>a' = gcd_c2 m a</code>, because <code>a'</code> must be a natural number and <code>gcd_c2 a</code> is an integer. And we can’t simply coerce an integer to be a natural number—what if it’s negative? But we know <code>[gcd_c2 m a]_m = [(gcd_c2 m a) % m]_m</code> and <code>0 ≤ (gcd_c2 m a) % m</code>, and there is a function, <code>Int.toNat</code>, that will convert a nonnegative integer to a natural number. So we make the following definitions:</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> inv_mod (m a : Nat) : Nat := Int.toNat ((gcd_c2 m a) % m)</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Ginv (m a i : Nat) : Nat := G m (inv_mod m a) i</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now <code>Ginv m a</code> can play the role of <code>g'</code> in the last two lemmas. We’ll skip the details and just summarize the results.</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Ginv_right_inv {m a : Nat} [NeZero m] (h1 : rel_prime m a) :</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>    ∀ i &lt; m, G m a (Ginv m a i) = i := <span class="cn">sorry</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Ginv_left_inv {m a : Nat} [NeZero m] (h1 : rel_prime m a) :</span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>    ∀ i &lt; m, Ginv m a (G m a i) = i := <span class="cn">sorry</span></span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Ginv_maps_below (m a : Nat) [NeZero m] :</span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a>    maps_below m (Ginv m a) := G_maps_below m (inv_mod m a)</span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-10"><a href="#cb99-10" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> G_one_one_below {m a : Nat} [NeZero m] (h1 : rel_prime m a) :</span>
<span id="cb99-11"><a href="#cb99-11" aria-hidden="true" tabindex="-1"></a>    one_one_below m (G m a) :=</span>
<span id="cb99-12"><a href="#cb99-12" aria-hidden="true" tabindex="-1"></a>  left_inv_one_one_below (Ginv_left_inv h1)</span>
<span id="cb99-13"><a href="#cb99-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-14"><a href="#cb99-14" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> G_onto_below {m a : Nat} [NeZero m] (h1 : rel_prime m a) :</span>
<span id="cb99-15"><a href="#cb99-15" aria-hidden="true" tabindex="-1"></a>    onto_below m (G m a) :=</span>
<span id="cb99-16"><a href="#cb99-16" aria-hidden="true" tabindex="-1"></a>  right_inv_onto_below (Ginv_right_inv h1) (Ginv_maps_below m a)</span>
<span id="cb99-17"><a href="#cb99-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-18"><a href="#cb99-18" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> G_perm_below {m a : Nat} [NeZero m] (h1 : rel_prime m a) :</span>
<span id="cb99-19"><a href="#cb99-19" aria-hidden="true" tabindex="-1"></a>    perm_below m (G m a) := And.intro (G_maps_below m a)</span>
<span id="cb99-20"><a href="#cb99-20" aria-hidden="true" tabindex="-1"></a>  (And.intro (G_one_one_below h1) (G_onto_below h1))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, we turn to the proof of <code>perm_prod</code>. Our proof will be by mathematical induction. In the induction step, our induction hypothesis will be</p>
<div class="ind">
<pre><code>∀ (g : Nat → Nat), perm_below n g →
    prod_seq n 0 f = prod_seq n 0 (f ∘ g),</code></pre>
</div>
<p>and we will have to prove</p>
<div class="ind">
<pre><code>∀ (g : Nat → Nat), perm_below (n + 1) g →
    prod_seq (n + 1) 0 f = prod_seq (n + 1) 0 (f ∘ g).</code></pre>
</div>
<p>To prove this, we’ll introduce an arbitrary function <code>g : Nat → Nat</code> and assume <code>perm_below (n + 1) g</code>. How can we make use of the inductive hypothesis? Here’s the key idea: Since <code>g</code> permutes the numbers below <code>n + 1</code>, there must be some <code>u ≤ n</code> such that <code>g u = n</code>. Now let <code>s</code> be a function that swaps <code>u</code> and <code>n</code>, but leaves all other numbers fixed. In other words, <code>s u = n</code>, <code>s n = u</code>, and <code>s i = i</code> if <code>i ≠ u</code> and <code>i ≠ n</code>. It is not hard to show that <code>s</code> permutes the numbers below <code>n + 1</code>, and using that fact we can prove that <code>g ∘ s</code> permutes the numbers below <code>n + 1</code>. But notice that</p>
<div class="ind">
<pre><code>(g ∘ s) n = g (s n) = g u = n.</code></pre>
</div>
<p>In other words, <code>g ∘ s</code> leaves <code>n</code> fixed. Using that fact, we’ll be able to prove that <code>g ∘ s</code> permutes the numbers below <code>n</code>. We can therefore apply the inductive hypothesis to <code>g ∘ s</code>, which leads to the conclusion</p>
<div class="ind">
<pre><code>prod_seq n 0 f = prod_seq n 0 (f ∘ g ∘ s).</code></pre>
</div>
<p>Since we also have <code>(f ∘ g ∘ s) n = f ((g ∘ s) n) = f n</code>, we can extend this to</p>
<div class="ind">
<pre><code>prod_seq (n + 1) 0 f = prod_seq (n + 1) 0 (f ∘ g ∘ s).</code></pre>
</div>
<p>Finally, we can then reach the required conclusion by proving</p>
<div class="ind">
<pre><code>prod_seq (n + 1) 0 (f ∘ g ∘ s) = prod_seq (n + 1) 0 (f ∘ g).</code></pre>
</div>
<p>To carry out this plan, we begin by defining our “swapping” function and proving its properties.</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="kw">swap</span> (u v i : Nat) : Nat :=</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>  if i = u then v else if i = v then u else i</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> swap_fst (u v : Nat) : <span class="kw">swap</span> u v u = v := <span class="kw">by</span></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> : <span class="kw">swap</span> u v u</span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">--Goal : (if u = u then v else if u = v then u else u) = v</span></span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h : u = u := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [if_pos h]</span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rfl</span></span>
<span id="cb106-10"><a href="#cb106-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb106-11"><a href="#cb106-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-12"><a href="#cb106-12" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> swap_snd (u v : Nat) : <span class="kw">swap</span> u v v = u := <span class="cn">sorry</span></span>
<span id="cb106-13"><a href="#cb106-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-14"><a href="#cb106-14" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> swap_perm_below {u v n} (h1 : u &lt; n) (h2 : v &lt; n) :</span>
<span id="cb106-15"><a href="#cb106-15" aria-hidden="true" tabindex="-1"></a>    perm_below n (<span class="kw">swap</span> u v) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For the swapping function <code>s</code> in the proof outline above, we’ll use <code>swap u n</code>. To prove that <code>g ∘ swap u n</code> permutes the numbers below <code>n</code>, we’ll need two lemmas:</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> comp_perm_below {n : Nat} {f g : Nat → Nat}</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>    (h1 : perm_below n f) (h2 : perm_below n g) :</span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>    perm_below n (f ∘ g) := <span class="cn">sorry</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> perm_below_fixed {n : Nat} {g : Nat → Nat}</span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a>    (h1 : perm_below (n + 1) g) (h2 : g n = n) : perm_below n g := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For the final step of the proof, we’ll need several lemmas</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> break_prod_twice  {m u j n : Nat} (f : Nat → ZMod m)</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>    (h1 : n = u + 1 + j) : prod_seq (n + 1) 0 f =</span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a>      prod_seq u 0 f * f u * prod_seq j (u + 1) f * f n := <span class="cn">sorry</span></span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> swap_prod_eq_prod_below {m u n : Nat} (f : Nat → ZMod m)</span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a>    (h1 : u ≤ n) : prod_seq u 0 (f ∘ <span class="kw">swap</span> u n) = prod_seq u 0 f := <span class="cn">sorry</span></span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> swap_prod_eq_prod_between {m u j n : Nat} (f : Nat → ZMod m)</span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a>    (h1 : n = u + 1 + j) : prod_seq j (u + 1) (f ∘ <span class="kw">swap</span> u n) =</span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a>      prod_seq j (u + 1) f := <span class="cn">sorry</span></span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-12"><a href="#cb108-12" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> trivial_swap (u : Nat) : <span class="kw">swap</span> u u = id := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Using these lemmas, we can prove the fact we’ll need in the final step.</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> swap_prod_eq_prod {m u n : Nat} (f : Nat → ZMod m) (h1 : u ≤ n) :</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>    prod_seq (n + 1) 0 (f ∘ <span class="kw">swap</span> u n) = prod_seq (n + 1) 0 f := <span class="kw">by</span></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> h2 : u = n</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h2 : u = n</span></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h2, trivial_swap n]</span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a>      <span class="co">--Goal : prod_seq (n + 1) 0 (f ∘ id) = prod_seq (n + 1) 0 f</span></span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h2 : ¬u = n</span></span>
<span id="cb109-10"><a href="#cb109-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : u + 1 ≤ n := Nat.lt_of_le_of_ne h1 h2</span>
<span id="cb109-11"><a href="#cb109-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (j : Nat) (h4 : n = u + 1 + j) <span class="kw">from</span> Nat.exists_eq_add_of_le h3</span>
<span id="cb109-12"><a href="#cb109-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> break_f : prod_seq (n + 1) 0 f =</span>
<span id="cb109-13"><a href="#cb109-13" aria-hidden="true" tabindex="-1"></a>      prod_seq u 0 f * f u * prod_seq j (u + 1) f * f n :=</span>
<span id="cb109-14"><a href="#cb109-14" aria-hidden="true" tabindex="-1"></a>      break_prod_twice f h4</span>
<span id="cb109-15"><a href="#cb109-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> break_fs : prod_seq (n + 1) 0 (f ∘ <span class="kw">swap</span> u n) =</span>
<span id="cb109-16"><a href="#cb109-16" aria-hidden="true" tabindex="-1"></a>      prod_seq u 0 (f ∘ <span class="kw">swap</span> u n) * (f ∘ <span class="kw">swap</span> u n) u *</span>
<span id="cb109-17"><a href="#cb109-17" aria-hidden="true" tabindex="-1"></a>      prod_seq j (u + 1) (f ∘ <span class="kw">swap</span> u n) * (f ∘ <span class="kw">swap</span> u n) n :=</span>
<span id="cb109-18"><a href="#cb109-18" aria-hidden="true" tabindex="-1"></a>      break_prod_twice (f ∘ <span class="kw">swap</span> u n) h4</span>
<span id="cb109-19"><a href="#cb109-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> f_eq_fs_below : prod_seq u 0 (f ∘ <span class="kw">swap</span> u n) =</span>
<span id="cb109-20"><a href="#cb109-20" aria-hidden="true" tabindex="-1"></a>      prod_seq u 0 f := swap_prod_eq_prod_below f h1</span>
<span id="cb109-21"><a href="#cb109-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> f_eq_fs_btwn : prod_seq j (u + 1) (f ∘ <span class="kw">swap</span> u n) =</span>
<span id="cb109-22"><a href="#cb109-22" aria-hidden="true" tabindex="-1"></a>      prod_seq j (u + 1) f := swap_prod_eq_prod_between f h4</span>
<span id="cb109-23"><a href="#cb109-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> prod_seq (n + 1) 0 (f ∘ <span class="kw">swap</span> u n) = prod_seq (n + 1) 0 f <span class="kw">from</span></span>
<span id="cb109-24"><a href="#cb109-24" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> prod_seq (n + 1) 0 (f ∘ <span class="kw">swap</span> u n)</span>
<span id="cb109-25"><a href="#cb109-25" aria-hidden="true" tabindex="-1"></a>        _ = prod_seq u 0 (f ∘ <span class="kw">swap</span> u n) * (f ∘ <span class="kw">swap</span> u n) u *</span>
<span id="cb109-26"><a href="#cb109-26" aria-hidden="true" tabindex="-1"></a>            prod_seq j (u + 1) (f ∘ <span class="kw">swap</span> u n) * (f ∘ <span class="kw">swap</span> u n) n :=</span>
<span id="cb109-27"><a href="#cb109-27" aria-hidden="true" tabindex="-1"></a>              break_fs</span>
<span id="cb109-28"><a href="#cb109-28" aria-hidden="true" tabindex="-1"></a>        _ = prod_seq u 0 f * (f ∘ <span class="kw">swap</span> u n) u *</span>
<span id="cb109-29"><a href="#cb109-29" aria-hidden="true" tabindex="-1"></a>            prod_seq j (u + 1) f * (f ∘ <span class="kw">swap</span> u n) n := <span class="kw">by</span></span>
<span id="cb109-30"><a href="#cb109-30" aria-hidden="true" tabindex="-1"></a>              <span class="kw">rw</span> [f_eq_fs_below, f_eq_fs_btwn]</span>
<span id="cb109-31"><a href="#cb109-31" aria-hidden="true" tabindex="-1"></a>        _ = prod_seq u 0 f * f (<span class="kw">swap</span> u n u) *</span>
<span id="cb109-32"><a href="#cb109-32" aria-hidden="true" tabindex="-1"></a>            prod_seq j (u + 1) f * f (<span class="kw">swap</span> u n n) := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb109-33"><a href="#cb109-33" aria-hidden="true" tabindex="-1"></a>        _ = prod_seq u 0 f * f n * prod_seq j (u + 1) f * f u := <span class="kw">by</span></span>
<span id="cb109-34"><a href="#cb109-34" aria-hidden="true" tabindex="-1"></a>              <span class="kw">rw</span> [swap_fst, swap_snd]</span>
<span id="cb109-35"><a href="#cb109-35" aria-hidden="true" tabindex="-1"></a>        _ = prod_seq u 0 f * f u * prod_seq j (u + 1) f * f n := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb109-36"><a href="#cb109-36" aria-hidden="true" tabindex="-1"></a>        _ = prod_seq (n + 1) 0 f := break_f.symm</span>
<span id="cb109-37"><a href="#cb109-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb109-38"><a href="#cb109-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We finally have all the pieces in place to prove <code>perm_prod</code>:</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> perm_prod {m : Nat} (f : Nat → ZMod m) :</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), ∀ (g : Nat → Nat), perm_below n g →</span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>      prod_seq n 0 f = prod_seq n 0 (f ∘ g) := <span class="kw">by</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> g : Nat → Nat</span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : perm_below 0 g</span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [prod_seq_base, prod_seq_base]</span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb110-10"><a href="#cb110-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb110-11"><a href="#cb110-11" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb110-12"><a href="#cb110-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> n : Nat</span>
<span id="cb110-13"><a href="#cb110-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : ∀ (g : Nat → Nat), perm_below n g →</span>
<span id="cb110-14"><a href="#cb110-14" aria-hidden="true" tabindex="-1"></a>      prod_seq n 0 f = prod_seq n 0 (f ∘ g)</span>
<span id="cb110-15"><a href="#cb110-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> g : Nat → Nat</span>
<span id="cb110-16"><a href="#cb110-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> g_pb : perm_below (n + 1) g</span>
<span id="cb110-17"><a href="#cb110-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> g_pb</span>
<span id="cb110-18"><a href="#cb110-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> g_ob : onto_below (n + 1) g := g_pb.right.right</span>
<span id="cb110-19"><a href="#cb110-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> g_ob</span>
<span id="cb110-20"><a href="#cb110-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h1 : n &lt; n + 1 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb110-21"><a href="#cb110-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (u : Nat) (h2 : u &lt; n + 1 ∧ g u = n) <span class="kw">from</span> g_ob n h1</span>
<span id="cb110-22"><a href="#cb110-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> s_pb : perm_below (n + 1) (<span class="kw">swap</span> u n) :=</span>
<span id="cb110-23"><a href="#cb110-23" aria-hidden="true" tabindex="-1"></a>      swap_perm_below h2.left h1</span>
<span id="cb110-24"><a href="#cb110-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> gs_pb_n1 : perm_below (n + 1) (g ∘ <span class="kw">swap</span> u n) :=</span>
<span id="cb110-25"><a href="#cb110-25" aria-hidden="true" tabindex="-1"></a>      comp_perm_below g_pb s_pb</span>
<span id="cb110-26"><a href="#cb110-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> gs_fix_n : (g ∘ <span class="kw">swap</span> u n) n = n :=</span>
<span id="cb110-27"><a href="#cb110-27" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> (g ∘ <span class="kw">swap</span> u n) n</span>
<span id="cb110-28"><a href="#cb110-28" aria-hidden="true" tabindex="-1"></a>        _ = g (<span class="kw">swap</span> u n n) := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb110-29"><a href="#cb110-29" aria-hidden="true" tabindex="-1"></a>        _ = g u := <span class="kw">by</span> <span class="kw">rw</span> [swap_snd]</span>
<span id="cb110-30"><a href="#cb110-30" aria-hidden="true" tabindex="-1"></a>        _ = n := h2.right</span>
<span id="cb110-31"><a href="#cb110-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> gs_pb_n : perm_below n (g ∘ <span class="kw">swap</span> u n) :=</span>
<span id="cb110-32"><a href="#cb110-32" aria-hidden="true" tabindex="-1"></a>      perm_below_fixed gs_pb_n1 gs_fix_n</span>
<span id="cb110-33"><a href="#cb110-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> gs_prod : prod_seq n 0 f = prod_seq n 0 (f ∘ (g ∘ <span class="kw">swap</span> u n)) :=</span>
<span id="cb110-34"><a href="#cb110-34" aria-hidden="true" tabindex="-1"></a>      ih (g ∘ <span class="kw">swap</span> u n) gs_pb_n</span>
<span id="cb110-35"><a href="#cb110-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : u ≤ n := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb110-36"><a href="#cb110-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> prod_seq (n + 1) 0 f = prod_seq (n + 1) 0 (f ∘ g) <span class="kw">from</span></span>
<span id="cb110-37"><a href="#cb110-37" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> prod_seq (n + 1) 0 f</span>
<span id="cb110-38"><a href="#cb110-38" aria-hidden="true" tabindex="-1"></a>        _ = prod_seq n 0 f * f n := prod_seq_zero_step n f</span>
<span id="cb110-39"><a href="#cb110-39" aria-hidden="true" tabindex="-1"></a>        _ = prod_seq n 0 (f ∘ (g ∘ <span class="kw">swap</span> u n)) *</span>
<span id="cb110-40"><a href="#cb110-40" aria-hidden="true" tabindex="-1"></a>            f ((g ∘ <span class="kw">swap</span> u n) n) := <span class="kw">by</span> <span class="kw">rw</span> [gs_prod, gs_fix_n]</span>
<span id="cb110-41"><a href="#cb110-41" aria-hidden="true" tabindex="-1"></a>        _ = prod_seq n 0 (f ∘ g ∘ <span class="kw">swap</span> u n) *</span>
<span id="cb110-42"><a href="#cb110-42" aria-hidden="true" tabindex="-1"></a>            (f ∘ g ∘ <span class="kw">swap</span> u n) n := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb110-43"><a href="#cb110-43" aria-hidden="true" tabindex="-1"></a>        _ = prod_seq (n + 1) 0 (f ∘ g ∘ <span class="kw">swap</span> u n) :=</span>
<span id="cb110-44"><a href="#cb110-44" aria-hidden="true" tabindex="-1"></a>              (prod_seq_zero_step n (f ∘ g ∘ <span class="kw">swap</span> u n)).symm</span>
<span id="cb110-45"><a href="#cb110-45" aria-hidden="true" tabindex="-1"></a>        _ = prod_seq (n + 1) 0 ((f ∘ g) ∘ <span class="kw">swap</span> u n) := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb110-46"><a href="#cb110-46" aria-hidden="true" tabindex="-1"></a>        _ = prod_seq (n + 1) 0 (f ∘ g) := swap_prod_eq_prod (f ∘ g) h3</span>
<span id="cb110-47"><a href="#cb110-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb110-48"><a href="#cb110-48" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>There is one more theorem that is proven in Section 7.4 of <em>HTPI</em>: Theorem 7.4.4, which says that <span class="math inline">\(\varphi\)</span> is a multiplicative function. The proof requires ideas that we will not develop in Lean until Chapter 8, so we will put off the proof until Section 8.1½.</p>
<section id="exercises-3" class="level3">
<h3 class="anchored" data-anchor-id="exercises-3">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb111"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint:  Use induction.</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a><span class="co">--For the base case, compute [a]_m ^ 0 * [1]_m in two ways:</span></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a><span class="co">--by Theorem_7_3_6_7, [a] ^ 0 * [1]_m = [a]_m ^ 0</span></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a><span class="co">--by ring, [a]_m ^ 0 * [1]_m = [1]_m.</span></span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Exercise_7_4_5_Int (m : Nat) (a : Int) :</span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), [a]_m ^ n = [a ^ n]_m := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb112"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> left_inv_one_one_below {n : Nat} {g g' : Nat → Nat}</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∀ i &lt; n, g' (g i) = i) : one_one_below n g := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb113"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> comp_perm_below {n : Nat} {f g : Nat → Nat}</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>    (h1 : perm_below n f) (h2 : perm_below n g) :</span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>    perm_below n (f ∘ g) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb114"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> perm_below_fixed {n : Nat} {g : Nat → Nat}</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>    (h1 : perm_below (n + 1) g) (h2 : g n = n) : perm_below n g := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb115"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_7_4_6 {a b c : Nat} :</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>    rel_prime (a * b) c ↔ rel_prime a c ∧ rel_prime b c := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="6">
<div class="sourceCode" id="cb116"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {m a : Nat} [NeZero m] (h1 : rel_prime m a) :</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>    a ^ (phi m + 1) ≡ a (MOD m) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="7">
<div class="sourceCode" id="cb117"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Exercise_7_4_11 {m a p : Nat} [NeZero m]</span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>    (h1 : rel_prime m a) (h2 : p + 1 = phi m) :</span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>    [a]_m * [a ^ p]_m = [1]_m := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="8">
<div class="sourceCode" id="cb118"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Exercise_7_4_12 {m a p q k : Nat} [NeZero m]</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>    (h1 : rel_prime m a) (h2 : p = q + (phi m) * k) :</span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>    a ^ p ≡ a ^ q (MOD m) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="public-key-cryptography" class="level2">
<h2 class="anchored" data-anchor-id="public-key-cryptography">7.5. Public-Key Cryptography</h2>
<p>Section 7.5 of <em>HTPI</em> discusses the RSA public-key cryptography system. The system is based on the following theorem:</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_5_1 (p q n e d k m c : Nat)</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>    (p_prime : prime p) (q_prime : prime q) (p_ne_q : p ≠ q)</span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>    (n_pq : n = p * q) (ed_congr_1 : e * d = k * (p - 1) * (q - 1) + 1)</span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>    (h1 : [m]_n ^ e = [c]_n) : [c]_n ^ d = [m]_n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For an explanation of how the RSA system works and why <code>Theorem_7_5_1</code> justifies it, see <em>HTPI</em>. Here we will focus on proving the theorem in Lean.</p>
<p>We will be applying Euler’s theorem to the prime numbers <code>p</code> and <code>q</code>, so we will need to know how to compute <code>phi p</code> and <code>phi q</code>. Fortunately, there is a simple formula we can use.</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> num_rp_prime {p : Nat} (h1 : prime p) :</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>    ∀ k &lt; p, num_rp_below p (k + 1) = k := <span class="cn">sorry</span></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> phi_prime {p : Nat} (h1 : prime p) : phi p = p - 1 := <span class="kw">by</span></span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : 1 ≤ p := prime_pos h1</span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : p - 1 + 1 = p := Nat.sub_add_cancel h2</span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : p - 1 &lt; p := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : num_rp_below p (p - 1 + 1) = p - 1 :=</span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a>    num_rp_prime h1 (p - 1) h4</span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h3] <span class="kw">at</span> h5</span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> phi p = p - 1 <span class="kw">from</span> h5</span>
<span id="cb120-12"><a href="#cb120-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We will also need to use Lemma 7.4.5 from <em>HTPI</em>. To prove that lemma in Lean, we will use <code>Theorem_7_2_2</code>, which says that for natural numbers <code>a</code>, <code>b</code>, and <code>c</code>, if <code>c ∣ a * b</code> and <code>c</code> and <code>a</code> are relatively prime, then <code>c ∣ b</code>. But we will need to extend the theorem to allow <code>b</code> to be an integer rather than a natural number. To prove this extension, we use the Lean function <code>Int.natAbs : Int → Nat</code>, which computes the absolute value of an integer. Lean knows several theorems about this function:</p>
<div class="ind">
<pre><code>@Int.natCast_dvd : ∀ {n : ℤ} {m : ℕ}, ↑m ∣ n ↔ m ∣ Int.natAbs n

Int.natAbs_mul : ∀ (a b : ℤ),
                  Int.natAbs (a * b) = Int.natAbs a * Int.natAbs b

Int.natAbs_ofNat : ∀ (n : ℕ), Int.natAbs ↑n = n</code></pre>
</div>
<p>With the help of these theorems, our extended version of <code>Theorem_7_2_2</code> follows easily from the original version:</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_2_2_Int {a c : Nat} {b : Int}</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ↑c ∣ ↑a * b) (h2 : rel_prime a c) : ↑c ∣ b := <span class="kw">by</span></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [Int.natCast_dvd, Int.natAbs_mul,</span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a>    Int.natAbs_ofNat] <span class="kw">at</span> h1        <span class="co">--h1 : c ∣ a * Int.natAbs b</span></span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [Int.natCast_dvd]        <span class="co">--Goal : c ∣ Int.natAbs b</span></span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> c ∣ Int.natAbs b <span class="kw">from</span> Theorem_7_2_2 h1 h2</span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With that preparation, we can now prove <code>Lemma_7_4_5</code>.</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_7_4_5 {m n : Nat} (a b : Int) (h1 : rel_prime m n) :</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>    a ≡ b (MOD m * n) ↔ a ≡ b (MOD m) ∧ a ≡ b (MOD n) := <span class="kw">by</span></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : a ≡ b (MOD m * n)</span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (j : Int) (h3 : a - b = (m * n) * j) <span class="kw">from</span> h2</span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro</span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof of a ≡ b (MOD m)</span></span>
<span id="cb123-9"><a href="#cb123-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro (n * j)</span>
<span id="cb123-10"><a href="#cb123-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> a - b = m * (n * j) <span class="kw">from</span></span>
<span id="cb123-11"><a href="#cb123-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">calc</span> a - b</span>
<span id="cb123-12"><a href="#cb123-12" aria-hidden="true" tabindex="-1"></a>          _ = m * n * j := h3</span>
<span id="cb123-13"><a href="#cb123-13" aria-hidden="true" tabindex="-1"></a>          _ = m * (n * j) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb123-14"><a href="#cb123-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb123-15"><a href="#cb123-15" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof of a ≡ b (MOD n)</span></span>
<span id="cb123-16"><a href="#cb123-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro (m * j)</span>
<span id="cb123-17"><a href="#cb123-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> a - b = n * (m * j) <span class="kw">from</span></span>
<span id="cb123-18"><a href="#cb123-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">calc</span> a - b</span>
<span id="cb123-19"><a href="#cb123-19" aria-hidden="true" tabindex="-1"></a>          _ = m * n * j := h3</span>
<span id="cb123-20"><a href="#cb123-20" aria-hidden="true" tabindex="-1"></a>          _ = n * (m * j) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb123-21"><a href="#cb123-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb123-22"><a href="#cb123-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb123-23"><a href="#cb123-23" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb123-24"><a href="#cb123-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : a ≡ b (MOD m) ∧ a ≡ b (MOD n)</span>
<span id="cb123-25"><a href="#cb123-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (j : Int) (h3 : a - b = m * j) <span class="kw">from</span> h2.left</span>
<span id="cb123-26"><a href="#cb123-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : (↑n : Int) ∣ a - b := h2.right</span>
<span id="cb123-27"><a href="#cb123-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h3] <span class="kw">at</span> h4      <span class="co">--h4 : ↑n ∣ ↑m * j</span></span>
<span id="cb123-28"><a href="#cb123-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h5 : ↑n ∣ j := Theorem_7_2_2_Int h4 h1</span>
<span id="cb123-29"><a href="#cb123-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (k : Int) (h6 : j = n * k) <span class="kw">from</span> h5</span>
<span id="cb123-30"><a href="#cb123-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro k    <span class="co">--Goal : a - b = ↑(m * n) * k</span></span>
<span id="cb123-31"><a href="#cb123-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [Nat.cast_mul]  <span class="co">--Goal : a - b = ↑m * ↑n * k</span></span>
<span id="cb123-32"><a href="#cb123-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> a - b = (m * n) * k <span class="kw">from</span></span>
<span id="cb123-33"><a href="#cb123-33" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> a - b</span>
<span id="cb123-34"><a href="#cb123-34" aria-hidden="true" tabindex="-1"></a>        _ = m * j := h3</span>
<span id="cb123-35"><a href="#cb123-35" aria-hidden="true" tabindex="-1"></a>        _ = m * (n * k) := <span class="kw">by</span> <span class="kw">rw</span> [h6]</span>
<span id="cb123-36"><a href="#cb123-36" aria-hidden="true" tabindex="-1"></a>        _ = (m * n) * k := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb123-37"><a href="#cb123-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb123-38"><a href="#cb123-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, we will need an exercise from Section 7.2, and we will need to know <code>NeZero p</code> for prime numbers <code>p</code>:</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> rel_prime_symm {a b : Nat} (h : rel_prime a b) :</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>    rel_prime b a := <span class="cn">sorry</span></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> prime_NeZero {p : Nat} (h : prime p) : NeZero p := <span class="kw">by</span></span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [neZero_iff]     <span class="co">--Goal : p ≠ 0</span></span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h</span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">linarith</span></span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Much of the reasoning about modular arithmetic that we need for the proof of <code>Theorem_7_5_1</code> is contained in a technical lemma:</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_7_5_1 {p e d m c s : Nat} {t : Int}</span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>    (h1 : prime p) (h2 : e * d = (p - 1) * s + 1)</span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>    (h3 : m ^ e - c = p * t) :</span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a>    c ^ d ≡ m (MOD p) := <span class="kw">by</span></span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : m ^ e ≡ c (MOD p) := Exists.intro t h3</span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : [m ^ e]_p = [c]_p := (cc_eq_iff_congr _ _ _).rtl h4</span>
<span id="cb125-7"><a href="#cb125-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←Exercise_7_4_5_Nat] <span class="kw">at</span> h5  <span class="co">--h5 : [m]_p ^ e = [c]_p</span></span>
<span id="cb125-8"><a href="#cb125-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> h6 : p ∣ m</span>
<span id="cb125-9"><a href="#cb125-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h6 : p ∣ m</span></span>
<span id="cb125-10"><a href="#cb125-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h7 : m ≡ 0 (MOD p) := <span class="kw">by</span></span>
<span id="cb125-11"><a href="#cb125-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">obtain</span> (j : Nat) (h8 : m = p * j) <span class="kw">from</span> h6</span>
<span id="cb125-12"><a href="#cb125-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro (↑j : Int)   <span class="co">--Goal : ↑m - 0 = ↑p * ↑j</span></span>
<span id="cb125-13"><a href="#cb125-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [h8, Nat.cast_mul]</span>
<span id="cb125-14"><a href="#cb125-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">ring</span></span>
<span id="cb125-15"><a href="#cb125-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb125-16"><a href="#cb125-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h8 : [m]_p = [0]_p := (cc_eq_iff_congr _ _ _).rtl h7</span>
<span id="cb125-17"><a href="#cb125-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h9 : e * d ≠ 0 := <span class="kw">by</span></span>
<span id="cb125-18"><a href="#cb125-18" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [h2]</span>
<span id="cb125-19"><a href="#cb125-19" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> (p - 1) * s + 1 ≠ 0 <span class="kw">from</span> Nat.add_one_ne_zero _</span>
<span id="cb125-20"><a href="#cb125-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb125-21"><a href="#cb125-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h10 : (0 : Int) ^ (e * d) = 0 := zero_pow h9</span>
<span id="cb125-22"><a href="#cb125-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h11 : [c ^ d]_p = [m]_p :=</span>
<span id="cb125-23"><a href="#cb125-23" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> [c ^ d]_p</span>
<span id="cb125-24"><a href="#cb125-24" aria-hidden="true" tabindex="-1"></a>        _ = [c]_p ^ d := <span class="kw">by</span> <span class="kw">rw</span> [Exercise_7_4_5_Nat]</span>
<span id="cb125-25"><a href="#cb125-25" aria-hidden="true" tabindex="-1"></a>        _ = ([m]_p ^ e) ^ d := <span class="kw">by</span> <span class="kw">rw</span> [h5]</span>
<span id="cb125-26"><a href="#cb125-26" aria-hidden="true" tabindex="-1"></a>        _ = [m]_p ^ (e * d) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb125-27"><a href="#cb125-27" aria-hidden="true" tabindex="-1"></a>        _ = [0]_p ^ (e * d) := <span class="kw">by</span> <span class="kw">rw</span> [h8]</span>
<span id="cb125-28"><a href="#cb125-28" aria-hidden="true" tabindex="-1"></a>        _ = [0 ^ (e * d)]_p := Exercise_7_4_5_Int _ _ _</span>
<span id="cb125-29"><a href="#cb125-29" aria-hidden="true" tabindex="-1"></a>        _ = [0]_p := <span class="kw">by</span> <span class="kw">rw</span> [h10]</span>
<span id="cb125-30"><a href="#cb125-30" aria-hidden="true" tabindex="-1"></a>        _ = [m]_p := <span class="kw">by</span> <span class="kw">rw</span> [h8]</span>
<span id="cb125-31"><a href="#cb125-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> c ^ d ≡ m (MOD p) <span class="kw">from</span> (cc_eq_iff_congr _ _ _).ltr h11</span>
<span id="cb125-32"><a href="#cb125-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb125-33"><a href="#cb125-33" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h6 : ¬p ∣ m</span></span>
<span id="cb125-34"><a href="#cb125-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h7 : rel_prime m p := rel_prime_of_prime_not_dvd h1 h6</span>
<span id="cb125-35"><a href="#cb125-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h8 : rel_prime p m := rel_prime_symm h7</span>
<span id="cb125-36"><a href="#cb125-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h9 : NeZero p := prime_NeZero h1</span>
<span id="cb125-37"><a href="#cb125-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h10 : (1 : Int) ^ s = 1 := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb125-38"><a href="#cb125-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h11 : [c ^ d]_p = [m]_p :=</span>
<span id="cb125-39"><a href="#cb125-39" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> [c ^ d]_p</span>
<span id="cb125-40"><a href="#cb125-40" aria-hidden="true" tabindex="-1"></a>        _ = [c]_p ^ d := <span class="kw">by</span> <span class="kw">rw</span> [Exercise_7_4_5_Nat]</span>
<span id="cb125-41"><a href="#cb125-41" aria-hidden="true" tabindex="-1"></a>        _ = ([m]_p ^ e) ^ d := <span class="kw">by</span> <span class="kw">rw</span> [h5]</span>
<span id="cb125-42"><a href="#cb125-42" aria-hidden="true" tabindex="-1"></a>        _ = [m]_p ^ (e * d) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb125-43"><a href="#cb125-43" aria-hidden="true" tabindex="-1"></a>        _ = [m]_p ^ ((p - 1) * s + 1) := <span class="kw">by</span> <span class="kw">rw</span> [h2]</span>
<span id="cb125-44"><a href="#cb125-44" aria-hidden="true" tabindex="-1"></a>        _ = ([m]_p ^ (p - 1)) ^ s * [m]_p := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb125-45"><a href="#cb125-45" aria-hidden="true" tabindex="-1"></a>        _ = ([m]_p ^ (phi p)) ^ s * [m]_p := <span class="kw">by</span> <span class="kw">rw</span> [phi_prime h1]</span>
<span id="cb125-46"><a href="#cb125-46" aria-hidden="true" tabindex="-1"></a>        _ = [1]_p ^ s * [m]_p := <span class="kw">by</span> <span class="kw">rw</span> [Theorem_7_4_2 h8]</span>
<span id="cb125-47"><a href="#cb125-47" aria-hidden="true" tabindex="-1"></a>        _ = [1 ^ s]_p * [m]_p := <span class="kw">by</span> <span class="kw">rw</span> [Exercise_7_4_5_Int]</span>
<span id="cb125-48"><a href="#cb125-48" aria-hidden="true" tabindex="-1"></a>        _ = [1]_p * [m]_p := <span class="kw">by</span> <span class="kw">rw</span> [h10]</span>
<span id="cb125-49"><a href="#cb125-49" aria-hidden="true" tabindex="-1"></a>        _ = [m]_p * [1]_p := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb125-50"><a href="#cb125-50" aria-hidden="true" tabindex="-1"></a>        _ = [m]_p := Theorem_7_3_6_7 _</span>
<span id="cb125-51"><a href="#cb125-51" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> c ^ d ≡ m (MOD p) <span class="kw">from</span> (cc_eq_iff_congr _ _ _).ltr h11</span>
<span id="cb125-52"><a href="#cb125-52" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb125-53"><a href="#cb125-53" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here, finally, is the proof of <code>Theorem_7_5_1</code>:</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_5_1 (p q n e d k m c : Nat)</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>    (p_prime : prime p) (q_prime : prime q) (p_ne_q : p ≠ q)</span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>    (n_pq : n = p * q) (ed_congr_1 : e * d = k * (p - 1) * (q - 1) + 1)</span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>    (h1 : [m]_n ^ e = [c]_n) : [c]_n ^ d = [m]_n := <span class="kw">by</span></span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [Exercise_7_4_5_Nat, cc_eq_iff_congr] <span class="kw">at</span> h1</span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">--h1 : m ^ e ≡ c (MOD n)</span></span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [Exercise_7_4_5_Nat, cc_eq_iff_congr]</span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">--Goal : c ^ d ≡ m (MOD n)</span></span>
<span id="cb126-9"><a href="#cb126-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (j : Int) (h2 : m ^ e - c = n * j) <span class="kw">from</span> h1</span>
<span id="cb126-10"><a href="#cb126-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [n_pq, Nat.cast_mul] <span class="kw">at</span> h2</span>
<span id="cb126-11"><a href="#cb126-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">--h2 : m ^ e - c = p * q * j</span></span>
<span id="cb126-12"><a href="#cb126-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : e * d = (p - 1) * (k * (q - 1)) + 1 := <span class="kw">by</span></span>
<span id="cb126-13"><a href="#cb126-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [ed_congr_1]</span>
<span id="cb126-14"><a href="#cb126-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">ring</span></span>
<span id="cb126-15"><a href="#cb126-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb126-16"><a href="#cb126-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : m ^ e - c = p * (q * j) := <span class="kw">by</span></span>
<span id="cb126-17"><a href="#cb126-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h2]</span>
<span id="cb126-18"><a href="#cb126-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">ring</span></span>
<span id="cb126-19"><a href="#cb126-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb126-20"><a href="#cb126-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> congr_p : c ^ d ≡ m (MOD p) := Lemma_7_5_1 p_prime h3 h4</span>
<span id="cb126-21"><a href="#cb126-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : e * d = (q - 1) * (k * (p - 1)) + 1 := <span class="kw">by</span></span>
<span id="cb126-22"><a href="#cb126-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [ed_congr_1]</span>
<span id="cb126-23"><a href="#cb126-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">ring</span></span>
<span id="cb126-24"><a href="#cb126-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb126-25"><a href="#cb126-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : m ^ e - c = q * (p * j) := <span class="kw">by</span></span>
<span id="cb126-26"><a href="#cb126-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h2]</span>
<span id="cb126-27"><a href="#cb126-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">ring</span></span>
<span id="cb126-28"><a href="#cb126-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb126-29"><a href="#cb126-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> congr_q : c ^ d ≡ m (MOD q) := Lemma_7_5_1 q_prime h5 h6</span>
<span id="cb126-30"><a href="#cb126-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h7 : ¬q ∣ p := <span class="kw">by</span></span>
<span id="cb126-31"><a href="#cb126-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">by_contra</span> h8</span>
<span id="cb126-32"><a href="#cb126-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h9 : q = 1 ∨ q = p := dvd_prime p_prime h8</span>
<span id="cb126-33"><a href="#cb126-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">disj_syll</span> h9 (prime_not_one q_prime)</span>
<span id="cb126-34"><a href="#cb126-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> False <span class="kw">from</span> p_ne_q h9.symm</span>
<span id="cb126-35"><a href="#cb126-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb126-36"><a href="#cb126-36" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h8 : rel_prime p q := rel_prime_of_prime_not_dvd q_prime h7</span>
<span id="cb126-37"><a href="#cb126-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [n_pq, Lemma_7_4_5 _ _ h8]</span>
<span id="cb126-38"><a href="#cb126-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> c ^ d ≡ m (MOD p) ∧ c ^ d ≡ m (MOD q) <span class="kw">from</span></span>
<span id="cb126-39"><a href="#cb126-39" aria-hidden="true" tabindex="-1"></a>    And.intro congr_p congr_q</span>
<span id="cb126-40"><a href="#cb126-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="exercises-4" class="level3">
<h3 class="anchored" data-anchor-id="exercises-4">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb127"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint:  Use induction.</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> num_rp_prime {p : Nat} (h1 : prime p) :</span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a>    ∀ k &lt; p, num_rp_below p (k + 1) = k := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb128"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> three_prime : prime 3 := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb129"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint:  Use the previous exercise, Exercise_7_2_7, and Theorem_7_4_2.</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_7_5_13a (a : Nat) (h1 : rel_prime 561 a) :</span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>    a ^ 560 ≡ 1 (MOD 3) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb130"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint:  Imitate the way Theorem_7_2_2_Int was proven from Theorem_7_2_2.</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Theorem_7_2_3_Int {p : Nat} {a b : Int}</span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a>    (h1 : prime p) (h2 : ↑p ∣ a * b) : ↑p ∣ a ∨ ↑p ∣ b := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb131"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint:  Use the previous exercise.</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_7_5_14b (n : Nat) (b : Int)</span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>    (h1 : prime n) (h2 : b ^ 2 ≡ 1 (MOD n)) :</span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a>    b ≡ 1 (MOD n) ∨ b ≡ -1 (MOD n) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Chap6.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Mathematical Induction</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./Chap8.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Infinite Sets</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
      <div class="nav-footer-center">© 2023-2025 Daniel J. Velleman.<br>Short excerpts from Daniel J. Velleman, <a href="https://doi.org/10.1017/9781108539890"><i>How To Prove It: A Structured Approach, 3rd Edition</i></a><br>© Daniel J. Velleman 2019, published by Cambridge University Press, reprinted with permission.</div>
  </div>
</footer>



</body></html>