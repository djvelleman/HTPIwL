<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.189">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>How To Prove It with Lean - 8&nbsp; Infinite Sets</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Appendix.html" rel="next">
<link href="./Chap7.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="HTPIwLstyles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Infinite Sets</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">How To Prove It with Lean</a> 
        <div class="sidebar-tools-main">
    <a href="./How-To-Prove-It-with-Lean.pdf" title="Download PDF" class="sidebar-tool px-1"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Preface</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap1.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Sentential Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap2.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Quantificational Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./IntroLean.html" class="sidebar-item-text sidebar-link">Introduction to Lean</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap3.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Proofs</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap4.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Relations</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap5.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Functions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap6.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Mathematical Induction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap7.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Number Theory</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap8.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Infinite Sets</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Appendix.html" class="sidebar-item-text sidebar-link">Appendix</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">In This Chapter</h2>
   
  <ul class="collapse">
  <li><a href="#equinumerous-sets" id="toc-equinumerous-sets" class="nav-link active" data-scroll-target="#equinumerous-sets">8.1. Equinumerous Sets</a></li>
  <li><a href="#debts-paid" id="toc-debts-paid" class="nav-link" data-scroll-target="#debts-paid">8.1½. Debts Paid</a></li>
  <li><a href="#countable-and-uncountable-sets" id="toc-countable-and-uncountable-sets" class="nav-link" data-scroll-target="#countable-and-uncountable-sets">8.2. Countable and Uncountable Sets</a></li>
  <li><a href="#the-cantorschröderbernstein-theorem" id="toc-the-cantorschröderbernstein-theorem" class="nav-link" data-scroll-target="#the-cantorschröderbernstein-theorem">8.3. The Cantor–Schröder–Bernstein Theorem</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<div class="hidden">
$$
\newcommand{\setmin}{\mathbin{\backslash}}
\newcommand{\symmdiff}{\mathbin{∆}}
$$
</div>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Infinite Sets</span></h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<section id="equinumerous-sets" class="level2">
<h2 class="anchored" data-anchor-id="equinumerous-sets">8.1. Equinumerous Sets</h2>
<p>Chapter 8 of <em>HTPI</em> begins by defining a set <span class="math inline">\(A\)</span> to be <em>equinumerous</em> with a set <span class="math inline">\(B\)</span> if there is a function <span class="math inline">\(f : A \to B\)</span> that is one-to-one and onto. But in Lean, a function must go from a <em>type</em> to a <em>type</em>, not a set to a set. Thus, when we translate the <em>HTPI</em> definition into Lean’s language, we end up with a definition that tells us when one <em>type</em> is equinumerous with another. Throughout this chapter, we will use the letters <code>U</code>, <code>V</code>, … for types and <code>A</code>, <code>B</code>, … for sets, so we state the definition of <em>equinumerous</em> like this in Lean:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> equinum (U V : <span class="kw">Type</span>) : <span class="kw">Prop</span> :=</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  ∃ (f : U → V), one_to_one f ∧ onto f</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>As in <em>HTPI</em>, we introduce the notation <code>U ∼ V</code> to indicate that <code>U</code> is equinumerous with <code>V</code> (to enter the symbol <code>∼</code>, type <code>\sim</code> or <code>\~</code>).</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">notation</span>:50  U:50 <span class="st">" ∼ "</span> V:50 =&gt; equinum U V</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Section 8.1 of <em>HTPI</em> begins the study of this concept with some examples. The first is a one-to-one, onto function from <span class="math inline">\(\mathbb{Z}^+\)</span> to <span class="math inline">\(\mathbb{Z}\)</span>, which shows that <span class="math inline">\(\mathbb{Z}^+ \sim \mathbb{Z}\)</span>. We will modify this example slightly to make it a function <code>fnz</code> from <code>Nat</code> to <code>Int</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fnz (n : Nat) : Int := if 2 ∣ n then ↑(n / 2) else -↑((n + 1) / 2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Note that, to get a result of type <code>Int</code>, coercion is necessary. We have specified that the coercion should be done after the computation of either <code>n / 2</code> or <code>(n + 1) / 2</code>, with that computation being done using natural-number arithmetic. Checking a few values of this functions suggests a simple pattern:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">#eval</span> [fnz 0, fnz 1, fnz 2, fnz 3, fnz 4, fnz 5, fnz 6]</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">--Answer: [0, -1, 1, -2, 2, -3, 3]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Perhaps the easiest way to prove that <code>fnz</code> is one-to-one and onto is to define a function that turns out to be its inverse. This time, in order to get the right type for the value of the function, we use the function <code>Int.toNat</code> to convert a nonnegative integer to a natural number.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fzn (a : Int) : Nat :=</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  if a ≥ 0 then 2 * Int.toNat a else 2 * Int.toNat (-a) - 1</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">#eval</span> [fzn 0, fzn (-1), fzn 1, fzn (-2), fzn 2, fzn (-3), fzn 3]</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">--Answer: [0, 1, 2, 3, 4, 5, 6]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To prove that <code>fzn</code> is the inverse of <code>fnz</code>, we begin by proving lemmas making it easier to compute the values of these functions</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fnz_even (k : Nat) : fnz (2 * k) = ↑k := <span class="kw">by</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h1 : 2 ∣ 2 * k := <span class="kw">by</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro k</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : 0 &lt; 2 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> fnz (2 * k) = ↑k <span class="kw">from</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> fnz (2 * k)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>      _ = ↑(2 * k / 2) := if_pos h1</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>      _ = ↑k := <span class="kw">by</span> <span class="kw">rw</span> [Nat.mul_div_cancel_left k h2]</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fnz_odd (k : Nat) : fnz (2 * k + 1) = -↑(k + 1) := <span class="cn">sorry</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fzn_nat (k : Nat) : fzn ↑k = 2 * k := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fzn_neg_succ_nat (k : Nat) : fzn (-↑(k + 1)) = 2 * k + 1 := <span class="kw">by</span> <span class="kw">rfl</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Using these lemmas and reasoning by cases, it is straightforward to prove lemmas confirming that the composition of these functions, in either order, yields the identity function. The cases for the first lemma are based on an exercise from Section 6.1.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fzn_fnz : fzn ∘ fnz = id := <span class="kw">by</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> funext        <span class="co">--Goal : ∀ (x : Nat), (fzn ∘ fnz) x = id x</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> n : Nat</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [comp_def]  <span class="co">--Goal : fzn (fnz n) = id n</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h1 : nat_even n ∨ nat_odd n := Exercise_6_1_16a1 n</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> <span class="kw">on</span> h1</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h1 : nat_even n</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (k : Nat) (h2 : n = 2 * k) <span class="kw">from</span> h1</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h2, fnz_even, fzn_nat]</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h1 : nat_odd n</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (k : Nat) (h2 : n = 2 * k + 1) <span class="kw">from</span> h1</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h2, fnz_odd, fzn_neg_succ_nat]</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fnz_fzn : fnz ∘ fzn = id  := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>By theorems from Chapter 5, it follows that both <code>fnz</code> and <code>fzn</code> are one-to-one and onto.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fzn_one_one : one_to_one fzn := Theorem_5_3_3_1 fzn fnz fnz_fzn</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fzn_onto : onto fzn := Theorem_5_3_3_2 fzn fnz fzn_fnz</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fnz_one_one : one_to_one fnz := Theorem_5_3_3_1 fnz fzn fzn_fnz</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fnz_onto : onto fnz := Theorem_5_3_3_2 fnz fzn fnz_fzn</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We conclude that <code>Nat ∼ Int</code> and <code>Int ∼ Nat</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> N_equinum_Z : Nat ∼ Int :=</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  Exists.intro fnz (And.intro fnz_one_one fnz_onto)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Z_equinum_N : Int ∼ Nat :=</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  Exists.intro fzn (And.intro fzn_one_one fzn_onto)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We’ll give one more example: a one-to-one, onto function <code>fnnn</code> from <code>Nat × Nat</code> to <code>Nat</code>, whose definition is modeled on a function from <span class="math inline">\(\mathbb{Z}^+ \times \mathbb{Z}^+\)</span> to <span class="math inline">\(\mathbb{Z}^+\)</span> in <em>HTPI</em>. The definition of <code>fnnn</code> will use numbers of the form <code>k * (k + 1) / 2</code>. These numbers are sometimes called <em>triangular numbers</em>, because they count the number of objects in a triangular grid with <code>k</code> rows.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tri (k : Nat) : Nat := k * (k + 1) / 2</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fnnn (p : Nat × Nat) : Nat := tri (p.1 + p.2) + p.1</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fnnn_def (a b : Nat) : fnnn (a, b) = tri (a + b) + a := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="kw">#eval</span> [fnnn (0, 0), fnnn (0, 1), fnnn (1, 0),</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  fnnn (0, 2), fnnn (1, 1), fnnn (2, 0)]</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">--Answer: [0, 1, 2, 3, 4, 5]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Two simple lemmas about <code>tri</code>, whose proofs we leave as exercises for you, help us prove the important properties of <code>fnnn</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> tri_step (k : Nat) : tri (k + 1) = tri k + k + 1 := <span class="cn">sorry</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> tri_incr {j k : Nat} (h1 : j ≤ k) : tri j ≤ tri k := <span class="cn">sorry</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> le_of_fnnn_eq {a1 b1 a2 b2 : Nat}</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    (h1 : fnnn (a1, b1) = fnnn (a2, b2)) : a1 + b1 ≤ a2 + b2 := <span class="kw">by</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_contra</span> h2</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : a2 + b2 + 1 ≤ a1 + b1 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : fnnn (a2, b2) &lt; fnnn (a1, b1) :=</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> fnnn (a2, b2)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>      _ = tri (a2 + b2) + a2 := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>      _ &lt; tri (a2 + b2) + (a2 + b2) + 1 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>      _ = tri (a2 + b2 + 1) := (tri_step _).symm</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>      _ ≤ tri (a1 + b1) := tri_incr h3</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>      _ ≤ tri (a1 + b1) + a1 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>      _ = fnnn (a1, b1) := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">linarith</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fnnn_one_one : one_to_one fnnn := <span class="kw">by</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> (a1, b1) : Nat × Nat</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> (a2, b2) : Nat × Nat</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : fnnn (a1, b1) = fnnn (a2, b2)  <span class="co">--Goal : (a1, b1) = (a2, b2)</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : a1 + b1 ≤ a2 + b2 := le_of_fnnn_eq h1</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : a2 + b2 ≤ a1 + b1 := le_of_fnnn_eq h1.symm</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : a1 + b1 = a2 + b2 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [fnnn_def, fnnn_def, h4] <span class="kw">at</span> h1</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">--h1 : tri (a2 + b2) + a1 = tri (a2 + b2) + a2</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : a1 = a2 := Nat.add_left_cancel h1</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h6] <span class="kw">at</span> h4   <span class="co">--h4 : a2 + b1 = a2 + b2</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h7 : b1 = b2 := Nat.add_left_cancel h4</span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h6, h7]</span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rfl</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fnnn_onto : onto fnnn := <span class="kw">by</span></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>  <span class="co">--Goal : ∀ (y : Nat), ∃ (x : Nat × Nat), fnnn x = y</span></span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro (0, 0)</span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> n : Nat</span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : ∃ (x : Nat × Nat), fnnn x = n</span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> ((a, b) : Nat × Nat) (h1 : fnnn (a, b) = n) <span class="kw">from</span> ih</span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">by_cases</span> h2 : b = 0</span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 1. h2 : b = 0</span></span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro (0, a + 1)</span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> fnnn (0, a + 1) = n + 1 <span class="kw">from</span></span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true" tabindex="-1"></a>        <span class="kw">calc</span> fnnn (0, a + 1)</span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true" tabindex="-1"></a>          _ = tri (0 + (a + 1)) + 0 := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true" tabindex="-1"></a>          _ = tri (a + 1) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true" tabindex="-1"></a>          _ = tri a + a + 1 := tri_step a</span>
<span id="cb11-55"><a href="#cb11-55" aria-hidden="true" tabindex="-1"></a>          _ = tri (a + 0) + a + 1 := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb11-56"><a href="#cb11-56" aria-hidden="true" tabindex="-1"></a>          _ = fnnn (a, b) + 1 := <span class="kw">by</span> <span class="kw">rw</span> [h2, fnnn_def]</span>
<span id="cb11-57"><a href="#cb11-57" aria-hidden="true" tabindex="-1"></a>          _ = n + 1 := <span class="kw">by</span> <span class="kw">rw</span> [h1]</span>
<span id="cb11-58"><a href="#cb11-58" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb11-59"><a href="#cb11-59" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 2. h2 : b ≠ 0</span></span>
<span id="cb11-60"><a href="#cb11-60" aria-hidden="true" tabindex="-1"></a>      <span class="kw">obtain</span> (k : Nat) (h3 : b = k + 1) <span class="kw">from</span></span>
<span id="cb11-61"><a href="#cb11-61" aria-hidden="true" tabindex="-1"></a>        exists_eq_add_one_of_ne_zero h2</span>
<span id="cb11-62"><a href="#cb11-62" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro (a + 1, k)</span>
<span id="cb11-63"><a href="#cb11-63" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> fnnn (a + 1, k) = n + 1 <span class="kw">from</span></span>
<span id="cb11-64"><a href="#cb11-64" aria-hidden="true" tabindex="-1"></a>        <span class="kw">calc</span> fnnn (a + 1, k)</span>
<span id="cb11-65"><a href="#cb11-65" aria-hidden="true" tabindex="-1"></a>          _ = tri (a + 1 + k) + (a + 1) := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb11-66"><a href="#cb11-66" aria-hidden="true" tabindex="-1"></a>          _ = tri (a + (k + 1)) + a + 1 := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb11-67"><a href="#cb11-67" aria-hidden="true" tabindex="-1"></a>          _ = tri (a + b) + a + 1 := <span class="kw">by</span> <span class="kw">rw</span> [h3]</span>
<span id="cb11-68"><a href="#cb11-68" aria-hidden="true" tabindex="-1"></a>          _ = fnnn (a, b) + 1 := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb11-69"><a href="#cb11-69" aria-hidden="true" tabindex="-1"></a>          _ = n + 1 := <span class="kw">by</span> <span class="kw">rw</span> [h1]</span>
<span id="cb11-70"><a href="#cb11-70" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb11-71"><a href="#cb11-71" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb11-72"><a href="#cb11-72" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb11-73"><a href="#cb11-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-74"><a href="#cb11-74" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> NxN_equinum_N : (Nat × Nat) ∼ Nat :=</span>
<span id="cb11-75"><a href="#cb11-75" aria-hidden="true" tabindex="-1"></a>  Exists.intro fnnn (And.intro fnnn_one_one fnnn_onto)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>One of the most important theorems about the concept of equinumerosity is Theorem 8.1.3 in <em>HTPI</em>, which says that <code>∼</code> is reflexive, symmetric, and transitive. We’ll prove the three parts of this theorem separately. To prove that <code>∼</code> is reflexive, we use the identity function. (Recall from Section 5.1 that <code>@id U</code> is the identity function on the type <code>U</code>.)</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> id_one_one (U : <span class="kw">Type</span>) : one_to_one (@id U) := <span class="kw">by</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x1 : U; <span class="kw">fix</span> x2 : U</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h : id x1 = id x2</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> x1 = x2 <span class="kw">from</span> h</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> id_onto (U : <span class="kw">Type</span>) : onto (@id U) := <span class="kw">by</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U              <span class="co">--Goal : ∃ (x : U), id x = y</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro y   <span class="co">--Goal : id y = y</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rfl</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_8_1_3_1 (U : <span class="kw">Type</span>) : U ∼ U := <span class="kw">by</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro id</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> one_to_one id ∧ onto id <span class="kw">from</span> And.intro (id_one_one U) (id_onto U)</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For symmetry, we use some theorems from Chapter 5 about inverses of functions:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_8_1_3_2 {U V : <span class="kw">Type</span>}</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    (h : U ∼ V) : V ∼ U := <span class="kw">by</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (f : U → V) (h1 : one_to_one f ∧ onto f) <span class="kw">from</span> h</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (finv : V → U) (h2 : graph finv = inv (graph f)) <span class="kw">from</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    Theorem_5_3_1 f h1.left h1.right</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro finv</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : finv ∘ f = id := Theorem_5_3_2_1 f finv h2</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : f ∘ finv = id := Theorem_5_3_2_2 f finv h2</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> one_to_one finv ∧ onto finv <span class="kw">from</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    And.intro (Theorem_5_3_3_1 finv f h4) (Theorem_5_3_3_2 finv f h3)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, for transitivity, we use theorems about composition of functions:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_8_1_3_3 {U V W : <span class="kw">Type</span>}</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    (h1 : U ∼ V) (h2 : V ∼ W) : U ∼ W := <span class="kw">by</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (f : U → V) (h3 : one_to_one f ∧ onto f) <span class="kw">from</span> h1</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (g : V → W) (h4 : one_to_one g ∧ onto g) <span class="kw">from</span> h2</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (g ∘ f)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> one_to_one (g ∘ f) ∧ onto (g ∘ f) <span class="kw">from</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    And.intro (Theorem_5_2_5_1 f g h3.left h4.left)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    (Theorem_5_2_5_2 f g h3.right h4.right)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>So far, we have only talked about <em>types</em> being equinumerous, but later in this chapter we are going to want to talk about <em>sets</em> being equinumerous. For example, it would be nice if we could give this proof:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> wishful_thinking?</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    {U : <span class="kw">Type</span>} (A : Set U) : A ∼ A := Theorem_8_1_3_1 A</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It seems like Lean shouldn’t accept this theorem; the notation <code>∼</code> was defined to apply to types, and in this theorem, <code>A</code> is a set, not a type. But if you enter this theorem into Lean, you will find that Lean accepts it! How is that possible?</p>
<p>We can find out what Lean thinks this theorem means by giving the command <code>#check @wishful_thinking?</code>. Lean’s response is:</p>
<div class="ind">
<pre><code>@wishful_thinking? : ∀ {U : Type} (A : Set U), ↑A ∼ ↑A</code></pre>
</div>
<p>Aha! The uparrows are the key to unlocking the mystery. As we know, uparrows in Lean represent coercions. So Lean must have coerced <code>A</code> into a type, so that it can be used with the <code>∼</code> notation. Although <code>A</code> is a set, <code>↑A</code> is a type.</p>
<p>What is the type <code>↑A</code>? Intuitively, you can think of the objects of type <code>↑A</code> as the elements of <code>A</code>. Since <code>A</code> has type <code>Set U</code>, the elements of <code>A</code> are some, but perhaps not all, of the objects of type <code>U</code>; for this reason, <code>↑A</code> is called a <em>subtype</em> of <code>U</code>.</p>
<p>However, this intuitive description can be misleading. The relationship between <code>↑A</code> and <code>U</code> is actually similar to the relationship between <code>Nat</code> and <code>Int</code>. Recall that, although we think of the natural numbers as being contained in the integers, in Lean, the types <code>Nat</code> and <code>Int</code> are completely separate. If <code>n</code> has type <code>Nat</code>, then <code>n</code> is not an integer, but there is an integer that corresponds to <code>n</code>, and <code>n</code> can be coerced to that corresponding integer. Similarly, although we might think of <code>↑A</code> as being contained in <code>U</code>, in fact the two types are completely separate. If <code>a</code> has type <code>↑A</code>, then <code>a</code> does not have type <code>U</code>, but there is an object of type <code>U</code> that corresponds to <code>a</code>. That corresponding object is called the <em>value</em> of <code>a</code>, and it is denoted <code>a.val</code>. Furthermore, <code>a</code> can be coerced to <code>a.val</code>; using Lean’s notation for coercion, we can write <code>↑a = a.val</code>.</p>
<p>If <code>a</code> has type <code>↑A</code>, then not only is <code>a.val</code> an object of type <code>U</code>, but it is an element of <code>A</code>. Indeed, <code>a</code> supplies us with a proof of this fact. This proof is denoted <code>a.property</code>. In other words, we have <code>a.property : a.val ∈ A</code>. Indeed, you might think of any object <code>a : ↑A</code> as a bundle consisting of two pieces of data, <code>a.val</code> and <code>a.property</code>. Not only can we extract these two pieces of data from <code>a</code> by using the <code>.val</code> and <code>.property</code> notation, but we can go in the other direction. That is, if we have <code>x : U</code> and <code>h : x ∈ A</code>, then we can bundle these two pieces of data together to create an object of type <code>↑A</code>. This object of type <code>↑A</code> is denoted <code>Subtype.mk x h</code>. Thus, if <code>a = Subtype.mk x h</code>, then <code>a</code> has type <code>↑A</code>, <code>a.val = x</code>, and <code>a.property = h</code>. We can make the creation of objects of type <code>↑A</code> slightly simpler by introducing the following function:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Subtype_elt {U : <span class="kw">Type</span>} {A : Set U} {x : U} (h : x ∈ A) : ↑A :=</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  Subtype.mk x h</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Note that the only nonimplicit argument of <code>Subtype_elt</code> is <code>h</code>. Thus, if we have <code>h : x ∈ A</code>, then <code>Subtype_elt h</code> is an object of type <code>↑A</code> whose value is <code>x</code>.</p>
<p>There is one more important property of the type <code>↑A</code>. For each element of <code>A</code>, there is <em>only one</em> corresponding object of type <code>↑A</code>. That means that if <code>a1</code> and <code>a2</code> are two objects of type <code>↑A</code> and <code>a1.val = a2.val</code>, then <code>a1 = a2</code>. We can think of this as an extensionality principle for subtypes. Recall that the extensionality principle for sets is called <code>Set.ext</code>, and it says that if two sets have the same elements, then they are equal. Similarly, the extensionality principle for subtypes is denoted <code>Subtype.ext</code>, and it says that if two objects of type <code>↑A</code> have the same value, then they are equal. More precisely, if we have <code>a1 a2 : ↑A</code>, then <code>Subtype.ext</code> proves <code>a.val = a2.val → a1 = a2</code>. And just as we usually start a proof that two sets are equal with the tactic <code>apply Set.ext</code>, it is often useful to start a proof that two objects of type <code>↑A</code> are equal with the tactic <code>apply Subtype.ext</code>.</p>
<p>Now that we know that the concept of equinumerosity can be applied not only to types but also to sets, we can use this idea to make a number of definitions. For any natural number <span class="math inline">\(n\)</span>, <em>HTPI</em> defines <span class="math inline">\(I_n\)</span> to be the set <span class="math inline">\(\{1, 2, \ldots, n\}\)</span>, and then it defines a set to be <em>finite</em> if it is equinumerous with <span class="math inline">\(I_n\)</span>, for some <span class="math inline">\(n\)</span>. In Lean, it is a bit more convenient to use sets of the form <span class="math inline">\(\{0, 1, \ldots, n - 1\}\)</span>. With that small change, we can repeat the definitions of finite, denumerable, and countable in <em>HTPI</em>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> I (n : Nat) : Set Nat := {k : Nat | k &lt; n}</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> I_def (k n : Nat) : k ∈ I n ↔ k &lt; n := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> finite (U : <span class="kw">Type</span>) : <span class="kw">Prop</span> := ∃ (n : Nat), I n ∼ U</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> denum (U : <span class="kw">Type</span>) : <span class="kw">Prop</span> := Nat ∼ U</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> denum_def (U : <span class="kw">Type</span>) : denum U ↔ Nat ∼ U := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ctble (U : <span class="kw">Type</span>) : <span class="kw">Prop</span> := finite U ∨ denum U</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Note that in the definition of <code>finite</code>, <code>I n ∼ U</code> means <code>↑(I n) ∼ U</code>, because <code>I n</code> is a set, not a type. But we will usually leave it to Lean to fill in such coercions when necessary.</p>
<p>Theorem 8.1.5 in <em>HTPI</em> gives two useful ways to characterize countable sets. The proof of the theorem in <em>HTPI</em> uses the fact that every set of natural numbers is countable. <em>HTPI</em> gives an intuitive explanation of why this is true, but of course in Lean an intuitive explanation won’t do. So before proving a version of Theorem 8.1.5, we sketch a proof that every set of natural numbers is countable.</p>
<p>Suppose <code>A</code> has type <code>Set Nat</code>. To prove that <code>A</code> is countable, we will define a function that numbers the elements of <code>A</code> by assigning the number <code>0</code> to the smallest element of <code>A</code>, <code>1</code> to the next element of <code>A</code>, <code>2</code> to the next, and so on. How do we tell which natural number should be assigned to any element <code>m</code> of <code>A</code>? Notice that if <code>m</code> is the smallest element of <code>A</code>, then there are <code>0</code> elements of <code>A</code> that are smaller than <code>m</code>; if it is the second smallest element of <code>A</code>, then there is <code>1</code> element of <code>A</code> that is smaller than <code>m</code>; and so on. In general, the number assigned to <code>m</code> should be the number of elements of <code>A</code> that are smaller than <code>m</code>. We therefore begin by defining a function <code>num_elts_below A m</code> that counts the number of elements of <code>A</code> that are smaller than any natural number <code>m</code>.</p>
<p>The definition of <code>num_elts_below</code> is recursive. The recursive step relates the number of elements of <code>A</code> below <code>n + 1</code> to the number of elements below <code>n</code>. There are two possibilities: either <code>n ∈ A</code> and the number of elements below <code>n + 1</code> is one larger than the number below <code>n</code>, or <code>n ∉ A</code> and the two numbers are the same. (This may remind you of the recursion we used to define <code>num_rp_below</code> in Chapter 7.)</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> num_elts_below (A : Set Nat) (m : Nat) : Nat :=</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; 0</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    | n + 1 =&gt; <span class="sc">**</span><span class="er">if n ∈ A then (num_elts_below A n) + 1</span><span class="sc">::</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>                else num_elts_below A n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Unfortunately, this definition results in an error message: <code>failed to synthesize Decidable (n ∈ A)</code>. Lean is complaining because it doesn’t know how to decide, in general, whether or not <code>n ∈ A</code>. As a result, if we asked it to evaluate <code>num_elts_below A m</code>, for some particular set <code>A</code> and natural number <code>m</code>, it wouldn’t know how to compute it. But this won’t be an issue for us; we want to use <code>num_elts_below</code> to prove theorems, but we’re never going to ask Lean to compute it. For reasons that we won’t explain here, we can get Lean to ignore this issue by adding the line <code>open Classical</code> at the top of our Lean file. This change leads to a new error, but this time the message is more helpful: <code>failed to compile definition, consider marking it as 'noncomputable'</code>. Following Lean’s advice, we finally get a definition that is acceptable to Lean:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>open Classical</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="kw">noncomputable</span> <span class="kw">def</span> num_elts_below (A : Set Nat) (m : Nat) : Nat :=</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    | 0 =&gt; 0</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    | n + 1 =&gt; if n ∈ A then (num_elts_below A n) + 1</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>                else num_elts_below A n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For example, if <code>A = {1, 3, 4}</code>, then <code>num_elts_below A 0 = num_elts_below A 1 = 0</code>, <code>num_elts_below A 2 = num_elts_below A 3 = 1</code>, <code>num_elts_below A 4 = 2</code>, and <code>num_elt_below A m = 3</code> for every <code>m ≥ 5</code>. Notice that <code>num_elts_below A</code> is a function from <code>Nat</code> to <code>Nat</code>, but it is neither one-to-one nor onto. To make it useful for proving that <code>A</code> is countable, we’ll need to modify it.</p>
<p>Suppose <code>f : U → V</code>, but <code>f</code> is not one-to-one or onto. How can we modify <code>f</code> to get a function that is one-to-one or onto? We begin with the problem of getting a function that is onto. The <em>range</em> of <code>f</code> is the set of all <code>y : V</code> such that for some <code>x : U</code>, <code>f x = y</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> range {U V : <span class="kw">Type</span>} (f : U → V) : Set V := {y : V | ∃ (x : U), f x = y}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>(In the exercises, we ask you to show that this is the same as <code>Ran (graph f)</code>.) Since every value of <code>f</code> is in <code>range f</code>, we can convert <code>f</code> into a function from <code>U</code> to <code>range f</code> (that is, from <code>U</code> to <code>↑(range f)</code>), as follows:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> elt_range {U V : <span class="kw">Type</span>} (f : U → V) (x : U) : f x ∈ range f := <span class="kw">by</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>                 <span class="co">--Goal : ∃ (x_1 : U), f x_1 = f x</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro x</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rfl</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> func_to_range {U V : <span class="kw">Type</span>} (f : U → V) (x : U) : range f :=</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>  Subtype_elt (elt_range f x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>According to these definitions, <code>func_to_range f</code> is a function from <code>U</code> to <code>↑(range f)</code>; it is the same as <code>f</code>, except that each value of the function is converted to an object of type <code>↑(range f)</code>. And it is not hard to prove that this function is onto:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> ftr_def {U V : <span class="kw">Type</span>} (f : U → V) (x : U) :</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    (func_to_range f x).val = f x := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> ftr_onto {U V : <span class="kw">Type</span>} (f : U → V) : onto (func_to_range f) := <span class="kw">by</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : range f              <span class="co">--y has type ↑(range f)</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h1 : y.val ∈ range f := y.property</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1                 <span class="co">--h1 : ∃ (x : U), f x = y.val</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (x : U) (h2 : f x = y.val) <span class="kw">from</span> h1</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro x         <span class="co">--Goal : func_to_range f x = y</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Subtype.ext            <span class="co">--Goal : (func_to_range f x).val = y.val</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [ftr_def, h2]</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rfl</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Is <code>func_to_range f</code> one-to-one? It turns out that if <code>f</code> is one-to-one, then so is <code>func_to_range f</code>, and therefore <code>func_to_range f</code> can be used to prove that <code>U ∼ range f</code>. Here are the proofs:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> ftr_one_one_of_one_one {U V : <span class="kw">Type</span>} {f : U → V}</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    (h : one_to_one f) : one_to_one (func_to_range f) := <span class="kw">by</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x1 : U; <span class="kw">fix</span> x2 : U</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : func_to_range f x1 = func_to_range f x2</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : f x1 = f x2 :=</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> f x1</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>      _ = (func_to_range f x1).val := (ftr_def f x1).symm</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>      _ = (func_to_range f x2).val := <span class="kw">by</span> <span class="kw">rw</span> [h1]</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>      _ = f x2 := ftr_def f x2</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> x1 = x2 <span class="kw">from</span> h x1 x2 h2</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> equinum_range {U V : <span class="kw">Type</span>} {f : U → V}</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>    (h : one_to_one f) : U ∼ range f := <span class="kw">by</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (func_to_range f)</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> one_to_one (func_to_range f) ∧ onto (func_to_range f) <span class="kw">from</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>    And.intro (ftr_one_one_of_one_one h) (ftr_onto f)</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We have seen that, given a function <code>f : U → V</code>, we can turn <code>f</code> into an onto function by replacing <code>V</code> with a subtype of <code>V</code>. (This is similar to an idea that is mentioned briefly in <em>HTPI</em>; see Exercise 23 in Section 5.2 of <em>HTPI</em>.) It is perhaps not surprising that we can sometimes turn <code>f</code> into a one-to-one function by replacing <code>U</code> with a subtype of <code>U</code>. If <code>A</code> has type <code>Set U</code>, then the <em>restriction</em> of <code>f</code> to <code>A</code> is a function from <code>A</code> to <code>V</code>. It has the same values as <code>f</code>, but only when applied to elements of <code>A</code>. (This idea is also mentioned in <em>HTPI</em>; see Exercise 7 in Section 5.2 of <em>HTPI</em>.) We can define the restriction of <code>f</code> to <code>A</code> in Lean as follows:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> func_restrict {U V : <span class="kw">Type</span>}</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  (f : U → V) (A : Set U) (x : A) : V := f x.val</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fr_def {U V : <span class="kw">Type</span>} (f : U → V) (A : Set U) (x : A) :</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    func_restrict f A x = f x.val := <span class="kw">by</span> <span class="kw">rfl</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Thus, <code>func_restrict f A</code> is a function from <code>A</code> to <code>V</code> (that is, from <code>↑A</code> to <code>V</code>). Is it one-to-one? The answer is: sometimes. We will say that a function is <em>one-to-one on <code>A</code></em> if it satisfies the definition of one-to-one when applied to elements of <code>A</code>:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> one_one_on {U V : <span class="kw">Type</span>} (f : U → V) (A : Set U) : <span class="kw">Prop</span> :=</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  ∀ ⦃x1 x2 : U⦄, x1 ∈ A → x2 ∈ A → f x1 = f x2 → x1 = x2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Notice that in this definition, we have used the same double braces for the quantified variables <code>x1</code> and <code>x2</code> that were used in the definition of “subset.” This means that <code>x1</code> and <code>x2</code> are implicit arguments, and therefore if we have <code>h : one_one_on f A</code>, <code>ha1 : a1 ∈ A</code>, <code>ha2 : a2 ∈ A</code>, and <code>heq : f a1 = f a2</code>, then <code>h h1a h2a heq</code> is a proof of <code>a1 = a2</code>. There is no need to specify that <code>a1</code> and <code>a2</code> are the values to be assigned to <code>x1</code> and <code>x2</code>; Lean will figure that out for itself. (To type the double braces <code>⦃</code> and <code>⦄</code>, type <code>\{{</code> and <code>\}}</code>. There were cases in previous chapters where it would have been appropriate to use such implicit arguments, but we chose not to do so to avoid confusion. But by now you should be comfortable enough with Lean that you won’t be confused by this new complication.)</p>
<p>It is now not hard to show that if <code>f</code> is one-to-one on <code>A</code>, then <code>func_restrict f A</code> is one-to-one:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fr_one_one_of_one_one_on {U V : <span class="kw">Type</span>} {f : U → V} {A : Set U}</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    (h : one_one_on f A) : one_to_one (func_restrict f A) := <span class="kw">by</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x1 : A; <span class="kw">fix</span> x2 : A                    <span class="co">--x1 and x2 have type ↑A</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : func_restrict f A x1 = func_restrict f A x2</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [fr_def, fr_def] <span class="kw">at</span> h1            <span class="co">--h1 : f x1.val = f x2.val</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Subtype.ext                         <span class="co">--Goal : x1.val = x2.val</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> x1.val = x2.val <span class="kw">from</span> h x1.property x2.property h1</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now we can combine our last two results: if <code>f</code> is one-to-one on <code>A</code>, then <code>func_restrict f A</code> is one-to-one, and therefore <code>A</code> is equinumerous with the range of <code>func_restrict f A</code>. And what is the range of <code>func_restrict f A</code>? It is just the image of <code>A</code> under <code>f</code>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> elt_image {U V : <span class="kw">Type</span>} {A : Set U} {x : U}</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    (f : U → V) (h : x ∈ A) : f x ∈ image f A := <span class="kw">by</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>                   <span class="co">--Goal : ∃ x_1 ∈ A, f x_1 = f x</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro x     <span class="co">--Goal : x ∈ A ∧ f x = f x</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro h</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rfl</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fr_range {U V : <span class="kw">Type</span>} (f : U → V) (A : Set U) :</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>    range (func_restrict f A) = image f A := <span class="kw">by</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : V</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : y ∈ range (func_restrict f A) <span class="co">--Goal : y ∈ image f A</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (a : A) (h2 : func_restrict f A a = y) <span class="kw">from</span> h1</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←h2, fr_def]                     <span class="co">--Goal : f a.val ∈ image f A</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> f a.val ∈ image f A <span class="kw">from</span> elt_image f a.property</span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : y ∈ image f A         <span class="co">--Goal : y ∈ range (func_restrict f A)</span></span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (a : U) (h2 : a ∈ A ∧ f a = y) <span class="kw">from</span> h1</span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">set</span> aA : A := Subtype_elt h2.left</span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : func_restrict f A aA = f a := fr_def f A aA</span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←h2.right, ←h3]</span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> func_restrict f A aA ∈ range (func_restrict f A) <span class="kw">from</span></span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>      elt_range (func_restrict f A) aA</span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Putting it all together, we have another theorem that helps us prove that sets are equinumerous:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> equinum_image {U V : <span class="kw">Type</span>} {A : Set U} {f : U → V}</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    (h : one_one_on f A) : A ∼ image f A := <span class="kw">by</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←fr_range f A]          <span class="co">--Goal : A ∼ range (func_restrict f A)</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h1 : one_to_one (func_restrict f A) :=</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    fr_one_one_of_one_one_on h</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> A ∼ range (func_restrict f A) <span class="kw">from</span> equinum_range h1</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We now return to the problem of showing that if <code>A</code> has type <code>Set Nat</code>, then it is countable. Recall that we have defined a function <code>num_elts_below A : Nat → Nat</code> that counts the number of elements of <code>A</code> below any natural number. Although <code>num_elts_below A</code> is not one-to-one, it turns out that it is one-to-one on <code>A</code>. We use this fact to show that if <code>A</code> has an upper bound then it is finite, and if it doesn’t then it is denumerable. The details of the proof are somewhat long. We’ll skip some of them here, but you can find them in the HTPI Lean package.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> neb_one_one_on (A : Set Nat) :</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    one_one_on (num_elts_below A) A := <span class="cn">sorry</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> neb_image_bdd {A : Set Nat} {m : Nat} (h : ∀ n ∈ A, n &lt; m) :</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    image (num_elts_below A) A = I (num_elts_below A m) := <span class="cn">sorry</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> bdd_subset_nat {A : Set Nat} {m : Nat}</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    (h : ∀ n ∈ A, n &lt; m) : I (num_elts_below A m) ∼ A := <span class="kw">by</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : A ∼ image (num_elts_below A) A :=</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>    equinum_image (neb_one_one_on A)</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [neb_image_bdd h] <span class="kw">at</span> h2        <span class="co">--h2 : A ∼ I (num_elts_below A m)</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> I (num_elts_below A m) ∼ A <span class="kw">from</span> Theorem_8_1_3_2 h2</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> neb_unbdd_onto {A : Set Nat}</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>    (h : ∀ (m : Nat), ∃ n ∈ A, n ≥ m) :</span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>    onto (func_restrict (num_elts_below A) A) := <span class="cn">sorry</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> unbdd_subset_nat {A : Set Nat}</span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a>    (h : ∀ (m : Nat), ∃ n ∈ A, n ≥ m) :</span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>    denum A := <span class="kw">by</span></span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [denum_def]</span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> f : A → Nat := func_restrict (num_elts_below A) A</span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h1 : one_to_one f :=</span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>    fr_one_one_of_one_one_on (neb_one_one_on A)</span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : onto f := neb_unbdd_onto h</span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : A ∼ Nat := Exists.intro f (And.intro h1 h2)</span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> Nat ∼ A <span class="kw">from</span> Theorem_8_1_3_2 h3</span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> set_nat_ctble (A : Set Nat) : ctble A := <span class="kw">by</span></span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>          <span class="co">--Goal : finite A ∨ denum A</span></span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> h1 : ∃ (m : Nat), ∀ n ∈ A, n &lt; m</span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h1 : ∃ (m : Nat), ∀ n ∈ A, n &lt; m</span></span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Or.inl  <span class="co">--Goal : finite A</span></span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (m : Nat) (h2 : ∀ n ∈ A, n &lt; m) <span class="kw">from</span> h1</span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro (num_elts_below A m)</span>
<span id="cb30-39"><a href="#cb30-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> I (num_elts_below A m) ∼ A <span class="kw">from</span> bdd_subset_nat h2</span>
<span id="cb30-40"><a href="#cb30-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb30-41"><a href="#cb30-41" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h1 : ¬∃ (m : Nat), ∀ n ∈ A, n &lt; m</span></span>
<span id="cb30-42"><a href="#cb30-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Or.inr  <span class="co">--Goal : denum A</span></span>
<span id="cb30-43"><a href="#cb30-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">push_neg</span> <span class="kw">at</span> h1</span>
<span id="cb30-44"><a href="#cb30-44" aria-hidden="true" tabindex="-1"></a>      <span class="co">--This tactic converts h1 to ∀ (m : Nat), ∃ n ∈ A, m ≤ n</span></span>
<span id="cb30-45"><a href="#cb30-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> denum A <span class="kw">from</span> unbdd_subset_nat h1</span>
<span id="cb30-46"><a href="#cb30-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb30-47"><a href="#cb30-47" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>As a consequence of our last theorem, we will get another characterization of countability: a type is countable if and only if it is equinumerous with some set of natural numbers. A finite type is equinumerous with the set <code>I n</code>, for some natural number <code>n</code>. But what set of natural numbers is a denumerable type equinumerous with? The obvious choice is the set of all natural numbers. We might call it the <em>universal set</em> for the type <code>Nat</code>. It will be convenient to have notation for the universal set of any type. It is not hard to show that any type is equinumerous with its universal set. We leave one lemma for the proof as an exercise for you:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Univ (U : <span class="kw">Type</span>) : Set U := {x : U | True}</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> elt_univ {U : <span class="kw">Type</span>} (x : U) : x ∈ Univ U := <span class="kw">by</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>   <span class="co">--Goal : True</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">trivial</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> onto_iff_range_eq_univ {U V : <span class="kw">Type</span>} (f : U → V) :</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>    onto f ↔ range f = Univ V := <span class="cn">sorry</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> univ_equinum_type (U : <span class="kw">Type</span>) : Univ U ∼ U := <span class="kw">by</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> f : U → U := id</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h1 : one_to_one f := id_one_one U</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : onto f := id_onto U</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [onto_iff_range_eq_univ] <span class="kw">at</span> h2  <span class="co">--h2 : range f = Univ U</span></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : U ∼ range f := equinum_range h1</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h2] <span class="kw">at</span> h3</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> Univ U ∼ U <span class="kw">from</span> Theorem_8_1_3_2 h3</span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With this preparation, we can prove our next characterization of countability, leaving the poof of a lemma as an exercise for you:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> ctble_of_ctble_equinum {U V : <span class="kw">Type</span>}</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    (h1 : U ∼ V) (h2 : ctble U) : ctble V := <span class="cn">sorry</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> ctble_iff_set_nat_equinum (U : <span class="kw">Type</span>) :</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    ctble U ↔ ∃ (J : Set Nat), J ∼ U := <span class="kw">by</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : ctble U</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1  <span class="co">--h1 : finite U ∨ denum U</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">by_cases</span> <span class="kw">on</span> h1</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 1. h1 : finite U</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span> <span class="kw">at</span> h1  <span class="co">--h1 : ∃ (n : Nat), I n ∼ U</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">obtain</span> (n : Nat) (h2 : I n ∼ U) <span class="kw">from</span> h1</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> ∃ (J : Set Nat), J ∼ U <span class="kw">from</span> Exists.intro (I n) h2</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 2. h1 : denum U</span></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [denum_def] <span class="kw">at</span> h1  <span class="co">--h1 : Nat ∼ U</span></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h2 : Univ Nat ∼ Nat := univ_equinum_type Nat</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro (Univ Nat)</span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> Univ Nat ∼ U <span class="kw">from</span> Theorem_8_1_3_3 h2 h1</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : ∃ (J : Set Nat), J ∼ U</span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (J : Set Nat) (h2 : J ∼ U) <span class="kw">from</span> h1</span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : ctble J := set_nat_ctble J</span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ctble U <span class="kw">from</span> ctble_of_ctble_equinum h2 h3</span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We have seen that if we have <code>f : U → V</code>, then it can be useful to replace either <code>U</code> or <code>V</code> with a subtype. We accomplished this by defining two functions, <code>func_to_range</code> and <code>func_restrict</code>. It is also sometimes useful to go in the other direction. To do this, we will define functions <code>func_to_type</code> and <code>func_extend</code> that are, in a sense, the reverses of <code>func_to_range</code> and <code>func_restrict</code>. If we have <code>f : U → B</code>, where <code>B</code> has type <code>Set V</code>, then <code>func_to_type f</code> is a function from <code>U</code> to <code>V</code>; it is the same as <code>f</code>, but with the values of the function coerced from <code>B</code> to <code>V</code>. If we have <code>f : A → V</code> and <code>v : V</code>, where <code>A</code> has type <code>Set U</code>, then <code>func_extend f v</code> is also a function from <code>U</code> to <code>V</code>; when applied to an element of <code>A</code>, it has the value specified by <code>f</code>, and when applied to anything else it has the value <code>v</code>. Here are the definitions:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> func_to_type {U V : <span class="kw">Type</span>} {B : Set V}</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>  (f : U → B) (x : U) : V := (f x).val</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> ftt_def {U V : <span class="kw">Type</span>} {B : Set V} (f : U → B) (x : U) :</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    func_to_type f x = (f x).val := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="kw">noncomputable</span> <span class="kw">def</span> func_extend {U V : <span class="kw">Type</span>} {A : Set U}</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>  (f : A → V) (v : V) (u : U) : V :=</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>  if test : u ∈ A then f (Subtype_elt test) else v</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fe_elt {U V : <span class="kw">Type</span>} {A : Set U} (f : A → V) (v : V) (a : A) :</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>    func_extend f v a.val = f a := dif_pos a.property</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Notice that in the definition of <code>func_extend</code>, we gave an identifier to the test in the <code>if</code> clause, so that we could refer to that test in the <code>then</code> clause. As a result, the if-then-else expression in the definition is what is called a <em>dependent</em> if-then-else. The proof of the lemma <code>fe_elt</code> uses the theorem <code>dif_pos</code>, which is just like <code>if_pos</code>, but for dependent if-then-else expressions. (Of course, <code>dif_neg</code> is the dependent version of <code>if_neg</code>.)</p>
<p>The sense in which <code>func_to_type</code> and <code>func_extend</code> reverse <code>func_to_range</code> and <code>func_restrict</code> is given by the following examples. We leave the proof of the second as an exercise for you:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U V : <span class="kw">Type</span>) (f : U → V) :</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    func_to_type (func_to_range f) = f := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U V : <span class="kw">Type</span>) (A : Set U) (f : A → V) (v : V) :</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    func_restrict (func_extend f v) A = f := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>How do <code>func_to_type</code> and <code>func_extend</code> interact with the properties <code>one_to_one</code> and <code>onto</code>? The answers are given by the following lemmas; you can find the straightforward proofs in the HTPI Lean package.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> ftt_range_of_onto {U V : <span class="kw">Type</span>} {B : Set V} {f : U → B}</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    (h : onto f) : range (func_to_type f) = B := <span class="cn">sorry</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> ftt_one_one_of_one_one {U V : <span class="kw">Type</span>} {B : Set V} {f : U → B}</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    (h : one_to_one f) : one_to_one (func_to_type f) := <span class="cn">sorry</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fe_image {U V : <span class="kw">Type</span>} {A : Set U}</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    (f : A → V) (v : V) : image (func_extend f v) A = range f := <span class="cn">sorry</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fe_one_one_on_of_one_one {U V : <span class="kw">Type</span>} {A : Set U} {f : A → V}</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>    (h : one_to_one f) (v : V) : one_one_on (func_extend f v) A := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Just as <code>func_to_type</code> and <code>func_extend</code> can be thought of as reversing <code>func_to_range</code> and <code>func_restrict</code>, the following theorem can be thought of as reversing the theorem <code>equinum_image</code>:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> type_to_type_of_equinum {U V : <span class="kw">Type</span>} {A : Set U} {B : Set V}</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    (h : A ∼ B) (v : V) :</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    ∃ (f : U → V), one_one_on f A ∧ image f A = B := <span class="kw">by</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (g : A → B) (h1 : one_to_one g ∧ onto g) <span class="kw">from</span> h</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> gtt : A → V := func_to_type g</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> f : U → V := func_extend gtt v</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro f</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof of one_to_one_on f A</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : one_to_one gtt := ftt_one_one_of_one_one h1.left</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> one_one_on f A <span class="kw">from</span> fe_one_one_on_of_one_one h2 v</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof of image f A = B</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : range gtt = B := ftt_range_of_onto h1.right</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : image f A = range gtt := fe_image gtt v</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h3, h2]</span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We are finally ready to turn to Theorem 8.1.5 in <em>HTPI</em>. The theorem says that for any set <span class="math inline">\(A\)</span>, the following statements are equivalent:</p>
<ol type="1">
<li><span class="math inline">\(A\)</span> is countable.</li>
<li>Either <span class="math inline">\(A = \varnothing\)</span> or there is a function <span class="math inline">\(f : \mathbb{Z}^+ \to A\)</span> that is onto.</li>
<li>There is a function <span class="math inline">\(f : A \to \mathbb{Z}^+\)</span> that is one-to-one.</li>
</ol>
<p>We will find it convenient to phrase these statements a little differently in Lean. Our plan is to prove that if <code>A</code> has type <code>Set U</code> then the following statements are equivalent:</p>
<ol type="1">
<li><code>ctble A</code></li>
<li><code>empty A ∨ ∃ (f : Nat → U), A ⊆ range f</code></li>
<li><code>∃ (f : U → Nat), one_one_on f A</code></li>
</ol>
<p>As in <em>HTPI</em>, we will do this by proving 1 → 2 → 3 → 1. Here is the proof of 1 → 2.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_8_1_5_1_to_2 {U : <span class="kw">Type</span>} {A : Set U} (h : ctble A) :</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    empty A ∨ ∃ (f : Nat → U), A ⊆ range f := <span class="kw">by</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">or_right</span> <span class="kw">with</span> h1                          <span class="co">--h1 : ∃ (x : U), x ∈ A</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (a : U) (h2 : a ∈ A) <span class="kw">from</span> h1</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [ctble_iff_set_nat_equinum] <span class="kw">at</span> h  <span class="co">--h : ∃ (J : Set Nat), J ∼ A</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (J : Set Nat) (h3 : J ∼ A) <span class="kw">from</span> h</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (f : Nat → U) (h4 : one_one_on f J ∧ image f J = A) <span class="kw">from</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>    type_to_type_of_equinum h3 a</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro f                      <span class="co">--Goal : A ⊆ range f</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y : U</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h5 : y ∈ A</span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←h4.right] <span class="kw">at</span> h5</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h5</span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (n : Nat) (h6 : n ∈ J ∧ f n = y) <span class="kw">from</span> h5</span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←h6.right]</span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> f n ∈ range f <span class="kw">from</span> elt_range f n</span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For the proof of 2 → 3, we need to consider two cases. If <code>A</code> is empty, then any function <code>f : U → Nat</code> will do to prove statement 3; we use the constant function that always takes the value 0. The easiest way to prove that this function is one-to-one on <code>A</code> is to use a lemma that says if <code>A</code> is empty, then any statement of the form <code>x ∈ A → P</code> is true.</p>
<p>The more interesting case is when we have a function <code>g : Nat → U</code> with <code>A ⊆ range g</code>. This means that for each <code>x ∈ A</code>, there is at least one natural number <code>n</code> such that <code>g n = x</code>. As in <em>HTPI</em>, we first define a function <code>F : A → Nat</code> that picks out the <em>smallest</em> such <code>n</code>; we could call it the <em>smallest preimage of <code>x</code></em>. We then use <code>func_extend</code> to get the required function from <code>U</code> to <code>Nat</code>. The easiest way to define <code>F</code> is to first define its graph, which we call <code>smallest_preimage_graph g A</code>.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> constant_func (U : <span class="kw">Type</span>) {V : <span class="kw">Type</span>} (v : V) (x : U) : V := v</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> elt_empty_implies {U : <span class="kw">Type</span>} {A : Set U} {x : U} {P : <span class="kw">Prop</span>}</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    (h : empty A) : x ∈ A → P := <span class="kw">by</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : x ∈ A</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">contradict</span> h</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ∃ (x : U), x ∈ A <span class="kw">from</span> Exists.intro x h1</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> one_one_on_empty {U : <span class="kw">Type</span>} {A : Set U}</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>    (f : U → Nat) (h : empty A) : one_one_on f A := <span class="kw">by</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x1 : U; <span class="kw">fix</span> x2 : U</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> x1 ∈ A → x2 ∈ A → f x1 = f x2 → x1 = x2 <span class="kw">from</span></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>    elt_empty_implies h</span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> smallest_preimage_graph {U : <span class="kw">Type</span>}</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>  (g : Nat → U) (A : Set U) : Set (A × Nat) :=</span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>  {(x, n) : A × Nat | g n = x.val ∧ ∀ (m : Nat), g m = x.val → n ≤ m}</span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> spg_is_func_graph {U : <span class="kw">Type</span>} {g : Nat → U} {A : Set U}</span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a>    (h : A ⊆ range g) : is_func_graph (smallest_preimage_graph g A) := <span class="kw">by</span></span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : A</span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">exists_unique</span></span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Existence</span></span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">set</span> W : Set Nat := {n : Nat | g n = x.val}</span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h1 : ∃ (n : Nat), n ∈ W := h x.property</span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ∃ (y : Nat), (x, y) ∈ smallest_preimage_graph g A <span class="kw">from</span></span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a>      well_ord_princ W h1</span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb38-32"><a href="#cb38-32" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Uniqueness</span></span>
<span id="cb38-33"><a href="#cb38-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> n1 : Nat; <span class="kw">fix</span> n2 : Nat</span>
<span id="cb38-34"><a href="#cb38-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : (x, n1) ∈ smallest_preimage_graph g A</span>
<span id="cb38-35"><a href="#cb38-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : (x, n2) ∈ smallest_preimage_graph g A</span>
<span id="cb38-36"><a href="#cb38-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1; <span class="kw">define</span> <span class="kw">at</span> h2</span>
<span id="cb38-37"><a href="#cb38-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : n1 ≤ n2 := h1.right n2 h2.left</span>
<span id="cb38-38"><a href="#cb38-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : n2 ≤ n1 := h2.right n1 h1.left</span>
<span id="cb38-39"><a href="#cb38-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">linarith</span></span>
<span id="cb38-40"><a href="#cb38-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb38-41"><a href="#cb38-41" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb38-42"><a href="#cb38-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-43"><a href="#cb38-43" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> spg_one_one {U : <span class="kw">Type</span>} {g : Nat → U} {A : Set U} {f : A → Nat}</span>
<span id="cb38-44"><a href="#cb38-44" aria-hidden="true" tabindex="-1"></a>    (h : graph f = smallest_preimage_graph g A) : one_to_one f := <span class="kw">by</span></span>
<span id="cb38-45"><a href="#cb38-45" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a1 : A; <span class="kw">fix</span> a2 : A</span>
<span id="cb38-46"><a href="#cb38-46" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : f a1 = f a2</span>
<span id="cb38-47"><a href="#cb38-47" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> y : Nat := f a2           <span class="co">--h1 : f a1 = y</span></span>
<span id="cb38-48"><a href="#cb38-48" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : f a2 = y := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb38-49"><a href="#cb38-49" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←graph_def, h] <span class="kw">at</span> h1 <span class="co">--h1 : (a1, y) ∈ smallest_preimage_graph g A</span></span>
<span id="cb38-50"><a href="#cb38-50" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←graph_def, h] <span class="kw">at</span> h2 <span class="co">--h2 : (a2, y) ∈ smallest_preimage_graph g A</span></span>
<span id="cb38-51"><a href="#cb38-51" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1                  <span class="co">--h1 : g y = a1.val ∧ ...</span></span>
<span id="cb38-52"><a href="#cb38-52" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2                  <span class="co">--h2 : g y = a2.val ∧ ...</span></span>
<span id="cb38-53"><a href="#cb38-53" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Subtype.ext             <span class="co">--Goal : a1.val = a2.val</span></span>
<span id="cb38-54"><a href="#cb38-54" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←h1.left, ←h2.left]</span>
<span id="cb38-55"><a href="#cb38-55" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rfl</span></span>
<span id="cb38-56"><a href="#cb38-56" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb38-57"><a href="#cb38-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-58"><a href="#cb38-58" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_8_1_5_2_to_3 {U : <span class="kw">Type</span>} {A : Set U}</span>
<span id="cb38-59"><a href="#cb38-59" aria-hidden="true" tabindex="-1"></a>    (h : empty A ∨ ∃ (f : Nat → U), A ⊆ range f) :</span>
<span id="cb38-60"><a href="#cb38-60" aria-hidden="true" tabindex="-1"></a>    ∃ (f : U → Nat), one_one_on f A := <span class="kw">by</span></span>
<span id="cb38-61"><a href="#cb38-61" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> <span class="kw">on</span> h</span>
<span id="cb38-62"><a href="#cb38-62" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h : empty A</span></span>
<span id="cb38-63"><a href="#cb38-63" aria-hidden="true" tabindex="-1"></a>    <span class="kw">set</span> f : U → Nat := constant_func U 0</span>
<span id="cb38-64"><a href="#cb38-64" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro f</span>
<span id="cb38-65"><a href="#cb38-65" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> one_one_on f A <span class="kw">from</span> one_one_on_empty f h</span>
<span id="cb38-66"><a href="#cb38-66" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb38-67"><a href="#cb38-67" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h : ∃ (f : Nat → U), A ⊆ range f</span></span>
<span id="cb38-68"><a href="#cb38-68" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (g : Nat → U) (h1 : A ⊆ range g) <span class="kw">from</span> h</span>
<span id="cb38-69"><a href="#cb38-69" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : is_func_graph (smallest_preimage_graph g A) :=</span>
<span id="cb38-70"><a href="#cb38-70" aria-hidden="true" tabindex="-1"></a>      spg_is_func_graph h1</span>
<span id="cb38-71"><a href="#cb38-71" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←func_from_graph] <span class="kw">at</span> h2</span>
<span id="cb38-72"><a href="#cb38-72" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (F : A → Nat)</span>
<span id="cb38-73"><a href="#cb38-73" aria-hidden="true" tabindex="-1"></a>      (h3 : graph F = smallest_preimage_graph g A) <span class="kw">from</span> h2</span>
<span id="cb38-74"><a href="#cb38-74" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : one_to_one F := spg_one_one h3</span>
<span id="cb38-75"><a href="#cb38-75" aria-hidden="true" tabindex="-1"></a>    <span class="kw">set</span> f : U → Nat := func_extend F 0</span>
<span id="cb38-76"><a href="#cb38-76" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro f</span>
<span id="cb38-77"><a href="#cb38-77" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> one_one_on f A <span class="kw">from</span> fe_one_one_on_of_one_one h4 0</span>
<span id="cb38-78"><a href="#cb38-78" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb38-79"><a href="#cb38-79" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, the proof of 3 → 1 is straightforward, using the theorem <code>equinum_image</code>.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_8_1_5_3_to_1 {U : <span class="kw">Type</span>} {A : Set U}</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ∃ (f : U → Nat), one_one_on f A) :</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    ctble A := <span class="kw">by</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (f : U → Nat) (h2 : one_one_on f A) <span class="kw">from</span> h1</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : A ∼ image f A := equinum_image h2</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [ctble_iff_set_nat_equinum]</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ∃ (J : Set Nat), J ∼ A <span class="kw">from</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    Exists.intro (image f A) (Theorem_8_1_3_2 h3)</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We now know that statements 1–3 are equivalent, which means that statements 2 and 3 can be thought of as alternative ways to think about countability:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_8_1_5_2 {U : <span class="kw">Type</span>} (A : Set U) :</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    ctble A ↔ empty A ∨ ∃ (f : Nat → U), A ⊆ range f := <span class="kw">by</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro Theorem_8_1_5_1_to_2</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : empty A ∨ ∃ (f : Nat → U), A ⊆ range f</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : ∃ (f : U → Nat), one_one_on f A := Theorem_8_1_5_2_to_3 h1</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ctble A <span class="kw">from</span> Theorem_8_1_5_3_to_1 h2</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_8_1_5_3 {U : <span class="kw">Type</span>} (A : Set U) :</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>    ctble A ↔ ∃ (f : U → Nat), one_one_on f A := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We end this section with a proof of Theorem 8.1.6 in <em>HTPI</em>, which says that the set of rational numbers is denumerable. Our strategy is to define a one-to-one function from <code>Rat</code> (the type of rational numbers) to <code>Nat</code>. We will need to know a little bit about the way rational numbers are represented in Lean. If <code>q</code> has type <code>Rat</code>, then when <code>q</code> is written in lowest terms, <code>q.num</code> is the numerator, which is an integer, and <code>q.den</code> is the denominator, which is a nonzero natural number. The theorem <code>Rat.ext</code> says that if two rational numbers have the same numerator and denominator, then they are equal. And we will also use the theorem <code>Prod.mk.inj</code>, which says that if two ordered pairs are equal, then their first coordinates are equal, as are their second coordinates.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fqn (q : Rat) : Nat := fnnn (fzn q.num, q.den)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fqn_def (q : Rat) : fqn q = fnnn (fzn q.num, q.den) := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fqn_one_one : one_to_one fqn := <span class="kw">by</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> q1 : Rat; <span class="kw">fix</span> q2 : Rat</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : fqn q1 = fqn q2</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [fqn_def, fqn_def] <span class="kw">at</span> h1</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">--h1 : fnnn (fzn q1.num, q1.den) = fnnn (fzn q2.num, q2.den)</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : (fzn q1.num, q1.den) = (fzn q2.num, q2.den) :=</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>    fnnn_one_one _ _ h1</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : fzn q1.num = fzn q2.num ∧ q1.den = q2.den :=</span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>    Prod.mk.inj h2</span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : q1.num = q2.num := fzn_one_one _ _ h3.left</span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> q1 = q2 <span class="kw">from</span> Rat.ext h4 h3.right</span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> range_fqn_unbdd :</span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a>    ∀ (m : Nat), ∃ n ∈ range fqn, n ≥ m := <span class="kw">by</span></span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> m : Nat</span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> n : Nat := fqn ↑m</span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro n</span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro</span>
<span id="cb41-25"><a href="#cb41-25" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that n ∈ range fqn</span></span>
<span id="cb41-26"><a href="#cb41-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb41-27"><a href="#cb41-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro ↑m</span>
<span id="cb41-28"><a href="#cb41-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb41-29"><a href="#cb41-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb41-30"><a href="#cb41-30" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that n ≥ m</span></span>
<span id="cb41-31"><a href="#cb41-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> n ≥ m <span class="kw">from</span></span>
<span id="cb41-32"><a href="#cb41-32" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> n</span>
<span id="cb41-33"><a href="#cb41-33" aria-hidden="true" tabindex="-1"></a>        _ = tri (2 * m + 1) + 2 * m := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb41-34"><a href="#cb41-34" aria-hidden="true" tabindex="-1"></a>        _ ≥ m := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb41-35"><a href="#cb41-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb41-36"><a href="#cb41-36" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb41-37"><a href="#cb41-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-38"><a href="#cb41-38" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_8_1_6 : denum Rat := <span class="kw">by</span></span>
<span id="cb41-39"><a href="#cb41-39" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> I : Set Nat := range fqn</span>
<span id="cb41-40"><a href="#cb41-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h1 : Nat ∼ I := unbdd_subset_nat range_fqn_unbdd</span>
<span id="cb41-41"><a href="#cb41-41" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : Rat ∼ I := equinum_range fqn_one_one</span>
<span id="cb41-42"><a href="#cb41-42" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : I ∼ Rat := Theorem_8_1_3_2 h2</span>
<span id="cb41-43"><a href="#cb41-43" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> denum Rat <span class="kw">from</span> Theorem_8_1_3_3 h1 h3</span>
<span id="cb41-44"><a href="#cb41-44" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="exercises" class="level3">
<h3 class="anchored" data-anchor-id="exercises">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb42"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint:  Use Exercise_6_1_16a2 from the exercises of Section 6.1.</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fnz_odd (k : Nat) : fnz (2 * k + 1) = -↑(k + 1) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb43"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> fnz_fzn : fnz ∘ fzn = id  := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb44"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> tri_step (k : Nat) : tri (k + 1) = tri k + k + 1 := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb45"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> tri_incr {j k : Nat} (h1 : j ≤ k) : tri j ≤ tri k := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb46"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {U V : <span class="kw">Type</span>} (f : U → V) : range f = Ran (graph f) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="6">
<div class="sourceCode" id="cb47"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> onto_iff_range_eq_univ {U V : <span class="kw">Type</span>} (f : U → V) :</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    onto f ↔ range f = Univ V := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>7. Notice that <code>ctble_of_ctble_equinum</code> was used in the proof of <code>ctble_iff_set_nat_equinum</code>. Therefore, to avoid circularity, you must not use <code>ctble_iff_set_nat_equinum</code> in your solution to this exercise.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> ctble_of_ctble_equinum {U V : <span class="kw">Type</span>}</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    (h1 : U ∼ V) (h2 : ctble U) : ctble V := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="numex" data-arguments="8">
<div class="sourceCode" id="cb49"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_8_1_1_b : denum {n : Int | even n} := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="9">
<div class="sourceCode" id="cb50"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> equinum_iff_inverse_pair (U V : <span class="kw">Type</span>) :</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    U ∼ V ↔ ∃ (f : U → V) (g : V → U), f ∘ g = id ∧ g ∘ f = id := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>10. Notice that if <code>f</code> is a function from <code>U</code> to <code>V</code>, then for every <code>X</code> of type <code>Set U</code>, <code>image f X</code> has type <code>Set V</code>. Therefore <code>image f</code> is a function from <code>Set U</code> to <code>Set V</code>.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> image_comp_id {U V : <span class="kw">Type</span>} {f : U → V} {g : V → U}</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    (h : g ∘ f = id) : (image g) ∘ (image f) = id := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="numex" data-arguments="11">
<div class="sourceCode" id="cb52"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_8_1_5_1 {U V : <span class="kw">Type</span>}</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>    (h : U ∼ V) : Set U ∼ Set V := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="mdsk">

</div>
<p>If <code>A</code> has type <code>Set U</code> and <code>X</code> has type <code>Set A</code> (that is, <code>Set ↑A</code>), then every element of <code>X</code> has type <code>↑A</code>, which means that its value is an element of <code>A</code>. Thus, if we take the values of all the elements of <code>X</code>, we will get a set of type <code>Set U</code> that is a subset of <code>A</code>. We will call this the <em>value image</em> of <code>X</code>. We can define a function that computes the value image of any <code>X : Set A</code>:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> val_image {U : <span class="kw">Type</span>} (A : Set U) (X : Set A) : Set U :=</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>  {y : U | ∃ x ∈ X, x.val = y}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The next three exercises ask you to prove properties of this function.</p>
<div class="numex" data-arguments="12">
<div class="sourceCode" id="cb54"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> subset_of_val_image_eq {U : <span class="kw">Type</span>} {A : Set U} {X1 X2 : Set A}</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>    (h : val_image A X1 = val_image A X2) : X1 ⊆ X2 := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="13">
<div class="sourceCode" id="cb55"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> val_image_one_one {U : <span class="kw">Type</span>} (A : Set U) :</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>    one_to_one (val_image A) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="14">
<div class="sourceCode" id="cb56"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> range_val_image {U : <span class="kw">Type</span>} (A : Set U) :</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>    range (val_image A) = 𝒫 A := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="15">
<div class="sourceCode" id="cb57"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Set_equinum_powerset {U : <span class="kw">Type</span>} (A : Set U) :</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>    Set A ∼ 𝒫 A := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="16">
<div class="sourceCode" id="cb58"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint:  Use Exercise_8_1_5_1 and Set_equinum_powerset.</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_8_1_5_2 {U V : <span class="kw">Type</span>} {A : Set U} {B : Set V}</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    (h : A ∼ B) : 𝒫 A ∼ 𝒫 B := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="17">
<div class="sourceCode" id="cb59"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (U V : <span class="kw">Type</span>) (A : Set U) (f : A → V) (v : V) :</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>    func_restrict (func_extend f v) A = f := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>18. We proved the implications in Theorem 8.1.5 for sets, but we could prove similar theorems for types. Here is a version of <code>Theorem_8_1_5_3</code> for types.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_8_1_5_3_type {U : <span class="kw">Type</span>} :</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>    ctble U ↔ ∃ (f : U → Nat), one_to_one f := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="numex" data-arguments="19">
<div class="sourceCode" id="cb61"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> ctble_set_of_ctble_type {U : <span class="kw">Type</span>}</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>    (h : ctble U) (A : Set U) : ctble A := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="20">
<div class="sourceCode" id="cb62"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_8_1_17 {U : <span class="kw">Type</span>} {A B : Set U}</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>    (h1 : B ⊆ A) (h2 : ctble A) : ctble B := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="debts-paid" class="level2">
<h2 class="anchored" data-anchor-id="debts-paid">8.1½. Debts Paid</h2>
<p>It is time to fulfill promises we made in two earlier chapters.</p>
<p>In Section 6.2, we promised to define a proposition <code>numElts A n</code> to express the idea that the set <code>A</code> has <code>n</code> elements. It should now be clear how to define this proposition:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> numElts {U : <span class="kw">Type</span>} (A : Set U) (n : Nat) : <span class="kw">Prop</span> := I n ∼ A</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> numElts_def {U : <span class="kw">Type</span>} (A : Set U) (n : Nat) :</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>    numElts A n ↔ I n ∼ A := <span class="kw">by</span> <span class="kw">rfl</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It is sometimes convenient to phrase the definition of <code>finite</code> in terms of <code>numElts</code>, so we state that version of the definition as a lemma.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> finite_def {U : <span class="kw">Type</span>} (A : Set U) :</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>    finite A ↔ ∃ (n : Nat), numElts A n := <span class="kw">by</span> <span class="kw">rfl</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We also owe you the proofs of several theorems about <code>numElts</code>. We’ll skip the details of some of these proofs, but for those that are not left as exercises, you can find all the details in the HTPI Lean package. We begin with the fact that a set has zero elements if and only if it is empty. If <code>A</code> has type <code>Set U</code> and <code>A</code> is empty, then any function from <code>U</code> to <code>Nat</code> can be used to prove <code>A ∼ I 0</code>. In the proof below, we use a constant function.</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> not_empty_iff_exists_elt {U : <span class="kw">Type</span>} {A : Set U} :</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    ¬empty A ↔ ∃ (x : U), x ∈ A := <span class="kw">by</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> : empty A</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">double_neg</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rfl</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> image_empty {U : <span class="kw">Type</span>} {A : Set U}</span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>    (f : U → Nat) (h : empty A) : image f A = I 0 := <span class="cn">sorry</span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> zero_elts_iff_empty {U : <span class="kw">Type</span>} (A : Set U) :</span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>    numElts A 0 ↔ empty A := <span class="kw">by</span></span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : numElts A 0</span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (f : I 0 → A) (h2 : one_to_one f ∧ onto f) <span class="kw">from</span> h1</span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">by_contra</span> h3</span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [not_empty_iff_exists_elt] <span class="kw">at</span> h3</span>
<span id="cb65-20"><a href="#cb65-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (x : U) (h4 : x ∈ A) <span class="kw">from</span> h3</span>
<span id="cb65-21"><a href="#cb65-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">set</span> xA : A := Subtype_elt h4</span>
<span id="cb65-22"><a href="#cb65-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (n : I 0) (h5 : f n = xA) <span class="kw">from</span> h2.right xA</span>
<span id="cb65-23"><a href="#cb65-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h6 : n.val &lt; 0 := n.property</span>
<span id="cb65-24"><a href="#cb65-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">linarith</span></span>
<span id="cb65-25"><a href="#cb65-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb65-26"><a href="#cb65-26" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb65-27"><a href="#cb65-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : empty A</span>
<span id="cb65-28"><a href="#cb65-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [numElts_def]</span>
<span id="cb65-29"><a href="#cb65-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">set</span> f : U → Nat := constant_func U 0</span>
<span id="cb65-30"><a href="#cb65-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : one_one_on f A := one_one_on_empty f h1</span>
<span id="cb65-31"><a href="#cb65-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : image f A = I 0 := image_empty f h1</span>
<span id="cb65-32"><a href="#cb65-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : A ∼ image f A := equinum_image h2</span>
<span id="cb65-33"><a href="#cb65-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h3] <span class="kw">at</span> h4</span>
<span id="cb65-34"><a href="#cb65-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> I 0 ∼ A <span class="kw">from</span> Theorem_8_1_3_2 h4</span>
<span id="cb65-35"><a href="#cb65-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb65-36"><a href="#cb65-36" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Next, we prove that if a set has a positive number of elements then it is not empty. The proof is straightforward.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> nonempty_of_pos_numElts {U : <span class="kw">Type</span>} {A : Set U} {n : Nat}</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>    (h1 : numElts A n) (h2 : n &gt; 0) : ∃ (x : U), x ∈ A := <span class="kw">by</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (f : I n → A) (h3 : one_to_one f ∧ onto f) <span class="kw">from</span> h1</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : 0 ∈ I n := h2</span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> x : A := f (Subtype_elt h4)</span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ∃ (x : U), x ∈ A <span class="kw">from</span> Exists.intro x.val x.property</span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Our next theorem is <code>remove_one_numElts</code>, which says that if a set has <code>n + 1</code> elements, and we remove one element, then the resulting set has <code>n</code> elements. We begin by proving that for any <code>k &lt; n + 1</code>, if we remove <code>k</code> from <code>I (n + 1)</code> then the resulting set is equinumerous with <code>I n</code>. To do this, we define a function that matches up <code>I n</code> with <code>I (n + 1) \ {k}</code>.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> incr_from (k n : Nat) : Nat := if n &lt; k then n else n + 1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The function <code>incr_from k</code> increments natural numbers from <code>k</code> on, while leaving numbers less than <code>k</code> fixed. Our strategy now is to prove that <code>incr_from k</code> is one-to-one on <code>I n</code>, and the image of <code>I n</code> under <code>incr_from k</code> is <code>I (n + 1) \ {k}</code>. The proof is a bit long, so we skip some of the details. Notice that Lean gets confused when coercing <code>I (n + 1) \ {k}</code> to a subtype unless we specify that we want <code>↑(I (n + 1) \ {k})</code> rather than <code>↑(I (n + 1)) \ ↑{k}</code>.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> incr_from_one_one (k : Nat) :</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>    one_to_one (incr_from k) := <span class="cn">sorry</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> incr_from_image {k n : Nat} (h : k &lt; n + 1) :</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>    image (incr_from k) (I n) = I (n + 1) \ {k} := <span class="cn">sorry</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> one_one_on_of_one_one {U V : <span class="kw">Type</span>} {f : U → V}</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>    (h : one_to_one f) (A : Set U) : one_one_on f A := <span class="kw">by</span></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x1 : U; <span class="kw">fix</span> x2 : U</span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : x1 ∈ A</span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : x2 ∈ A</span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> f x1 = f x2 → x1 = x2 <span class="kw">from</span> h x1 x2</span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> I_equinum_I_remove_one {k n : Nat}</span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true" tabindex="-1"></a>    (h : k &lt; n + 1) : I n ∼ ↑(I (n + 1) \ {k}) := <span class="kw">by</span></span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←incr_from_image h]</span>
<span id="cb68-19"><a href="#cb68-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> I n ∼ image (incr_from k) (I n) <span class="kw">from</span></span>
<span id="cb68-20"><a href="#cb68-20" aria-hidden="true" tabindex="-1"></a>    equinum_image (one_one_on_of_one_one (incr_from_one_one k) (I n))</span>
<span id="cb68-21"><a href="#cb68-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Using one more lemma, whose proof we leave as an exercise for you, we can prove <code>remove_one_numElts</code>.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> remove_one_equinum</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>    {U V : <span class="kw">Type</span>} {A : Set U} {B : Set V} {a : U} {b : V} {f : U → V}</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>    (h1 : one_one_on f A) (h2 : image f A = B)</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>    (h3 : a ∈ A) (h4 : f a = b) : ↑(A \ {a}) ∼ ↑(B \ {b}) := <span class="cn">sorry</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> remove_one_numElts {U : <span class="kw">Type</span>} {A : Set U} {n : Nat} {a : U}</span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>    (h1 : numElts A (n + 1)) (h2 : a ∈ A) : numElts (A \ {a}) n := <span class="kw">by</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [numElts_def] <span class="kw">at</span> h1; <span class="kw">rewrite</span> [numElts_def]</span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">--h1 : I (n + 1) ∼ A;  Goal : I n ∼ ↑(A \ {a})</span></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (f : Nat → U) (h3 : one_one_on f (I (n + 1)) ∧</span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>    image f (I (n + 1)) = A) <span class="kw">from</span> type_to_type_of_equinum h1 a</span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←h3.right] <span class="kw">at</span> h2</span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (k : Nat) (h4 : k ∈ I (n + 1) ∧ f k = a) <span class="kw">from</span> h2</span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : ↑(I (n + 1) \ {k}) ∼ ↑(A \ {a}) :=</span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a>    remove_one_equinum h3.left h3.right h4.left h4.right</span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : k &lt; n + 1 := h4.left</span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h7 : I n ∼ ↑(I (n + 1) \ {k}) := I_equinum_I_remove_one h6</span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> I n ∼ ↑(A \ {a}) <span class="kw">from</span> Theorem_8_1_3_3 h7 h5</span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, we prove that a set has one element if and only if it is a singleton set, leaving the proof of one lemma as an exercise for you.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> singleton_of_diff_empty {U : <span class="kw">Type</span>} {A : Set U} {a : U}</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>    (h1 : a ∈ A) (h2 : empty (A \ {a})) : A = {a} := <span class="cn">sorry</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> one_one_on_I_1 {U : <span class="kw">Type</span>} (f : Nat → U) : one_one_on f (I 1) := <span class="kw">by</span></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x1 : Nat; <span class="kw">fix</span> x2 : Nat</span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : x1 ∈ I 1</span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : x2 ∈ I 1</span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : f x1 = f x2</span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1; <span class="kw">define</span> <span class="kw">at</span> h2   <span class="co">--h1 : x1 &lt; 1; h2 : x2 &lt; 1</span></span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">linarith</span></span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> image_I_1 {U : <span class="kw">Type</span>} (f : Nat → U) : image f (I 1) = {f 0} := <span class="kw">by</span></span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> y</span>
<span id="cb70-16"><a href="#cb70-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb70-17"><a href="#cb70-17" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb70-18"><a href="#cb70-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : y ∈ image f (I 1)</span>
<span id="cb70-19"><a href="#cb70-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1; <span class="kw">define</span></span>
<span id="cb70-20"><a href="#cb70-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (x : Nat) (h2 : x ∈ I 1 ∧ f x = y) <span class="kw">from</span> h1</span>
<span id="cb70-21"><a href="#cb70-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : x &lt; 1 := h2.left</span>
<span id="cb70-22"><a href="#cb70-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : x = 0 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb70-23"><a href="#cb70-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←h2.right, h4]</span>
<span id="cb70-24"><a href="#cb70-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb70-25"><a href="#cb70-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb70-26"><a href="#cb70-26" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb70-27"><a href="#cb70-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : y ∈ {f 0}</span>
<span id="cb70-28"><a href="#cb70-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1; <span class="kw">define</span></span>
<span id="cb70-29"><a href="#cb70-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro 0</span>
<span id="cb70-30"><a href="#cb70-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro _ h1.symm</span>
<span id="cb70-31"><a href="#cb70-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb70-32"><a href="#cb70-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">linarith</span></span>
<span id="cb70-33"><a href="#cb70-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb70-34"><a href="#cb70-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb70-35"><a href="#cb70-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-36"><a href="#cb70-36" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> singleton_one_elt {U : <span class="kw">Type</span>} (u : U) : numElts {u} 1 := <span class="kw">by</span></span>
<span id="cb70-37"><a href="#cb70-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [numElts_def]  <span class="co">--Goal : I 1 ∼ {u}</span></span>
<span id="cb70-38"><a href="#cb70-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> f : Nat → U := constant_func Nat u</span>
<span id="cb70-39"><a href="#cb70-39" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h1 : one_one_on f (I 1) := one_one_on_I_1 f</span>
<span id="cb70-40"><a href="#cb70-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : image f (I 1) = {f 0} := image_I_1 f</span>
<span id="cb70-41"><a href="#cb70-41" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : f 0 = u := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb70-42"><a href="#cb70-42" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←h3, ←h2]</span>
<span id="cb70-43"><a href="#cb70-43" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> I 1 ∼ image f (I 1) <span class="kw">from</span> equinum_image h1</span>
<span id="cb70-44"><a href="#cb70-44" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb70-45"><a href="#cb70-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-46"><a href="#cb70-46" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> one_elt_iff_singleton {U : <span class="kw">Type</span>} (A : Set U) :</span>
<span id="cb70-47"><a href="#cb70-47" aria-hidden="true" tabindex="-1"></a>    numElts A 1 ↔ ∃ (x : U), A = {x} := <span class="kw">by</span></span>
<span id="cb70-48"><a href="#cb70-48" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb70-49"><a href="#cb70-49" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb70-50"><a href="#cb70-50" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : numElts A 1  <span class="co">--Goal : ∃ (x : U), A = {x}</span></span>
<span id="cb70-51"><a href="#cb70-51" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : 1 &gt; 0 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb70-52"><a href="#cb70-52" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (x : U) (h3 : x ∈ A) <span class="kw">from</span> nonempty_of_pos_numElts h1 h2</span>
<span id="cb70-53"><a href="#cb70-53" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : numElts (A \ {x}) 0 := remove_one_numElts h1 h3</span>
<span id="cb70-54"><a href="#cb70-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [zero_elts_iff_empty] <span class="kw">at</span> h4</span>
<span id="cb70-55"><a href="#cb70-55" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ∃ (x : U), A = {x} <span class="kw">from</span></span>
<span id="cb70-56"><a href="#cb70-56" aria-hidden="true" tabindex="-1"></a>      Exists.intro x (singleton_of_diff_empty h3 h4)</span>
<span id="cb70-57"><a href="#cb70-57" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb70-58"><a href="#cb70-58" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb70-59"><a href="#cb70-59" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : ∃ (x : U), A = {x}</span>
<span id="cb70-60"><a href="#cb70-60" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (x : U) (h2 : A = {x}) <span class="kw">from</span> h1</span>
<span id="cb70-61"><a href="#cb70-61" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h2]</span>
<span id="cb70-62"><a href="#cb70-62" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> numElts {x} 1 <span class="kw">from</span> singleton_one_elt x</span>
<span id="cb70-63"><a href="#cb70-63" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb70-64"><a href="#cb70-64" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We have now proven all of the theorems about <code>numElts</code> whose proofs were promised in Section 6.2. However, there is still one important issue that we have not addressed. Could there be a set <code>A</code> such that, say, <code>numElts A 5</code> and <code>numElts A 6</code> are both true? Surely the answer is no—a set can’t have five elements and also have six elements! But it requires proof. We ask you to prove the following theorem in the exercises.</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_8_1_6b {U : <span class="kw">Type</span>} {A : Set U} {m n : Nat}</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>    (h1 : numElts A m) (h2 : numElts A n) : m = n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Next, we turn to our promise, at the end of Section 7.4, to prove Theorem 7.4.4 of <em>HTPI</em>, which says that the totient function <span class="math inline">\(\varphi\)</span> is multiplicative.</p>
<p>To define the totient function in Lean, in Chapter 7 we defined <code>phi m</code> to be <code>num_rp_below m m</code>, where <code>num_rp_below m k</code> is the number of natural numbers less than <code>k</code> that are relatively prime to <code>m</code>. But in this chapter we have developed new methods for counting things. Our first task is to show that these new methods agree with the method used in Chapter 7.</p>
<p>We have already remarked that the definition of <code>num_elts_below</code> in this chapter bears some resemblance to the definition of <code>num_rp_below</code> in Chapter 7. It should not be surprising, therefore, that these two counting methods give results that agree.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> set_rp_below (m : Nat) : Set Nat := {n : Nat | rel_prime m n ∧ n &lt; m}</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> set_rp_below_def (a m : Nat) :</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>    a ∈ set_rp_below m ↔ rel_prime m a ∧ a &lt; m := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> neb_nrpb (m : Nat) : ∀ ⦃k : Nat⦄, k ≤ m →</span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>    num_elts_below (set_rp_below m) k = num_rp_below m k := <span class="cn">sorry</span></span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> neb_phi (m : Nat) :</span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a>    num_elts_below (set_rp_below m) m = phi m := <span class="kw">by</span></span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [phi_def]</span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h1 : m ≤ m := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> num_elts_below (set_rp_below m) m = num_rp_below m m <span class="kw">from</span></span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a>    neb_nrpb m h1</span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb72-16"><a href="#cb72-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-17"><a href="#cb72-17" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> phi_is_numElts (m : Nat) :</span>
<span id="cb72-18"><a href="#cb72-18" aria-hidden="true" tabindex="-1"></a>    numElts (set_rp_below m) (phi m) := <span class="kw">by</span></span>
<span id="cb72-19"><a href="#cb72-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [numElts_def, ←neb_phi m]</span>
<span id="cb72-20"><a href="#cb72-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">--Goal : I (num_elts_below (set_rp_below m) m) ∼ set_rp_below m</span></span>
<span id="cb72-21"><a href="#cb72-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h1 : ∀ n ∈ set_rp_below m, n &lt; m := <span class="kw">by</span></span>
<span id="cb72-22"><a href="#cb72-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> n : Nat</span>
<span id="cb72-23"><a href="#cb72-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : n ∈ set_rp_below m</span>
<span id="cb72-24"><a href="#cb72-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h2</span>
<span id="cb72-25"><a href="#cb72-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> n &lt; m <span class="kw">from</span> h2.right</span>
<span id="cb72-26"><a href="#cb72-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb72-27"><a href="#cb72-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> I (num_elts_below (set_rp_below m) m) ∼ set_rp_below m <span class="kw">from</span></span>
<span id="cb72-28"><a href="#cb72-28" aria-hidden="true" tabindex="-1"></a>    bdd_subset_nat h1</span>
<span id="cb72-29"><a href="#cb72-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>According to the last lemma, we can now think of <code>phi m</code> as the number of elements of the set <code>set_rp_below m</code>.</p>
<p>We will need one more number-theoretic fact: Lemma 7.4.7 from <em>HTPI</em>. We follow the strategy of the proof in <em>HTPI</em>, separating out one calculation as an auxiliary lemma before giving the main proof.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_7_4_7_aux {m n : Nat} {s t : Int}</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>    (h : s * m + t * n = 1) (a b : Nat) :</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>    t * n * a + s * m * b ≡ a (MOD m) := <span class="kw">by</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (s * (b - a))</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> t * n * a + s * m * b - a = m * (s * (b - a)) <span class="kw">from</span></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> t * n * a + s * m * b - a</span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>      _ = (t * n - 1) * a + s * m * b := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>      _ = (t * n - (s * m + t * n)) * a + s * m * b := <span class="kw">by</span> <span class="kw">rw</span> [h]</span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>      _ = m * (s * (b - a)) := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_7_4_7 {m n : Nat} [NeZero m] [NeZero n]</span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a>    (h1 : rel_prime m n) (a b : Nat) :</span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a>    ∃ (r : Nat), r &lt; m * n ∧ r ≡ a (MOD m) ∧ r ≡ b (MOD n) := <span class="kw">by</span></span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> s : Int := gcd_c1 m n</span>
<span id="cb73-17"><a href="#cb73-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> t : Int := gcd_c2 m n</span>
<span id="cb73-18"><a href="#cb73-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : s * m + t * n = gcd m n := gcd_lin_comb n m</span>
<span id="cb73-19"><a href="#cb73-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1                      <span class="co">--h1 : gcd m n = 1</span></span>
<span id="cb73-20"><a href="#cb73-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h1, Nat.cast_one] <span class="kw">at</span> h4  <span class="co">--h4 : s * m + t * n = 1</span></span>
<span id="cb73-21"><a href="#cb73-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> x : Int := t * n * a + s * m * b</span>
<span id="cb73-22"><a href="#cb73-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : x ≡ a (MOD m) := Lemma_7_4_7_aux h4 a b</span>
<span id="cb73-23"><a href="#cb73-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [add_comm] <span class="kw">at</span> h4          <span class="co">--h4 : t * n + s * m = 1</span></span>
<span id="cb73-24"><a href="#cb73-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : s * m * b + t * n * a ≡ b (MOD n) :=</span>
<span id="cb73-25"><a href="#cb73-25" aria-hidden="true" tabindex="-1"></a>    Lemma_7_4_7_aux h4 b a</span>
<span id="cb73-26"><a href="#cb73-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h7 : s * m * b + t * n * a = x := <span class="kw">by</span> <span class="kw">ring</span></span>
<span id="cb73-27"><a href="#cb73-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h7] <span class="kw">at</span> h6                <span class="co">--h6 : x ≡ b (MOD n)</span></span>
<span id="cb73-28"><a href="#cb73-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h8 : m * n ≠ 0 := mul_ne_zero (NeZero.ne m) (NeZero.ne n)</span>
<span id="cb73-29"><a href="#cb73-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←neZero_iff] <span class="kw">at</span> h8       <span class="co">--h8 : NeZero (m * n)</span></span>
<span id="cb73-30"><a href="#cb73-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h9 : 0 ≤ x % ↑(m * n) ∧ x % ↑(m * n) &lt; ↑(m * n) ∧</span>
<span id="cb73-31"><a href="#cb73-31" aria-hidden="true" tabindex="-1"></a>    x ≡ x % ↑(m * n) (MOD m * n) := mod_cmpl_res (m * n) x</span>
<span id="cb73-32"><a href="#cb73-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h10 : x % ↑(m * n) &lt; ↑(m * n) ∧</span>
<span id="cb73-33"><a href="#cb73-33" aria-hidden="true" tabindex="-1"></a>    x ≡ x % ↑(m * n) (MOD m * n) := h9.right</span>
<span id="cb73-34"><a href="#cb73-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> r : Nat := Int.toNat (x % ↑(m * n))</span>
<span id="cb73-35"><a href="#cb73-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h11 : x % ↑(m * n) = ↑r := (Int.toNat_of_nonneg h9.left).symm</span>
<span id="cb73-36"><a href="#cb73-36" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h11, Nat.cast_lt] <span class="kw">at</span> h10 <span class="co">--h10 : r &lt; m * n ∧ x ≡ r (MOD m * n)</span></span>
<span id="cb73-37"><a href="#cb73-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro r</span>
<span id="cb73-38"><a href="#cb73-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro h10.left</span>
<span id="cb73-39"><a href="#cb73-39" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h12 : r ≡ x (MOD (m * n)) := congr_symm h10.right</span>
<span id="cb73-40"><a href="#cb73-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [Lemma_7_4_5 _ _ h1] <span class="kw">at</span> h12 <span class="co">--h12 : r ≡ x (MOD m) ∧ r ≡ x (MOD n)</span></span>
<span id="cb73-41"><a href="#cb73-41" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro</span>
<span id="cb73-42"><a href="#cb73-42" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that r ≡ a (MOD m)</span></span>
<span id="cb73-43"><a href="#cb73-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> r ≡ a (MOD m) <span class="kw">from</span> congr_trans h12.left h5</span>
<span id="cb73-44"><a href="#cb73-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb73-45"><a href="#cb73-45" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that r ≡ b (MOD n)</span></span>
<span id="cb73-46"><a href="#cb73-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> r ≡ b (MOD n) <span class="kw">from</span> congr_trans h12.right h6</span>
<span id="cb73-47"><a href="#cb73-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb73-48"><a href="#cb73-48" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The next fact we need is part 1 of Theorem 8.1.2 in <em>HTPI</em>, which says that if <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(C\)</span>, and <span class="math inline">\(D\)</span> are sets such that <span class="math inline">\(A \sim B\)</span> and <span class="math inline">\(C \sim D\)</span>, then <span class="math inline">\(A \times C \sim B \times D\)</span>. It is straightforward to translate the <em>HTPI</em> proof into a Lean proof about Cartesian products of equinumerous types.</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> func_prod {U V W X : <span class="kw">Type</span>} (f : U → V) (g : W → X)</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>  (p : U × W) : V × X := (f p.1, g p.2)</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> func_prod_def {U V W X : <span class="kw">Type</span>}</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>    (f : U → V) (g : W → X) (u : U) (w : W) :</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>    func_prod f g (u, w) = (f u, g w) := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_8_1_2_1_type {U V W X : <span class="kw">Type</span>}</span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a>    (h1 : U ∼ V) (h2 : W ∼ X) : (U × W) ∼ (V × X) := <span class="kw">by</span></span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (f : U → V) (h3 : one_to_one f ∧ onto f) <span class="kw">from</span> h1</span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (g : W → X) (h4 : one_to_one g ∧ onto g) <span class="kw">from</span> h2</span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (func_prod f g)</span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro</span>
<span id="cb74-14"><a href="#cb74-14" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof of one_to_one (func_prod f g)</span></span>
<span id="cb74-15"><a href="#cb74-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> (u1, w1) : U × W; <span class="kw">fix</span> (u2, w2) : U × W</span>
<span id="cb74-16"><a href="#cb74-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h5 : func_prod f g (u1, w1) = func_prod f g (u2, w2)</span>
<span id="cb74-17"><a href="#cb74-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [func_prod_def, func_prod_def] <span class="kw">at</span> h5</span>
<span id="cb74-18"><a href="#cb74-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h6 : f u1 = f u2 ∧ g w1 = g w2 := Prod.mk.inj h5</span>
<span id="cb74-19"><a href="#cb74-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h7 : u1 = u2 := h3.left u1 u2 h6.left</span>
<span id="cb74-20"><a href="#cb74-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h8 : w1 = w2 := h4.left w1 w2 h6.right</span>
<span id="cb74-21"><a href="#cb74-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h7, h8]</span>
<span id="cb74-22"><a href="#cb74-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb74-23"><a href="#cb74-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb74-24"><a href="#cb74-24" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof of onto (func_prod f g)</span></span>
<span id="cb74-25"><a href="#cb74-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> (v, x) : V × X</span>
<span id="cb74-26"><a href="#cb74-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (u : U) (h5 : f u = v) <span class="kw">from</span> h3.right v</span>
<span id="cb74-27"><a href="#cb74-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (w : W) (h6 : g w = x) <span class="kw">from</span> h4.right x</span>
<span id="cb74-28"><a href="#cb74-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro (u, w)</span>
<span id="cb74-29"><a href="#cb74-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [func_prod_def, h5, h6]</span>
<span id="cb74-30"><a href="#cb74-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rfl</span></span>
<span id="cb74-31"><a href="#cb74-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Using coercions to subtypes, we can also apply this theorem to sets. If <code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code> are sets and we have <code>A ∼ B</code> and <code>C ∼ D</code>, then <code>Theorem_8_1_2_1_type</code> implies that <code>↑A × ↑C ∼ ↑B × ↑D</code>. Unfortunately, Cartesian products of subtypes are somewhat inconvenient to work with. It will turn out to be easier to work with subtypes of Cartesian products. To make this possible, we define a Cartesian product operation on sets:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> set_prod {U V : <span class="kw">Type</span>} (A : Set U) (B : Set V) : Set (U × V) :=</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>  {(a, b) : U × V | a ∈ A ∧ b ∈ B}</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a><span class="kw">notation</span>:75 A:75 <span class="st">" ×ₛ "</span> B:75 =&gt; set_prod A B</span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> set_prod_def {U V : <span class="kw">Type</span>} (A : Set U) (B : Set V) (a : U) (b : V) :</span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>    (a, b) ∈ A ×ₛ B ↔ a ∈ A ∧ b ∈ B := <span class="kw">by</span> <span class="kw">rfl</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To type the subscript <code>s</code> after <code>×</code>, type <code>\_s</code>. Thus, to type <code>×ₛ</code>, you can type <code>\times\_s</code> or <code>\x\_s</code>. Notice that in the <code>notation</code> command that introduces the symbol <code>×ₛ</code>, we have used the number <code>75</code> in positions where we used <code>50</code> when defining the notation <code>∼</code>. Without going into detail about exactly what the three occurrences of <code>50</code> and <code>75</code> mean, we will just say that this tells Lean that <code>×ₛ</code> is to be given higher precedence than <code>∼</code>, and as a result an expression like <code>A ∼ B ×ₛ C</code> will be interpreted as <code>A ∼ (B ×ₛ C)</code> rather than <code>(A ∼ B) ×ₛ C</code>.</p>
<p>According to this definition, if <code>A</code> has type <code>Set U</code> and <code>B</code> has type <code>Set V</code>, then <code>A ×ₛ B</code> has type <code>Set (U × V)</code>, and therefore <code>↑(A ×ₛ B)</code> is a subtype of <code>U × V</code>. There is an obvious correspondence between <code>↑(A ×ₛ B)</code> and <code>↑A × ↑B</code> that can be used to prove that they are equinumerous:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> elt_set_prod {U V : <span class="kw">Type</span>} {A : Set U} {B : Set V} (p : ↑A × ↑B) :</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>    (p.1.val, p.2.val) ∈ A ×ₛ B := And.intro p.1.property p.2.property</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prod_type_to_prod_set {U V : <span class="kw">Type</span>}</span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>  (A : Set U) (B : Set V) (p : ↑A × ↑B) : ↑(A ×ₛ B) :=</span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>  Subtype_elt (elt_set_prod p)</span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prod_set_to_prod_type {U V : <span class="kw">Type</span>}</span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a>  (A : Set U) (B : Set V) (p : ↑(A ×ₛ B)) : ↑A × ↑B :=</span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a>  (Subtype_elt p.property.left, Subtype_elt p.property.right)</span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> set_prod_equinum_type_prod {U V : <span class="kw">Type</span>} (A : Set U) (B : Set V) :</span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true" tabindex="-1"></a>    ↑(A ×ₛ B) ∼ (↑A × ↑B) := <span class="kw">by</span></span>
<span id="cb76-14"><a href="#cb76-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> F : ↑(A ×ₛ B) → ↑A × ↑B := prod_set_to_prod_type A B</span>
<span id="cb76-15"><a href="#cb76-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> G : ↑A × ↑B → ↑(A ×ₛ B) := prod_type_to_prod_set A B</span>
<span id="cb76-16"><a href="#cb76-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h1 : F ∘ G = id := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb76-17"><a href="#cb76-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : G ∘ F = id := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb76-18"><a href="#cb76-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : one_to_one F := Theorem_5_3_3_1 F G h2</span>
<span id="cb76-19"><a href="#cb76-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : onto F := Theorem_5_3_3_2 F G h1</span>
<span id="cb76-20"><a href="#cb76-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ↑(A ×ₛ B) ∼ (↑A × ↑B) <span class="kw">from</span> Exists.intro F (And.intro h3 h4)</span>
<span id="cb76-21"><a href="#cb76-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Using this lemma we can now prove a more convenient set version of the first part of Theorem 8.1.2.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_8_1_2_1_set</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>    {U V W X : <span class="kw">Type</span>} {A : Set U} {B : Set V} {C : Set W} {D : Set X}</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>    (h1 : A ∼ B) (h2 : C ∼ D) : A ×ₛ C ∼ B ×ₛ D := <span class="kw">by</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : ↑(A ×ₛ C) ∼ (↑A × ↑C) := set_prod_equinum_type_prod A C</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : (↑A × ↑C) ∼ (↑B × ↑D) := Theorem_8_1_2_1_type h1 h2</span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : ↑(B ×ₛ D) ∼ (↑B × ↑D) := set_prod_equinum_type_prod B D</span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : (↑B × ↑D) ∼ ↑(B ×ₛ D) := Theorem_8_1_3_2 h5</span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h7 : ↑(A ×ₛ C) ∼ (↑B × ↑D) := Theorem_8_1_3_3 h3 h4</span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ↑(A ×ₛ C) ∼ ↑(B ×ₛ D) <span class="kw">from</span> Theorem_8_1_3_3 h7 h6</span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>As explained in Section 7.4 of <em>HTPI</em>, a key fact used in the proof of Theorem 7.4.4 is that if <span class="math inline">\(A\)</span> is a set with <span class="math inline">\(m\)</span> elements and <span class="math inline">\(B\)</span> is a set with <span class="math inline">\(n\)</span> elements, then <span class="math inline">\(A \times B\)</span> has <span class="math inline">\(mn\)</span> elements. Section 7.4 of <em>HTPI</em> gives an intuitive explanation of this fact, but we’ll need to prove it in Lean. In other words, we need to prove the following theorem:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> numElts_prod {U V : <span class="kw">Type</span>} {A : Set U} {B : Set V} {m n : Nat}</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>    (h1 : numElts A m) (h2 : numElts B n) : numElts (A ×ₛ B) (m * n)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here’s our plan for this proof: The hypotheses <code>numElts A m</code> and <code>numElts B n</code> mean <code>I m ∼ A</code> and <code>I n ∼ B</code>. Applying <code>Theorem_8_1_2_1_set</code> to these hypotheses, we can infer <code>I m ×ₛ I n ∼ A ×ₛ B</code>. If we can prove that <code>I (m * n) ∼ I m ×ₛ I n</code>, then we’ll be able to conclude <code>I (m * n) ∼ A ×ₛ B</code>, or in other words <code>numElts (A ×ₛ B) (m * n)</code>, as required. Thus, the key to the proof is to show that <code>I (m * n) ∼ I m ×ₛ I n</code>.</p>
<p>To prove this, we’ll define a function from <code>Nat</code> to <code>Nat × Nat</code> that maps <code>I (m * n)</code> to <code>I m ×ₛ I n</code>. The function we will use maps a natural number <code>a</code> to the quotient and remainder when <code>a</code> is divided by <code>n</code>.</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> qr (n a : Nat) : Nat × Nat := (a / n, a % n)</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> qr_def (n a : Nat) : qr n a = (a / n, a % n) := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> qr_one_one (n : Nat) : one_to_one (qr n) := <span class="kw">by</span></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a1 : Nat; <span class="kw">fix</span> a2 : Nat</span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : qr n a1 = qr n a2       <span class="co">--Goal : a1 = a2</span></span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [qr_def, qr_def] <span class="kw">at</span> h1</span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : a1 / n = a2 / n ∧ a1 % n = a2 % n := Prod.mk.inj h1</span>
<span id="cb79-11"><a href="#cb79-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a1 = a2 <span class="kw">from</span></span>
<span id="cb79-12"><a href="#cb79-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> a1</span>
<span id="cb79-13"><a href="#cb79-13" aria-hidden="true" tabindex="-1"></a>      _ = n * (a1 / n) + a1 % n := (Nat.div_add_mod a1 n).symm</span>
<span id="cb79-14"><a href="#cb79-14" aria-hidden="true" tabindex="-1"></a>      _ = n * (a2 / n) + a2 % n := <span class="kw">by</span> <span class="kw">rw</span> [h2.left, h2.right]</span>
<span id="cb79-15"><a href="#cb79-15" aria-hidden="true" tabindex="-1"></a>      _ = a2 := Nat.div_add_mod a2 n</span>
<span id="cb79-16"><a href="#cb79-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb79-17"><a href="#cb79-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-18"><a href="#cb79-18" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> qr_image (m n : Nat) :</span>
<span id="cb79-19"><a href="#cb79-19" aria-hidden="true" tabindex="-1"></a>    image (qr n) (I (m * n)) = (I m) ×ₛ (I n) := <span class="cn">sorry</span></span>
<span id="cb79-20"><a href="#cb79-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-21"><a href="#cb79-21" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> I_prod (m n : Nat) : I (m * n) ∼ I m ×ₛ I n := <span class="kw">by</span></span>
<span id="cb79-22"><a href="#cb79-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←qr_image m n]</span>
<span id="cb79-23"><a href="#cb79-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> I (m * n) ∼ image (qr n) (I (m * n)) <span class="kw">from</span></span>
<span id="cb79-24"><a href="#cb79-24" aria-hidden="true" tabindex="-1"></a>    equinum_image (one_one_on_of_one_one (qr_one_one n) (I (m * n)))</span>
<span id="cb79-25"><a href="#cb79-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb79-26"><a href="#cb79-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-27"><a href="#cb79-27" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> numElts_prod {U V : <span class="kw">Type</span>} {A : Set U} {B : Set V} {m n : Nat}</span>
<span id="cb79-28"><a href="#cb79-28" aria-hidden="true" tabindex="-1"></a>    (h1 : numElts A m) (h2 : numElts B n) : numElts (A ×ₛ B) (m * n) := <span class="kw">by</span></span>
<span id="cb79-29"><a href="#cb79-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [numElts_def] <span class="kw">at</span> h1     <span class="co">--h1 : I m ∼ A</span></span>
<span id="cb79-30"><a href="#cb79-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [numElts_def] <span class="kw">at</span> h2     <span class="co">--h2 : I n ∼ B</span></span>
<span id="cb79-31"><a href="#cb79-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [numElts_def]           <span class="co">--Goal : I (m * n) ∼ A ×ₛ B</span></span>
<span id="cb79-32"><a href="#cb79-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : I m ×ₛ I n ∼ A ×ₛ B := Theorem_8_1_2_1_set h1 h2</span>
<span id="cb79-33"><a href="#cb79-33" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : I (m * n) ∼ I m ×ₛ I n := I_prod m n</span>
<span id="cb79-34"><a href="#cb79-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> I (m * n) ∼ A ×ₛ B <span class="kw">from</span> Theorem_8_1_3_3 h4 h3</span>
<span id="cb79-35"><a href="#cb79-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Our strategy for proving Theorem 7.4.4 will be to show that if <code>m</code> and <code>n</code> are relatively prime, then <code>set_rp_below (m * n) ∼ set_rp_below m ×ₛ set_rp_below n</code>. Once again, we use a function from <code>Nat</code> to <code>Nat × Nat</code> to show that these sets are equinumerous. This time, the function will map <code>a</code> to <code>(a % m, a % n)</code>.</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mod_mod (m n a : Nat) : Nat × Nat := (a % m, a % n)</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> mod_mod_def (m n a : Nat) : mod_mod m n a = (a % m, a % n) := <span class="kw">by</span> <span class="kw">rfl</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Our proof will make use of several theorems from the exercises of Sections 7.3 and 7.4:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> congr_rel_prime {m a b : Nat} (h1 : a ≡ b (MOD m)) :</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>    rel_prime m a ↔ rel_prime m b := <span class="cn">sorry</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> rel_prime_mod (m a : Nat) :</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>    rel_prime m (a % m) ↔ rel_prime m a := <span class="cn">sorry</span></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> congr_iff_mod_eq_Nat (m a b : Nat) [NeZero m] :</span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a>    ↑a ≡ ↑b (MOD m) ↔ a % m = b % m := <span class="cn">sorry</span></span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_7_4_6 {a b c : Nat} :</span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a>    rel_prime (a * b) c ↔ rel_prime a c ∧ rel_prime b c := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Combining these with other theorems from Chapter 7, we can now use <code>mod_mod m n</code> to show that <code>set_rp_below (m * n) ∼ set_rp_below m ×ₛ set_rp_below n</code>.</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> left_NeZero_of_mul {m n : Nat} (h : m * n ≠ 0) : NeZero m :=</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>  neZero_iff.rtl (left_ne_zero_of_mul h)</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> right_NeZero_of_mul {m n : Nat} (h : m * n ≠ 0) : NeZero n :=</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>  neZero_iff.rtl (right_ne_zero_of_mul h)</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> mod_mod_one_one_on {m n : Nat} (h1 : rel_prime m n) :</span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a>    one_one_on (mod_mod m n) (set_rp_below (m * n)) := <span class="kw">by</span></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> a1 : Nat; <span class="kw">fix</span> a2 : Nat</span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : a1 ∈ set_rp_below (m * n)</span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : a2 ∈ set_rp_below (m * n)</span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h4 : mod_mod m n a1 = mod_mod m n a2   <span class="co">--Goal : a1 = a2</span></span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2; <span class="kw">define</span> <span class="kw">at</span> h3</span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [mod_mod_def, mod_mod_def] <span class="kw">at</span> h4</span>
<span id="cb82-16"><a href="#cb82-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : a1 % m = a2 % m ∧ a1 % n = a2 % n := Prod.mk.inj h4</span>
<span id="cb82-17"><a href="#cb82-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : m * n ≠ 0 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb82-18"><a href="#cb82-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h7 : NeZero m := left_NeZero_of_mul h6</span>
<span id="cb82-19"><a href="#cb82-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h8 : NeZero n := right_NeZero_of_mul h6</span>
<span id="cb82-20"><a href="#cb82-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←congr_iff_mod_eq_Nat, ←congr_iff_mod_eq_Nat] <span class="kw">at</span> h5</span>
<span id="cb82-21"><a href="#cb82-21" aria-hidden="true" tabindex="-1"></a>      <span class="co">--h5 : ↑a1 ≡ ↑a2 (MOD m) ∧ ↑a1 ≡ ↑a2 (MOD n)</span></span>
<span id="cb82-22"><a href="#cb82-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←Lemma_7_4_5 _ _ h1] <span class="kw">at</span> h5  <span class="co">--h5 : ↑a1 ≡ ↑a2 (MOD m * n)</span></span>
<span id="cb82-23"><a href="#cb82-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [congr_iff_mod_eq_Nat] <span class="kw">at</span> h5 <span class="co">--h5 : a1 % (m * n) = a2 % (m * n)</span></span>
<span id="cb82-24"><a href="#cb82-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [Nat.mod_eq_of_lt h2.right, Nat.mod_eq_of_lt h3.right] <span class="kw">at</span> h5</span>
<span id="cb82-25"><a href="#cb82-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> a1 = a2 <span class="kw">from</span> h5</span>
<span id="cb82-26"><a href="#cb82-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb82-27"><a href="#cb82-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-28"><a href="#cb82-28" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> mod_elt_set_rp_below {a m : Nat} [NeZero m] (h1 : rel_prime m a) :</span>
<span id="cb82-29"><a href="#cb82-29" aria-hidden="true" tabindex="-1"></a>    a % m ∈ set_rp_below m := <span class="kw">by</span></span>
<span id="cb82-30"><a href="#cb82-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>                  <span class="co">--Goal : rel_prime m (a % m) ∧ a % m &lt; m</span></span>
<span id="cb82-31"><a href="#cb82-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [rel_prime_mod] <span class="co">--Goal : rel_prime m a ∧ a % m &lt; m</span></span>
<span id="cb82-32"><a href="#cb82-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> rel_prime m a ∧ a % m &lt; m <span class="kw">from</span></span>
<span id="cb82-33"><a href="#cb82-33" aria-hidden="true" tabindex="-1"></a>    And.intro h1 (mod_nonzero_lt a (NeZero.ne m))</span>
<span id="cb82-34"><a href="#cb82-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb82-35"><a href="#cb82-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-36"><a href="#cb82-36" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> mod_mod_image {m n : Nat} (h1 : rel_prime m n) :</span>
<span id="cb82-37"><a href="#cb82-37" aria-hidden="true" tabindex="-1"></a>    image (mod_mod m n) (set_rp_below (m * n)) =</span>
<span id="cb82-38"><a href="#cb82-38" aria-hidden="true" tabindex="-1"></a>      (set_rp_below m) ×ₛ (set_rp_below n) := <span class="kw">by</span></span>
<span id="cb82-39"><a href="#cb82-39" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb82-40"><a href="#cb82-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> (b, c) : Nat × Nat</span>
<span id="cb82-41"><a href="#cb82-41" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb82-42"><a href="#cb82-42" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb82-43"><a href="#cb82-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : (b, c) ∈ image (mod_mod m n) (set_rp_below (m * n))</span>
<span id="cb82-44"><a href="#cb82-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h2</span>
<span id="cb82-45"><a href="#cb82-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (a : Nat)</span>
<span id="cb82-46"><a href="#cb82-46" aria-hidden="true" tabindex="-1"></a>      (h3 : a ∈ set_rp_below (m * n) ∧ mod_mod m n a = (b, c)) <span class="kw">from</span> h2</span>
<span id="cb82-47"><a href="#cb82-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [set_rp_below_def, mod_mod_def] <span class="kw">at</span> h3</span>
<span id="cb82-48"><a href="#cb82-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : rel_prime (m * n) a := h3.left.left</span>
<span id="cb82-49"><a href="#cb82-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [Lemma_7_4_6] <span class="kw">at</span> h4   <span class="co">--h4 : rel_prime m a ∧ rel_prime n a</span></span>
<span id="cb82-50"><a href="#cb82-50" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h5 : a % m = b ∧ a % n = c := Prod.mk.inj h3.right</span>
<span id="cb82-51"><a href="#cb82-51" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb82-52"><a href="#cb82-52" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←h5.left, ←h5.right]</span>
<span id="cb82-53"><a href="#cb82-53" aria-hidden="true" tabindex="-1"></a>      <span class="co">--Goal : a % m ∈ set_rp_below m ∧ a % n ∈ set_rp_below n</span></span>
<span id="cb82-54"><a href="#cb82-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h6 : m * n ≠ 0 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb82-55"><a href="#cb82-55" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h7 : NeZero m := left_NeZero_of_mul h6</span>
<span id="cb82-56"><a href="#cb82-56" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h8 : NeZero n := right_NeZero_of_mul h6</span>
<span id="cb82-57"><a href="#cb82-57" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro</span>
<span id="cb82-58"><a href="#cb82-58" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that a % m ∈ set_rp_below m</span></span>
<span id="cb82-59"><a href="#cb82-59" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> a % m ∈ set_rp_below m <span class="kw">from</span> mod_elt_set_rp_below h4.left</span>
<span id="cb82-60"><a href="#cb82-60" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb82-61"><a href="#cb82-61" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that a % n ∈ set_rp_below n</span></span>
<span id="cb82-62"><a href="#cb82-62" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> a % n ∈ set_rp_below n <span class="kw">from</span> mod_elt_set_rp_below h4.right</span>
<span id="cb82-63"><a href="#cb82-63" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb82-64"><a href="#cb82-64" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb82-65"><a href="#cb82-65" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb82-66"><a href="#cb82-66" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : (b, c) ∈ set_rp_below m ×ₛ set_rp_below n</span>
<span id="cb82-67"><a href="#cb82-67" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [set_prod_def, set_rp_below_def, set_rp_below_def] <span class="kw">at</span> h2</span>
<span id="cb82-68"><a href="#cb82-68" aria-hidden="true" tabindex="-1"></a>      <span class="co">--h2 : (rel_prime m b ∧ b &lt; m) ∧ (rel_prime n c ∧ c &lt; n)</span></span>
<span id="cb82-69"><a href="#cb82-69" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb82-70"><a href="#cb82-70" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : m ≠ 0 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb82-71"><a href="#cb82-71" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : n ≠ 0 := <span class="kw">by</span> <span class="kw">linarith</span></span>
<span id="cb82-72"><a href="#cb82-72" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←neZero_iff] <span class="kw">at</span> h3</span>
<span id="cb82-73"><a href="#cb82-73" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←neZero_iff] <span class="kw">at</span> h4</span>
<span id="cb82-74"><a href="#cb82-74" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (a : Nat) (h5 : a &lt; m * n ∧ a ≡ b (MOD m) ∧ a ≡ c (MOD n))</span>
<span id="cb82-75"><a href="#cb82-75" aria-hidden="true" tabindex="-1"></a>      <span class="kw">from</span> Lemma_7_4_7 h1 b c</span>
<span id="cb82-76"><a href="#cb82-76" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro a</span>
<span id="cb82-77"><a href="#cb82-77" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro</span>
<span id="cb82-78"><a href="#cb82-78" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof of a ∈ set_rp_below (m * n)</span></span>
<span id="cb82-79"><a href="#cb82-79" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span>                  <span class="co">--Goal : rel_prime (m * n) a ∧ a &lt; m * n</span></span>
<span id="cb82-80"><a href="#cb82-80" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> And.intro _ h5.left</span>
<span id="cb82-81"><a href="#cb82-81" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [Lemma_7_4_6]   <span class="co">--Goal : rel_prime m a ∧ rel_prime n a</span></span>
<span id="cb82-82"><a href="#cb82-82" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [congr_rel_prime h5.right.left,</span>
<span id="cb82-83"><a href="#cb82-83" aria-hidden="true" tabindex="-1"></a>        congr_rel_prime h5.right.right]</span>
<span id="cb82-84"><a href="#cb82-84" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> rel_prime m b ∧ rel_prime n c <span class="kw">from</span></span>
<span id="cb82-85"><a href="#cb82-85" aria-hidden="true" tabindex="-1"></a>        And.intro h2.left.left h2.right.left</span>
<span id="cb82-86"><a href="#cb82-86" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb82-87"><a href="#cb82-87" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof of mod_mod m n a = (b, c)</span></span>
<span id="cb82-88"><a href="#cb82-88" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [congr_iff_mod_eq_Nat, congr_iff_mod_eq_Nat] <span class="kw">at</span> h5</span>
<span id="cb82-89"><a href="#cb82-89" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [mod_mod_def, h5.right.left, h5.right.right]</span>
<span id="cb82-90"><a href="#cb82-90" aria-hidden="true" tabindex="-1"></a>        <span class="co">--Goal : (b % m, c % n) = (b, c)</span></span>
<span id="cb82-91"><a href="#cb82-91" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [Nat.mod_eq_of_lt h2.left.right,</span>
<span id="cb82-92"><a href="#cb82-92" aria-hidden="true" tabindex="-1"></a>        Nat.mod_eq_of_lt h2.right.right]</span>
<span id="cb82-93"><a href="#cb82-93" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rfl</span></span>
<span id="cb82-94"><a href="#cb82-94" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb82-95"><a href="#cb82-95" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb82-96"><a href="#cb82-96" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb82-97"><a href="#cb82-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-98"><a href="#cb82-98" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> set_rp_below_prod {m n : Nat} (h1 : rel_prime m n) :</span>
<span id="cb82-99"><a href="#cb82-99" aria-hidden="true" tabindex="-1"></a>    set_rp_below (m * n) ∼ (set_rp_below m) ×ₛ (set_rp_below n) := <span class="kw">by</span></span>
<span id="cb82-100"><a href="#cb82-100" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←mod_mod_image h1]</span>
<span id="cb82-101"><a href="#cb82-101" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> set_rp_below (m * n) ∼</span>
<span id="cb82-102"><a href="#cb82-102" aria-hidden="true" tabindex="-1"></a>    image (mod_mod m n) (set_rp_below (m * n)) <span class="kw">from</span></span>
<span id="cb82-103"><a href="#cb82-103" aria-hidden="true" tabindex="-1"></a>    equinum_image (mod_mod_one_one_on h1)</span>
<span id="cb82-104"><a href="#cb82-104" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We finally have everything we need to prove Theorem 7.4.4.</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> eq_numElts_of_equinum {U V : <span class="kw">Type</span>} {A : Set U} {B : Set V} {n : Nat}</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>    (h1 : A ∼ B) (h2 : numElts A n) : numElts B n := <span class="kw">by</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [numElts_def] <span class="kw">at</span> h2   <span class="co">--h2 : I n ∼ A</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [numElts_def]         <span class="co">--Goal : I n ∼ B</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> I n ∼ B <span class="kw">from</span> Theorem_8_1_3_3 h2 h1</span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_7_4_4 {m n : Nat} (h1 : rel_prime m n) :</span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a>    phi (m * n) = (phi m) * (phi n) := <span class="kw">by</span></span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : numElts (set_rp_below m) (phi m) := phi_is_numElts m</span>
<span id="cb83-11"><a href="#cb83-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : numElts (set_rp_below n) (phi n) := phi_is_numElts n</span>
<span id="cb83-12"><a href="#cb83-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : numElts (set_rp_below (m * n)) (phi (m * n)) :=</span>
<span id="cb83-13"><a href="#cb83-13" aria-hidden="true" tabindex="-1"></a>    phi_is_numElts (m * n)</span>
<span id="cb83-14"><a href="#cb83-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : numElts (set_rp_below m ×ₛ set_rp_below n) (phi (m * n)) :=</span>
<span id="cb83-15"><a href="#cb83-15" aria-hidden="true" tabindex="-1"></a>    eq_numElts_of_equinum (set_rp_below_prod h1) h4</span>
<span id="cb83-16"><a href="#cb83-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : numElts (set_rp_below m ×ₛ set_rp_below n) (phi m * phi n) :=</span>
<span id="cb83-17"><a href="#cb83-17" aria-hidden="true" tabindex="-1"></a>    numElts_prod h2 h3</span>
<span id="cb83-18"><a href="#cb83-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> phi (m * n) = phi m * phi n <span class="kw">from</span> Exercise_8_1_6b h5 h6</span>
<span id="cb83-19"><a href="#cb83-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="exercises-1" class="level3">
<h3 class="anchored" data-anchor-id="exercises-1">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb84"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> image_empty {U : <span class="kw">Type</span>} {A : Set U}</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>    (f : U → Nat) (h : empty A) : image f A = I 0 := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb85"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> remove_one_equinum</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>    {U V : <span class="kw">Type</span>} {A : Set U} {B : Set V} {a : U} {b : V} {f : U → V}</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>    (h1 : one_one_on f A) (h2 : image f A = B)</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>    (h3 : a ∈ A) (h4 : f a = b) : ↑(A \ {a}) ∼ ↑(B \ {b}) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb86"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> singleton_of_diff_empty {U : <span class="kw">Type</span>} {A : Set U} {a : U}</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>    (h1 : a ∈ A) (h2 : empty (A \ {a})) : A = {a} := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb87"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> eq_zero_of_I_zero_equinum {n : Nat} (h : I 0 ∼ I n) : n = 0 := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb88"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint: Use mathematical induction.</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_8_1_6a : ∀ ⦃m n : Nat⦄, (I m ∼ I n) → m = n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="6">
<div class="sourceCode" id="cb89"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_8_1_6b {U : <span class="kw">Type</span>} {A : Set U} {m n : Nat}</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>    (h1 : numElts A m) (h2 : numElts A n) : m = n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="7">
<div class="sourceCode" id="cb90"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> neb_nrpb (m : Nat) : ∀ ⦃k : Nat⦄, k ≤ m →</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>    num_elts_below (set_rp_below m) k = num_rp_below m k := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="8">
<div class="sourceCode" id="cb91"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint:  You might find it helpful to apply the theorem div_mod_char</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a><span class="co">--from the exercises of Section 6.4.</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> qr_image (m n : Nat) :</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>    image (qr n) (I (m * n)) = I m ×ₛ I n := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="mdsk">

</div>
<p>Suppose <code>U</code> and <code>V</code> are types, <code>A</code> and <code>C</code> have type <code>Set U</code>, and we have two functions <code>f : A → V</code> and <code>g : C → V</code>. Then we can define a new function <code>func_union f g : A ∪ C → V</code> as follows:</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> is_elt_snd_of_not_fst {U : <span class="kw">Type</span>} {A C : Set U} {x : U}</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>    (h1 : x ∈ A ∪ C) (h2 : x ∉ A) : x ∈ C := <span class="kw">by</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">disj_syll</span> h1 h2</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> x ∈ C <span class="kw">from</span> h1</span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> elt_snd_of_not_fst {U : <span class="kw">Type</span>} {A C : Set U} {x : ↑(A ∪ C)}</span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a>  (h : x.val ∉ A) : C :=</span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a>  Subtype_elt (is_elt_snd_of_not_fst x.property h)</span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true" tabindex="-1"></a><span class="kw">noncomputable</span> <span class="kw">def</span> func_union {U V : <span class="kw">Type</span>} {A C : Set U}</span>
<span id="cb92-12"><a href="#cb92-12" aria-hidden="true" tabindex="-1"></a>  (f : A → V) (g : C → V) (x : ↑(A ∪ C)) : V :=</span>
<span id="cb92-13"><a href="#cb92-13" aria-hidden="true" tabindex="-1"></a>  if test : x.val ∈ A then f (Subtype_elt test)</span>
<span id="cb92-14"><a href="#cb92-14" aria-hidden="true" tabindex="-1"></a>    else g (elt_snd_of_not_fst test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Note that in the definition of <code>func_union</code>, we have <code>test : x.val ∈ A</code> in the <code>then</code> clause and <code>test : x.val ∉ A</code> in the <code>else</code> clause. If <code>x.val ∈ A</code> then the value of <code>func_union f g x</code> is determined by <code>f</code>, and if <code>x.val ∉ A</code> then it is determined by <code>g</code>. The next two exercises ask you to prove properties of this function</p>
<div class="numex" data-arguments="9">
<div class="sourceCode" id="cb93"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> func_union_one_one {U V : <span class="kw">Type</span>} {A C : Set U}</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>    {f : A → V} {g : C → V} (h1 : empty (range f ∩ range g))</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>    (h2 : one_to_one f) (h3 : one_to_one g) :</span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>    one_to_one (func_union f g) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="10">
<div class="sourceCode" id="cb94"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> func_union_range {U V : <span class="kw">Type</span>} {A C : Set U}</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>    (f : A → V) (g : C → V) (h : empty (A ∩ C)) :</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>    range (func_union f g) = range f ∪ range g := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="11">
<div class="sourceCode" id="cb95"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint:  Use the last two exercises.</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_8_1_2_2</span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>    {U V : <span class="kw">Type</span>} {A C : Set U} {B D : Set V}</span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>    (h1 : empty (A ∩ C)) (h2 : empty (B ∩ D))</span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>    (h3 : A ∼ B) (h4 : C ∼ D) : ↑(A ∪ C) ∼ ↑(B ∪ D) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="12">
<div class="sourceCode" id="cb96"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> shift_I_equinum (n m : Nat) : I m ∼ ↑(I (n + m) \ I n) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="13">
<div class="sourceCode" id="cb97"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_8_1_7 {U : <span class="kw">Type</span>} {A B : Set U} {n m : Nat}</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>    (h1 : empty (A ∩ B)) (h2 : numElts A n) (h3 : numElts B m) :</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>    numElts (A ∪ B) (n + m) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="14">
<div class="sourceCode" id="cb98"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> equinum_sub {U V : <span class="kw">Type</span>} {A C : Set U} {B : Set V}</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>    (h1 : A ∼ B) (h2 : C ⊆ A) : ∃ (D : Set V), D ⊆ B ∧ C ∼ D := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="15">
<div class="sourceCode" id="cb99"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_8_1_8b {U : <span class="kw">Type</span>} {A B : Set U}</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>    (h1 : finite A) (h2 : B ⊆ A) : finite B := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="16">
<div class="sourceCode" id="cb100"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> finite_bdd {A : Set Nat} (h : finite A) :</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>    ∃ (m : Nat), ∀ n ∈ A, n &lt; m := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="17">
<div class="sourceCode" id="cb101"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> N_not_finite : ¬finite Nat := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="18">
<div class="sourceCode" id="cb102"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> denum_not_finite (U : <span class="kw">Type</span>)</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>    (h : denum U) : ¬finite U := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="19">
<div class="sourceCode" id="cb103"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint:  Use Like_Exercise_6_2_16 from the exercises of Section 6.2.</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_6_2_16 {U : <span class="kw">Type</span>} {f : U → U}</span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>    (h1 : one_to_one f) (h2 : finite U) : onto f := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="countable-and-uncountable-sets" class="level2">
<h2 class="anchored" data-anchor-id="countable-and-uncountable-sets">8.2. Countable and Uncountable Sets</h2>
<p>Section 8.2 of <em>HTPI</em> shows that many set-theoretic operations, when applied to countable sets, produce results that are countable. For example, the first part of Theorem 8.2.1 shows that a Cartesian product of countable sets is countable. Our proof of this statement in Lean is based on <code>Theorem_8_1_2_1_set</code> and the denumerability of <code>Nat × Nat</code>. We also use an exercise from Section 8.1.</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> NxN_denum : denum (Nat × Nat) := Theorem_8_1_3_2 NxN_equinum_N</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_8_2_1_1 {U V : <span class="kw">Type</span>} {A : Set U} {B : Set V}</span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a>    (h1 : ctble A) (h2 : ctble B) : ctble (A ×ₛ B) := <span class="kw">by</span></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [ctble_iff_set_nat_equinum] <span class="kw">at</span> h1</span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [ctble_iff_set_nat_equinum] <span class="kw">at</span> h2</span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (J : Set Nat) (h3 : J ∼ A) <span class="kw">from</span> h1</span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (K : Set Nat) (h4 : K ∼ B) <span class="kw">from</span> h2</span>
<span id="cb104-9"><a href="#cb104-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : J ×ₛ K ∼ A ×ₛ B := Theorem_8_1_2_1_set h3 h4</span>
<span id="cb104-10"><a href="#cb104-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : ctble (Nat × Nat) := Or.inr NxN_denum</span>
<span id="cb104-11"><a href="#cb104-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h7 : ctble (J ×ₛ K) := ctble_set_of_ctble_type h6 (J ×ₛ K)</span>
<span id="cb104-12"><a href="#cb104-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ctble (A ×ₛ B) <span class="kw">from</span> ctble_of_ctble_equinum h5 h7</span>
<span id="cb104-13"><a href="#cb104-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The second part of Theorem 8.2.1 shows that a union of two countable sets is countable, but, as we ask you to show in the exercises, it is superseded by Theorem 8.2.2, which says that a union of a countable family of countable sets is countable. So we will skip ahead to Theorem 8.2.2. Here’s how we state the theorem in Lean:</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_8_2_2 {U : <span class="kw">Type</span>} {F : Set (Set U)}</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ctble F) (h2 : ∀ A ∈ F, ctble A) : ctble (⋃₀ F)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>As in the proof in <em>HTPI</em>, we will use the characterization of countability from <code>Theorem_8_1_5_2</code>. We first consider the case in which <code>F</code> is nonempty and also all elements of <code>F</code> are nonempty. According to <code>Theorem_8_1_5_2</code>, the hypotheses <code>h1</code> and <code>h2</code> then imply that there is a function <code>j : Nat → Set U</code> such that <code>F ⊆ range j</code>, and also for each <code>A ∈ F</code> there is a function <code>gA : Nat → U</code> with <code>A ⊆ range gA</code>. We begin by proving an easier version of the theorem, where we assume that we have a function <code>g</code> from <code>Set U</code> to <code>Nat → U</code> that supplies, for each <code>A ∈ F</code>, the required function <code>gA</code>. Imitating the proof in <em>HTPI</em>, we can use <code>j</code> and <code>g</code> to construct the function needed to prove that <code>⋃₀ F</code> is countable.</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_8_2_2_1 {U : <span class="kw">Type</span>} {F : Set (Set U)} {g : Set U → Nat → U}</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ctble F) (h2 : ¬empty F) (h3 : ∀ A ∈ F, A ⊆ range (g A)) :</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>    ctble (⋃₀ F) := <span class="kw">by</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [Theorem_8_1_5_2] <span class="kw">at</span> h1</span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">disj_syll</span> h1 h2               <span class="co">--h1 : ∃ (f : Nat → Set U), F ⊆ range f</span></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [Theorem_8_1_5_2]</span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Or.inr                  <span class="co">--Goal : ∃ (f : Nat → Set U), ⋃₀F ⊆ range f</span></span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (j : Nat → Set U) (h4 : F ⊆ range j) <span class="kw">from</span> h1</span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (p : Nat → Nat × Nat) (h5 : one_to_one p ∧ onto p) <span class="kw">from</span> NxN_denum</span>
<span id="cb106-10"><a href="#cb106-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> f : Nat → U := fun (n : Nat) =&gt; g (j (p n).1) (p n).2</span>
<span id="cb106-11"><a href="#cb106-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro f</span>
<span id="cb106-12"><a href="#cb106-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb106-13"><a href="#cb106-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h6 : x ∈ ⋃₀ F</span>
<span id="cb106-14"><a href="#cb106-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (A : Set U) (h7 : A ∈ F ∧ x ∈ A) <span class="kw">from</span> h6</span>
<span id="cb106-15"><a href="#cb106-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (n1 : Nat) (h8 : j n1 = A) <span class="kw">from</span> h4 h7.left</span>
<span id="cb106-16"><a href="#cb106-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (n2 : Nat) (h9 : g A n2 = x) <span class="kw">from</span> h3 A h7.left h7.right</span>
<span id="cb106-17"><a href="#cb106-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (n : Nat) (h10 : p n = (n1, n2)) <span class="kw">from</span> h5.right (n1, n2)</span>
<span id="cb106-18"><a href="#cb106-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro n</span>
<span id="cb106-19"><a href="#cb106-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> f n = x <span class="kw">from</span></span>
<span id="cb106-20"><a href="#cb106-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> f n</span>
<span id="cb106-21"><a href="#cb106-21" aria-hidden="true" tabindex="-1"></a>      _ = g (j (p n).1) (p n).2 := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb106-22"><a href="#cb106-22" aria-hidden="true" tabindex="-1"></a>      _ = g (j n1) n2 := <span class="kw">by</span> <span class="kw">rw</span> [h10]</span>
<span id="cb106-23"><a href="#cb106-23" aria-hidden="true" tabindex="-1"></a>      _ = g A n2 := <span class="kw">by</span> <span class="kw">rw</span> [h8]</span>
<span id="cb106-24"><a href="#cb106-24" aria-hidden="true" tabindex="-1"></a>      _ = x := <span class="kw">by</span> <span class="kw">rw</span> [h9]</span>
<span id="cb106-25"><a href="#cb106-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>How can we use <code>Lemma_8_2_2_1</code> to prove <code>Theorem_8_2_2</code> (still assuming that <code>F</code> and every element of <code>F</code> are nonempty)? We must use the hypothesis <code>h2 : ∀ A ∈ F, ctble A</code> in <code>Theorem_8_2_2</code> to produce the function <code>g</code> required in <code>Lemma_8_2_2_1</code>. As we have already observed, <code>Theorem_8_1_5_2</code> guarantees that for each <code>A ∈ F</code>, an appropriate function <code>gA : Nat → U</code> exists. We need a function <code>g</code> that will <em>choose</em> such a function <code>gA</code> for each <code>A</code>. A function with this property is often called a <em>choice function</em>. And now we come to a delicate point that was skipped over in <em>HTPI</em>: to prove the existence of a choice function, we must use a statement called the <em>axiom of choice</em>.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>The distinction between the existence of an appropriate function <code>gA</code> for each <code>A</code> and the existence of a function that chooses such a function for each <code>A</code> is a subtle one. Perhaps for this reason, many people find the axiom of choice to be intuitively obvious. <em>HTPI</em> took advantage of this intuition to skip over this step in the proof without comment. But of course Lean won’t let us skip anything!</p>
<p>To implement the axiom of choice, Lean uses a function called <code>Classical.choose</code>. Given a proof <code>h</code> of a statement of the form <code>∃ (x : U), P x</code>, the expression <code>Classical.choose h</code> produces (“chooses”) some <code>u : U</code> such that <code>P u</code> is true. There is also a theorem <code>Classical.choose_spec</code> that guarantees that the <code>Classical.choose</code> function meets its specification—that is, <code>P (Classical.choose h)</code> is true. Using these, we can prove a lemma that will bridge the gap between <code>Lemma_8_2_2_1</code> and <code>Theorem_8_2_2</code>.</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_8_2_2_2 {U : <span class="kw">Type</span>} {F : Set (Set U)} (h1 : ∀ A ∈ F, ctble A)</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>    (h2 : ¬empty F) (h3 : ∀ A ∈ F, ¬empty A):</span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>    ∃ (g : Set U → Nat → U), ∀ A ∈ F, A ⊆ range (g A) := <span class="kw">by</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : ∀ (A : Set U), ∃ (gA : Nat → U),</span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a>      A ∈ F → A ⊆ range gA := <span class="kw">by</span></span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> A : Set U</span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">by_cases</span> h4 : A ∈ F</span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 1. h4 : A ∈ F</span></span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h5 : ctble A := h1 A h4</span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [Theorem_8_1_5_2] <span class="kw">at</span> h5</span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">disj_syll</span> h5 (h3 A h4)    <span class="co">--h5 : ∃ (f : Nat → U), A ⊆ range f</span></span>
<span id="cb107-12"><a href="#cb107-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">obtain</span> (gA : Nat → U) (h6 : A ⊆ range gA) <span class="kw">from</span> h5</span>
<span id="cb107-13"><a href="#cb107-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro gA</span>
<span id="cb107-14"><a href="#cb107-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">assume</span> h7 : A ∈ F</span>
<span id="cb107-15"><a href="#cb107-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> A ⊆ range gA <span class="kw">from</span> h6</span>
<span id="cb107-16"><a href="#cb107-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb107-17"><a href="#cb107-17" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 2. h4 : A ∉ F</span></span>
<span id="cb107-18"><a href="#cb107-18" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [not_empty_iff_exists_elt] <span class="kw">at</span> h2</span>
<span id="cb107-19"><a href="#cb107-19" aria-hidden="true" tabindex="-1"></a>      <span class="kw">obtain</span> (A0 : Set U) (h5 : A0 ∈ F) <span class="kw">from</span> h2</span>
<span id="cb107-20"><a href="#cb107-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h6 : ¬empty A0 := h3 A0 h5</span>
<span id="cb107-21"><a href="#cb107-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [not_empty_iff_exists_elt] <span class="kw">at</span> h6</span>
<span id="cb107-22"><a href="#cb107-22" aria-hidden="true" tabindex="-1"></a>      <span class="kw">obtain</span> (x0 : U) (h7 : x0 ∈ A0) <span class="kw">from</span> h6</span>
<span id="cb107-23"><a href="#cb107-23" aria-hidden="true" tabindex="-1"></a>      <span class="kw">set</span> gA : Nat → U := constant_func Nat x0</span>
<span id="cb107-24"><a href="#cb107-24" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro gA</span>
<span id="cb107-25"><a href="#cb107-25" aria-hidden="true" tabindex="-1"></a>      <span class="kw">contrapos</span></span>
<span id="cb107-26"><a href="#cb107-26" aria-hidden="true" tabindex="-1"></a>      <span class="kw">assume</span> h8 : A ⊈ range gA</span>
<span id="cb107-27"><a href="#cb107-27" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> A ∉ F <span class="kw">from</span> h4</span>
<span id="cb107-28"><a href="#cb107-28" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb107-29"><a href="#cb107-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb107-30"><a href="#cb107-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> g : Set U → Nat → U := fun (A : Set U) =&gt; Classical.choose (h4 A)</span>
<span id="cb107-31"><a href="#cb107-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro g</span>
<span id="cb107-32"><a href="#cb107-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> A : Set U</span>
<span id="cb107-33"><a href="#cb107-33" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> A ∈ F → A ⊆ range (g A) <span class="kw">from</span> Classical.choose_spec (h4 A)</span>
<span id="cb107-34"><a href="#cb107-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Notice that the domain of the function <code>g</code> in <code>Lemma_8_2_2_2</code> is <code>Set U</code>, not <code>F</code>. Thus, we must produce a function <code>gA</code> for every <code>A : Set U</code>, but it is only when <code>A ∈ F</code> that we care what <code>gA</code> is. Thus, the proof above just picks a default value (<code>constant_func Nat x0</code>) when <code>A ∉ F</code>.</p>
<p>We can now prove the theorem, still under the assumption that all elements of <code>F</code> are nonempty. If <code>F</code> is empty, then we can show that <code>⋃₀ F</code> is empty, so it has zero elements, which implies that it is finite and therefore countable. If <code>F</code> is not empty, then we can combine <code>Lemma_8_2_2_1</code> and <code>Lemma_8_2_2_2</code> to prove the theorem.</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_8_2_2_3 {U : <span class="kw">Type</span>} {F : Set (Set U)}</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ctble F) (h2 : ∀ A ∈ F, ctble A) (h3 : ∀ A ∈ F, ¬empty A) :</span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a>    ctble (⋃₀ F) := <span class="kw">by</span></span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> h4 : empty F</span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h4 : empty F</span></span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h5 : empty (⋃₀ F) := <span class="kw">by</span></span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">contradict</span> h4 <span class="kw">with</span> h5</span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [not_empty_iff_exists_elt] <span class="kw">at</span> h5</span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">obtain</span> (x : U) (h6 : x ∈ ⋃₀ F) <span class="kw">from</span> h5</span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">obtain</span> (A : Set U) (h7 : A ∈ F ∧ x ∈ A) <span class="kw">from</span> h6</span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> ∃ (x : Set U), x ∈ F <span class="kw">from</span> Exists.intro A h7.left</span>
<span id="cb108-12"><a href="#cb108-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb108-13"><a href="#cb108-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←zero_elts_iff_empty] <span class="kw">at</span> h5    <span class="co">--h5 : numElts (⋃₀ F) 0</span></span>
<span id="cb108-14"><a href="#cb108-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb108-15"><a href="#cb108-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Or.inl</span>
<span id="cb108-16"><a href="#cb108-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [finite_def]</span>
<span id="cb108-17"><a href="#cb108-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ∃ (n : Nat), numElts (⋃₀ F) n <span class="kw">from</span> Exists.intro 0 h5</span>
<span id="cb108-18"><a href="#cb108-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb108-19"><a href="#cb108-19" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h4 : ¬empty F</span></span>
<span id="cb108-20"><a href="#cb108-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (g : Set U → Nat → U) (h5 : ∀ A ∈ F, A ⊆ range (g A)) <span class="kw">from</span></span>
<span id="cb108-21"><a href="#cb108-21" aria-hidden="true" tabindex="-1"></a>      Lemma_8_2_2_2 h2 h4 h3</span>
<span id="cb108-22"><a href="#cb108-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ctble (⋃₀ F) <span class="kw">from</span> Lemma_8_2_2_1 h1 h4 h5</span>
<span id="cb108-23"><a href="#cb108-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, we deal with the possibility that <code>F</code> contains the empty set. As in <em>HTPI</em>, we show that we can simply remove the empty set from <code>F</code> and then apply our earlier reasoning.</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> remove_empty_subset {U : <span class="kw">Type</span>} (F : Set (Set U)) :</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>    {A : Set U | A ∈ F ∧ ¬empty A} ⊆ F := <span class="kw">by</span></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> X : Set U</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : X ∈ {A : Set U | A ∈ F ∧ ¬empty A}</span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> X ∈ F <span class="kw">from</span> h1.left</span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> remove_empty_union_eq {U : <span class="kw">Type</span>} (F : Set (Set U)) :</span>
<span id="cb109-10"><a href="#cb109-10" aria-hidden="true" tabindex="-1"></a>    ⋃₀ {A : Set U | A ∈ F ∧ ¬empty A} = ⋃₀ F := <span class="cn">sorry</span></span>
<span id="cb109-11"><a href="#cb109-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-12"><a href="#cb109-12" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_8_2_2 {U : <span class="kw">Type</span>} {F : Set (Set U)}</span>
<span id="cb109-13"><a href="#cb109-13" aria-hidden="true" tabindex="-1"></a>    (h1 : ctble F) (h2 : ∀ A ∈ F, ctble A) : ctble (⋃₀ F) := <span class="kw">by</span></span>
<span id="cb109-14"><a href="#cb109-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> G : Set (Set U) := {A : Set U | A ∈ F ∧ ¬empty A}</span>
<span id="cb109-15"><a href="#cb109-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : G ⊆ F := remove_empty_subset F</span>
<span id="cb109-16"><a href="#cb109-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : ⋃₀ G = ⋃₀ F := remove_empty_union_eq F</span>
<span id="cb109-17"><a href="#cb109-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←h4]</span>
<span id="cb109-18"><a href="#cb109-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : ctble G := Exercise_8_1_17 h3 h1</span>
<span id="cb109-19"><a href="#cb109-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : ∀ A ∈ G, ctble A := <span class="kw">by</span></span>
<span id="cb109-20"><a href="#cb109-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> A : Set U</span>
<span id="cb109-21"><a href="#cb109-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h6 : A ∈ G</span>
<span id="cb109-22"><a href="#cb109-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ctble A <span class="kw">from</span> h2 A (h3 h6)</span>
<span id="cb109-23"><a href="#cb109-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb109-24"><a href="#cb109-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h7 : ∀ A ∈ G, ¬empty A := <span class="kw">by</span></span>
<span id="cb109-25"><a href="#cb109-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> A : Set U</span>
<span id="cb109-26"><a href="#cb109-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h7 : A ∈ G</span>
<span id="cb109-27"><a href="#cb109-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h7</span>
<span id="cb109-28"><a href="#cb109-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ¬empty A <span class="kw">from</span> h7.right</span>
<span id="cb109-29"><a href="#cb109-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb109-30"><a href="#cb109-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ctble (⋃₀ G) <span class="kw">from</span> Lemma_8_2_2_3 h5 h6 h7</span>
<span id="cb109-31"><a href="#cb109-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>By the way, we can now explain a mystery from Section 5.1. The reason we skipped the proof of the right-to-left direction of <code>func_from_graph</code> is that the proof uses <code>Classical.choose</code> and <code>Classical.choose_spec</code>. Now that you know about this function and theorem, we can show you the proof.</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> func_from_graph_rtl {A B : <span class="kw">Type</span>} (F : Set (A × B)) :</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>    is_func_graph F → (∃ (f : A → B), graph f = F) := <span class="kw">by</span></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : is_func_graph F</span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1    <span class="co">--h1 : ∀ (x : A), ∃! (y : B), (x, y) ∈ F</span></span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : ∀ (x : A), ∃ (y : B), (x, y) ∈ F := <span class="kw">by</span></span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> x : A</span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (y : B) (h3 : (x, y) ∈ F)</span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a>      (h4 : ∀ (y1 y2 : B), (x, y1) ∈ F → (x, y2) ∈ F → y1 = y2) <span class="kw">from</span> h1 x</span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ∃ (y : B), (x, y) ∈ F <span class="kw">from</span> Exists.intro y h3</span>
<span id="cb110-10"><a href="#cb110-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb110-11"><a href="#cb110-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> f : A → B := fun (x : A) =&gt; Classical.choose (h2 x)</span>
<span id="cb110-12"><a href="#cb110-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro f</span>
<span id="cb110-13"><a href="#cb110-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb110-14"><a href="#cb110-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> (x, y) : A × B</span>
<span id="cb110-15"><a href="#cb110-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : (x, f x) ∈ F := Classical.choose_spec (h2 x)</span>
<span id="cb110-16"><a href="#cb110-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb110-17"><a href="#cb110-17" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb110-18"><a href="#cb110-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h4 : (x, y) ∈ graph f</span>
<span id="cb110-19"><a href="#cb110-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h4        <span class="co">--h4 : f x = y</span></span>
<span id="cb110-20"><a href="#cb110-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h4] <span class="kw">at</span> h3</span>
<span id="cb110-21"><a href="#cb110-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> (x, y) ∈ F <span class="kw">from</span> h3</span>
<span id="cb110-22"><a href="#cb110-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb110-23"><a href="#cb110-23" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb110-24"><a href="#cb110-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h4 : (x, y) ∈ F</span>
<span id="cb110-25"><a href="#cb110-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>              <span class="co">--Goal : f x = y</span></span>
<span id="cb110-26"><a href="#cb110-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (z : B) (h5 : (x, z) ∈ F)</span>
<span id="cb110-27"><a href="#cb110-27" aria-hidden="true" tabindex="-1"></a>      (h6 : ∀ (y1 y2 : B), (x, y1) ∈ F → (x, y2) ∈ F → y1 = y2) <span class="kw">from</span> h1 x</span>
<span id="cb110-28"><a href="#cb110-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> f x = y <span class="kw">from</span> h6 (f x) y h3 h4</span>
<span id="cb110-29"><a href="#cb110-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb110-30"><a href="#cb110-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>There is one more theorem in Section 8.2 of <em>HTPI</em> showing that a set-theoretic operation, when applied to a countable set, gives a countable result. Theorem 8.2.4 says that if a set <span class="math inline">\(A\)</span> is countable, then the set of all finite sequences of elements of <span class="math inline">\(A\)</span> is also countable. In <em>HTPI</em>, finite sequences are represented by functions, but in Lean it is easier to use lists. Thus, if <code>A</code> has type <code>Set U</code>, then we define a <em>finite sequence of elements of <code>A</code></em> to be a list <code>l : List U</code> with the property that every entry of <code>l</code> is an element of <code>A</code>. Letting <code>seq A</code> denote the set of all finite sequences of elements of <code>A</code>, our version of Theorem 8.2.4 will say that if <code>A</code> is countable, then so is <code>seq A</code>.</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> seq {U : <span class="kw">Type</span>} (A : Set U) : Set (List U) :=</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>  {l : List U | ∀ x ∈ l, x ∈ A}</span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> seq_def {U : <span class="kw">Type</span>} (A : Set U) (l : List U) :</span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a>    l ∈ seq A ↔ ∀ x ∈ l, x ∈ A := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_8_2_4 {U : <span class="kw">Type</span>} {A : Set U}</span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a>    (h1 : ctble A) : ctble (seq A)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Our proof of <code>Theorem_8_2_4</code> will use exactly the same strategy as the proof in <em>HTPI</em>. We begin by showing that, for every natural number <code>n</code>, the set of sequences of elements of <code>A</code> of length <code>n</code> is countable. The proof is by mathematical induction. The base case is easy, because the only sequence of length <code>0</code> is the <code>nil</code> list.</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> seq_by_length {U : <span class="kw">Type</span>} (A : Set U) (n : Nat) : Set (List U) :=</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>  {l : List U | l ∈ seq A ∧ l.length = n}</span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> sbl_base {U : <span class="kw">Type</span>} (A : Set U) : seq_by_length A 0 = {[]} := <span class="kw">by</span></span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> l : List U</span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : l ∈ seq_by_length A 0</span>
<span id="cb112-10"><a href="#cb112-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1   <span class="co">--h1 : l ∈ seq A ∧ l.length = 0</span></span>
<span id="cb112-11"><a href="#cb112-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [List.length_eq_zero_iff] <span class="kw">at</span> h1</span>
<span id="cb112-12"><a href="#cb112-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb112-13"><a href="#cb112-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> l = [] <span class="kw">from</span> h1.right</span>
<span id="cb112-14"><a href="#cb112-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb112-15"><a href="#cb112-15" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb112-16"><a href="#cb112-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : l ∈ {[]}</span>
<span id="cb112-17"><a href="#cb112-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1     <span class="co">--h1 : l = []</span></span>
<span id="cb112-18"><a href="#cb112-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>           <span class="co">--Goal : l ∈ seq A ∧ l.length = 0</span></span>
<span id="cb112-19"><a href="#cb112-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro _ (List.length_eq_zero_iff.rtl h1)</span>
<span id="cb112-20"><a href="#cb112-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>           <span class="co">--Goal : ∀ x ∈ l, x ∈ A</span></span>
<span id="cb112-21"><a href="#cb112-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> x : U</span>
<span id="cb112-22"><a href="#cb112-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">contrapos</span></span>
<span id="cb112-23"><a href="#cb112-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : x ∉ A</span>
<span id="cb112-24"><a href="#cb112-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h1]</span>
<span id="cb112-25"><a href="#cb112-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> x ∉ [] <span class="kw">from</span> List.not_mem_nil</span>
<span id="cb112-26"><a href="#cb112-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb112-27"><a href="#cb112-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For the induction step, the key idea is that <code>A ×ₛ (seq_by_length A n) ∼ seq_by_length A (n + 1)</code>. To prove this, we define a function <code>seq_cons U</code> that matches up <code>A ×ₛ (seq_by_length A n)</code> with <code>seq_by_length A (n + 1)</code>.</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> seq_cons (U : <span class="kw">Type</span>) (p : U × (List U)) : List U := p.1 :: p.2</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> seq_cons_def {U : <span class="kw">Type</span>} (x : U) (l : List U) :</span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>    seq_cons U (x, l) = x :: l := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> seq_cons_one_one (U : <span class="kw">Type</span>) : one_to_one (seq_cons U) := <span class="kw">by</span></span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> (a1, l1) : U × List U; <span class="kw">fix</span> (a2, l2) : U × List U</span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : seq_cons U (a1, l1) = seq_cons U (a2, l2)</span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [seq_cons_def, seq_cons_def] <span class="kw">at</span> h1  <span class="co">--h1 : a1 :: l1 = a2 :: l2</span></span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [List.cons_eq_cons] <span class="kw">at</span> h1           <span class="co">--h1 : a1 = a2 ∧ l1 = l2</span></span>
<span id="cb113-11"><a href="#cb113-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h1.left, h1.right]</span>
<span id="cb113-12"><a href="#cb113-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rfl</span></span>
<span id="cb113-13"><a href="#cb113-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb113-14"><a href="#cb113-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-15"><a href="#cb113-15" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> seq_cons_image {U : <span class="kw">Type</span>} (A : Set U) (n : Nat) :</span>
<span id="cb113-16"><a href="#cb113-16" aria-hidden="true" tabindex="-1"></a>    image (seq_cons U) (A ×ₛ (seq_by_length A n)) =</span>
<span id="cb113-17"><a href="#cb113-17" aria-hidden="true" tabindex="-1"></a>      seq_by_length A (n + 1) := <span class="cn">sorry</span></span>
<span id="cb113-18"><a href="#cb113-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-19"><a href="#cb113-19" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_8_2_4_1 {U : <span class="kw">Type</span>} (A : Set U) (n : Nat) :</span>
<span id="cb113-20"><a href="#cb113-20" aria-hidden="true" tabindex="-1"></a>    A ×ₛ (seq_by_length A n) ∼ seq_by_length A (n + 1) := <span class="kw">by</span></span>
<span id="cb113-21"><a href="#cb113-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←seq_cons_image A n]</span>
<span id="cb113-22"><a href="#cb113-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> A ×ₛ seq_by_length A n ∼</span>
<span id="cb113-23"><a href="#cb113-23" aria-hidden="true" tabindex="-1"></a>    image (seq_cons U) (A ×ₛ seq_by_length A n) <span class="kw">from</span> equinum_image</span>
<span id="cb113-24"><a href="#cb113-24" aria-hidden="true" tabindex="-1"></a>    (one_one_on_of_one_one (seq_cons_one_one U) (A ×ₛ (seq_by_length A n)))</span>
<span id="cb113-25"><a href="#cb113-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With this preparation, we can now use <code>singleton_one_elt</code> to justify the base case of our induction proof and <code>Theorem_8_2_1_1</code> for the induction step.</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_8_2_4_2 {U : <span class="kw">Type</span>} {A : Set U} (h1 : ctble A) :</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>    ∀ (n : Nat), ctble (seq_by_length A n) := <span class="kw">by</span></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_induc</span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Base Case</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [sbl_base]   <span class="co">--Goal : ctble {[]}</span></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Or.inl         <span class="co">--Goal : finite {[]}</span></span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [finite_def]</span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro 1 <span class="co">--Goal : numElts {[]} 1</span></span>
<span id="cb114-10"><a href="#cb114-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> numElts {[]} 1 <span class="kw">from</span> singleton_one_elt []</span>
<span id="cb114-11"><a href="#cb114-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb114-12"><a href="#cb114-12" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Induction Step</span></span>
<span id="cb114-13"><a href="#cb114-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> n : Nat</span>
<span id="cb114-14"><a href="#cb114-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> ih : ctble (seq_by_length A n)</span>
<span id="cb114-15"><a href="#cb114-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : A ×ₛ (seq_by_length A n) ∼ seq_by_length A (n + 1) :=</span>
<span id="cb114-16"><a href="#cb114-16" aria-hidden="true" tabindex="-1"></a>      Lemma_8_2_4_1 A n</span>
<span id="cb114-17"><a href="#cb114-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : ctble (A ×ₛ (seq_by_length A n)) := Theorem_8_2_1_1 h1 ih</span>
<span id="cb114-18"><a href="#cb114-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ctble (seq_by_length A (n + 1)) <span class="kw">from</span> ctble_of_ctble_equinum h2 h3</span>
<span id="cb114-19"><a href="#cb114-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb114-20"><a href="#cb114-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Our next step is to show that the union of all of the sets <code>seq_by_length A n</code>, for <code>n : Nat</code>, is <code>seq A</code>.</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sbl_set {U : <span class="kw">Type</span>} (A : Set U) : Set (Set (List U)) :=</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>  {S : Set (List U) | ∃ (n : Nat), seq_by_length A n = S}</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_8_2_4_3 {U : <span class="kw">Type</span>} (A : Set U) : ⋃₀ (sbl_set A) = seq A := <span class="kw">by</span></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> l : List U</span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : l ∈ ⋃₀ (sbl_set A)</span>
<span id="cb115-10"><a href="#cb115-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb115-11"><a href="#cb115-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (S : Set (List U)) (h2 :  S ∈ sbl_set A ∧ l ∈ S) <span class="kw">from</span> h1</span>
<span id="cb115-12"><a href="#cb115-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : S ∈ sbl_set A := h2.left</span>
<span id="cb115-13"><a href="#cb115-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h3</span>
<span id="cb115-14"><a href="#cb115-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (n : Nat) (h4 : seq_by_length A n = S) <span class="kw">from</span> h3</span>
<span id="cb115-15"><a href="#cb115-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h5 : l ∈ S := h2.right</span>
<span id="cb115-16"><a href="#cb115-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←h4] <span class="kw">at</span> h5</span>
<span id="cb115-17"><a href="#cb115-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h5</span>
<span id="cb115-18"><a href="#cb115-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> l ∈ seq A <span class="kw">from</span> h5.left</span>
<span id="cb115-19"><a href="#cb115-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb115-20"><a href="#cb115-20" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb115-21"><a href="#cb115-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : l ∈ seq A</span>
<span id="cb115-22"><a href="#cb115-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb115-23"><a href="#cb115-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">set</span> n : Nat := l.length</span>
<span id="cb115-24"><a href="#cb115-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro (seq_by_length A n)</span>
<span id="cb115-25"><a href="#cb115-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro</span>
<span id="cb115-26"><a href="#cb115-26" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof of seq_by_length A n ∈ sbl_set A</span></span>
<span id="cb115-27"><a href="#cb115-27" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span></span>
<span id="cb115-28"><a href="#cb115-28" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro n</span>
<span id="cb115-29"><a href="#cb115-29" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rfl</span></span>
<span id="cb115-30"><a href="#cb115-30" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb115-31"><a href="#cb115-31" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof of l ∈ seq_by_length A n</span></span>
<span id="cb115-32"><a href="#cb115-32" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span></span>
<span id="cb115-33"><a href="#cb115-33" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> And.intro h1</span>
<span id="cb115-34"><a href="#cb115-34" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rfl</span></span>
<span id="cb115-35"><a href="#cb115-35" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb115-36"><a href="#cb115-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb115-37"><a href="#cb115-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Of course, <code>sbl_set A</code> is countable. The easiest way to prove this is to note that <code>seq_by_length A</code> is a function from <code>Nat</code> to <code>Set (List U)</code> whose range contains all of the sets in <code>sbl_set A</code>.</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_8_2_4_4 {U : <span class="kw">Type</span>} (A : Set U) : ctble (sbl_set A) := <span class="kw">by</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [Theorem_8_1_5_2]</span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Or.inr   <span class="co">--Goal : ∃ (f : Nat → Set (List U)), sbl_set A ⊆ range f</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (seq_by_length A)</span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> S : Set (List U)</span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h1 : S ∈ sbl_set A</span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1; <span class="kw">define</span></span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ∃ (x : Nat), seq_by_length A x = S <span class="kw">from</span> h1</span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We now have everything we need to prove <code>Theorem_8_2_4</code> as an application of <code>Theorem_8_2_2</code>.</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_8_2_4 {U : <span class="kw">Type</span>} {A : Set U}</span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>    (h1 : ctble A) : ctble (seq A) := <span class="kw">by</span></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> F : Set (Set (List U)) := sbl_set A</span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h2 : ctble F := Lemma_8_2_4_4 A</span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : ∀ S ∈ F, ctble S := <span class="kw">by</span></span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> S : Set (List U)</span>
<span id="cb117-7"><a href="#cb117-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h3 : S ∈ F</span>
<span id="cb117-8"><a href="#cb117-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h3</span>
<span id="cb117-9"><a href="#cb117-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (n : Nat) (h4 : seq_by_length A n = S) <span class="kw">from</span> h3</span>
<span id="cb117-10"><a href="#cb117-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←h4]</span>
<span id="cb117-11"><a href="#cb117-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ctble (seq_by_length A n) <span class="kw">from</span> Lemma_8_2_4_2 h1 n</span>
<span id="cb117-12"><a href="#cb117-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb117-13"><a href="#cb117-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←Lemma_8_2_4_3 A]</span>
<span id="cb117-14"><a href="#cb117-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ctble (⋃₀ sbl_set A) <span class="kw">from</span> Theorem_8_2_2 h2 h3</span>
<span id="cb117-15"><a href="#cb117-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>There is a set-theoretic operation that can produce an uncountable set from a countable set: the power set operation. <em>HTPI</em> demonstrates this by proving Cantor’s theorem (Theorem 8.2.5), which says that <span class="math inline">\(\mathscr{P}(\mathbb{Z}^+)\)</span> is uncountable. The strategy for this proof is tricky; it involves defining a set <span class="math inline">\(D\)</span> using a method called <em>diagonalization</em>. For an explanation of the motivation behind this strategy, see <em>HTPI</em>.</p>
<p>Here we will prove in Lean that the collection of all sets of natural numbers is uncountable. There is no need to use the power set operation for this, because we have a type, namely <code>Set Nat</code>, that contains all sets of natural numbers. So our Lean version of Cantor’s theorem says that <code>Set Nat</code> is uncountable.</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Cantor's_theorem : ¬ctble (Set Nat) := <span class="kw">by</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_contra</span> h1</span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [ctble_iff_set_nat_equinum] <span class="kw">at</span> h1</span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (J : Set Nat) (h2 : J ∼ Set Nat) <span class="kw">from</span> h1</span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (F : J → Set Nat) (h3 : one_to_one F ∧ onto F) <span class="kw">from</span> h2</span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> f : Nat → Set Nat := func_extend F ∅</span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> D : Set Nat := {n : Nat | n ∉ f n}</span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (nJ : J) (h4 : F nJ = D) <span class="kw">from</span> h3.right D</span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> n : Nat := nJ.val</span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : n ∈ D ↔ n ∉ f n := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb118-11"><a href="#cb118-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h6 : f n = F nJ := fe_elt F ∅ nJ</span>
<span id="cb118-12"><a href="#cb118-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h6, h4] <span class="kw">at</span> h5      <span class="co">--h5 : n ∈ D ↔ n ∉ D</span></span>
<span id="cb118-13"><a href="#cb118-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> h7 : n ∈ D</span>
<span id="cb118-14"><a href="#cb118-14" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h7 : n ∈ D</span></span>
<span id="cb118-15"><a href="#cb118-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">contradict</span> h7</span>
<span id="cb118-16"><a href="#cb118-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> n ∉ D <span class="kw">from</span> h5.ltr h7</span>
<span id="cb118-17"><a href="#cb118-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb118-18"><a href="#cb118-18" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h7 : n ∉ D</span></span>
<span id="cb118-19"><a href="#cb118-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">contradict</span> h7</span>
<span id="cb118-20"><a href="#cb118-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> n ∈ D <span class="kw">from</span> h5.rtl h7</span>
<span id="cb118-21"><a href="#cb118-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb118-22"><a href="#cb118-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>As a consequence of Theorem 8.2.5, <em>HTPI</em> shows that <span class="math inline">\(\mathbb{R}\)</span> is uncountable. The proof is not hard, but it requires facts about the decimal expansions of real numbers. Developing those facts in Lean would take us too far afield, so we will skip the proof.</p>
<section id="exercises-2" class="level3">
<h3 class="anchored" data-anchor-id="exercises-2">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb119"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> pair_ctble {U : <span class="kw">Type</span>}</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>    (a b : U) : ctble ↑({a, b} : Set U) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb120"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint:  Use the previous exercise and Theorem_8_2_2.</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_8_2_1_2 {U : <span class="kw">Type</span>} {A B : Set U}</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>    (h1 : ctble A) (h2 : ctble B) : ctble ↑(A ∪ B) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb121"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> remove_empty_union_eq {U : <span class="kw">Type</span>} (F : Set (Set U)) :</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>    ⋃₀ {A : Set U | A ∈ F ∧ ¬empty A} = ⋃₀ F := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb122"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> seq_cons_image {U : <span class="kw">Type</span>} (A : Set U) (n : Nat) :</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>    image (seq_cons U) (A ×ₛ (seq_by_length A n)) =</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>      seq_by_length A (n + 1) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb123"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint:  Apply Theorem_8_2_4 to the set Univ U.</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_8_2_4_type {U : <span class="kw">Type</span>}</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>    (h : ctble U) : ctble (List U) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="6">
<div class="sourceCode" id="cb124"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> list_to_set (U : <span class="kw">Type</span>) (l : List U) : Set U := {x : U | x ∈ l}</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> list_to_set_def (U : <span class="kw">Type</span>) (l : List U) (x : U) :</span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a>    x ∈ list_to_set U l ↔ x ∈ l := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint:  Use induction on the size of A.</span></span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> set_from_list {U : <span class="kw">Type</span>} {A : Set U} (h : finite A) :</span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a>    ∃ (l : List U), list_to_set U l = A := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="7">
<div class="sourceCode" id="cb125"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Hint:  Use the previous exercise and Theorem_8_2_4_type.</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Exercise_8_2_4 (U : <span class="kw">Type</span>) (h : ctble U) :</span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>    ctble {X : Set U | finite X} := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="8">
<div class="sourceCode" id="cb126"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_8_2_6b (U V W : <span class="kw">Type</span>) :</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>     ((U × V) → W) ∼ (U → V → W) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="9">
<div class="sourceCode" id="cb127"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Like_Exercise_8_2_7 : ∃ (P : Set (Set Nat)),</span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>    partition P ∧ denum P ∧ ∀ X ∈ P, denum X := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="10">
<div class="sourceCode" id="cb128"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> unctbly_many_inf_set_nat :</span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>    ¬ctble {X : Set Nat | ¬finite X} := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="11">
<div class="sourceCode" id="cb129"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_8_2_8 {U : <span class="kw">Type</span>} {A B : Set U}</span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>    (h : empty (A ∩ B)) : 𝒫 (A ∪ B) ∼ 𝒫 A ×ₛ 𝒫 B := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="the-cantorschröderbernstein-theorem" class="level2">
<h2 class="anchored" data-anchor-id="the-cantorschröderbernstein-theorem">8.3. The Cantor–Schröder–Bernstein Theorem</h2>
<p>The final section of <em>HTPI</em> proves the Cantor–Schröder–Bernstein theorem. The theorem says that if we have two sets such that there is a one-to-one function from each set to the other, then the two sets are equinumerous. We will prove it in Lean for types, but of course we can apply it to sets as well by coercing the sets to subtypes.</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Cantor_Schroeder_Bernstein_theorem</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>    {U V : <span class="kw">Type</span>} {f : U → V} {g : V → U}</span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a>    (h1 : one_to_one f) (h2 : one_to_one g) : U ∼ V</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To prove the theorem, we must produce a one-to-one, onto function <code>h</code> from <code>U</code> to <code>V</code>. Imitating the proof in <em>HTPI</em>, we will do this by defining a set <code>X : Set U</code> and then using <code>f</code> to determine the values of <code>h</code> on elements of the domain that belong to <code>X</code> and the inverse of <code>g</code> for those that don’t. That is, the graph of <code>h</code> will be the set <code>csb_func_graph f g X</code> defined as follows:</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> csb_func_graph {U V : <span class="kw">Type</span>}</span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>  (f : U → V) (g : V → U) (X : Set U) : Set (U × V) :=</span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>  {(x, y) : U × V | (x ∈ X ∧ f x = y) ∨ (x ∉ X ∧ g y = x)}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Is <code>csb_func_graph f g X</code> the graph of a function? It is not hard to show that it is, as long as <code>∀ (x : U), x ∉ X → x ∈ range g</code>. We first state lemmas spelling out the two cases in the definition of <code>csb_func_graph f g X</code>, leaving the proof of the second as an exercise for you.</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> csb_func_graph_X {U V : <span class="kw">Type</span>} {X : Set U} {x : U}</span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>    (f : U → V) (g : V → U) (h : x ∈ X) (y : V) :</span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a>    (x, y) ∈ csb_func_graph f g X ↔ f x = y := <span class="kw">by</span></span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : (x, y) ∈ csb_func_graph f g X</span>
<span id="cb132-7"><a href="#cb132-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb132-8"><a href="#cb132-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h2 : ¬(x ∉ X ∧ g y = x) := <span class="kw">by</span></span>
<span id="cb132-9"><a href="#cb132-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">demorgan</span></span>
<span id="cb132-10"><a href="#cb132-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> x ∈ X ∨ g y ≠ x <span class="kw">from</span> Or.inl h</span>
<span id="cb132-11"><a href="#cb132-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb132-12"><a href="#cb132-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">disj_syll</span> h1 h2        <span class="co">--h1 : x ∈ X ∧ f x = y</span></span>
<span id="cb132-13"><a href="#cb132-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> f x = y <span class="kw">from</span> h1.right</span>
<span id="cb132-14"><a href="#cb132-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb132-15"><a href="#cb132-15" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb132-16"><a href="#cb132-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : f x = y</span>
<span id="cb132-17"><a href="#cb132-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb132-18"><a href="#cb132-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Or.inl</span>
<span id="cb132-19"><a href="#cb132-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> x ∈ X ∧ f x = y <span class="kw">from</span> And.intro h h1</span>
<span id="cb132-20"><a href="#cb132-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb132-21"><a href="#cb132-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb132-22"><a href="#cb132-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-23"><a href="#cb132-23" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> csb_func_graph_not_X {U V : <span class="kw">Type</span>} {X : Set U} {x : U}</span>
<span id="cb132-24"><a href="#cb132-24" aria-hidden="true" tabindex="-1"></a>    (f : U → V) (g : V → U) (h : x ∉ X) (y : V) :</span>
<span id="cb132-25"><a href="#cb132-25" aria-hidden="true" tabindex="-1"></a>    (x, y) ∈ csb_func_graph f g X ↔ g y = x := <span class="cn">sorry</span></span>
<span id="cb132-26"><a href="#cb132-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-27"><a href="#cb132-27" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> csb_func_graph_is_func_graph {U V : <span class="kw">Type</span>} {g : V → U} {X : Set U}</span>
<span id="cb132-28"><a href="#cb132-28" aria-hidden="true" tabindex="-1"></a>    (f : U → V) (h1 : ∀ (x : U), x ∉ X → x ∈ range g) (h2 : one_to_one g) :</span>
<span id="cb132-29"><a href="#cb132-29" aria-hidden="true" tabindex="-1"></a>    is_func_graph (csb_func_graph f g X) := <span class="kw">by</span></span>
<span id="cb132-30"><a href="#cb132-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb132-31"><a href="#cb132-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : U</span>
<span id="cb132-32"><a href="#cb132-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> h3 : x ∈ X</span>
<span id="cb132-33"><a href="#cb132-33" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h3 : x ∈ X</span></span>
<span id="cb132-34"><a href="#cb132-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">exists_unique</span></span>
<span id="cb132-35"><a href="#cb132-35" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Existence</span></span>
<span id="cb132-36"><a href="#cb132-36" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro (f x)</span>
<span id="cb132-37"><a href="#cb132-37" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [csb_func_graph_X f g h3]</span>
<span id="cb132-38"><a href="#cb132-38" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rfl</span></span>
<span id="cb132-39"><a href="#cb132-39" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb132-40"><a href="#cb132-40" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Uniqueness</span></span>
<span id="cb132-41"><a href="#cb132-41" aria-hidden="true" tabindex="-1"></a>      <span class="kw">fix</span> y1 : V; <span class="kw">fix</span> y2 : V</span>
<span id="cb132-42"><a href="#cb132-42" aria-hidden="true" tabindex="-1"></a>      <span class="kw">assume</span> h4 : (x, y1) ∈ csb_func_graph f g X</span>
<span id="cb132-43"><a href="#cb132-43" aria-hidden="true" tabindex="-1"></a>      <span class="kw">assume</span> h5 : (x, y2) ∈ csb_func_graph f g X</span>
<span id="cb132-44"><a href="#cb132-44" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [csb_func_graph_X f g h3] <span class="kw">at</span> h4  <span class="co">--h4 : f x = y1</span></span>
<span id="cb132-45"><a href="#cb132-45" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [csb_func_graph_X f g h3] <span class="kw">at</span> h5  <span class="co">--h5 : f x = y2</span></span>
<span id="cb132-46"><a href="#cb132-46" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [←h4, ←h5]</span>
<span id="cb132-47"><a href="#cb132-47" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rfl</span></span>
<span id="cb132-48"><a href="#cb132-48" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb132-49"><a href="#cb132-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb132-50"><a href="#cb132-50" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h3 : x ∉ X</span></span>
<span id="cb132-51"><a href="#cb132-51" aria-hidden="true" tabindex="-1"></a>    <span class="kw">exists_unique</span></span>
<span id="cb132-52"><a href="#cb132-52" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Existence</span></span>
<span id="cb132-53"><a href="#cb132-53" aria-hidden="true" tabindex="-1"></a>      <span class="kw">obtain</span> (y : V) (h4 : g y = x) <span class="kw">from</span> h1 x h3</span>
<span id="cb132-54"><a href="#cb132-54" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro y</span>
<span id="cb132-55"><a href="#cb132-55" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [csb_func_graph_not_X f g h3]</span>
<span id="cb132-56"><a href="#cb132-56" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> g y = x <span class="kw">from</span> h4</span>
<span id="cb132-57"><a href="#cb132-57" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb132-58"><a href="#cb132-58" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Uniqueness</span></span>
<span id="cb132-59"><a href="#cb132-59" aria-hidden="true" tabindex="-1"></a>      <span class="kw">fix</span> y1 : V; <span class="kw">fix</span> y2 : V</span>
<span id="cb132-60"><a href="#cb132-60" aria-hidden="true" tabindex="-1"></a>      <span class="kw">assume</span> h4 : (x, y1) ∈ csb_func_graph f g X</span>
<span id="cb132-61"><a href="#cb132-61" aria-hidden="true" tabindex="-1"></a>      <span class="kw">assume</span> h5 : (x, y2) ∈ csb_func_graph f g X</span>
<span id="cb132-62"><a href="#cb132-62" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [csb_func_graph_not_X f g h3] <span class="kw">at</span> h4 <span class="co">--h4 : g y1 = x</span></span>
<span id="cb132-63"><a href="#cb132-63" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [csb_func_graph_not_X f g h3] <span class="kw">at</span> h5 <span class="co">--h5 : g y2 = x</span></span>
<span id="cb132-64"><a href="#cb132-64" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [←h5] <span class="kw">at</span> h4</span>
<span id="cb132-65"><a href="#cb132-65" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> y1 = y2 <span class="kw">from</span> h2 y1 y2 h4</span>
<span id="cb132-66"><a href="#cb132-66" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb132-67"><a href="#cb132-67" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb132-68"><a href="#cb132-68" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Our plan is to define <code>h</code> to be the function whose graph is <code>csb_func_graph f g X</code>. With this definition, the value of <code>h x</code> for any <code>x : U</code> can be determined by a simple rule: if <code>x ∈ X</code>, then <code>h x = f x</code>, and if <code>x ∉ X</code>, then <code>h x</code> has the property that <code>g (h x) = x</code>:</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> csb_func_X</span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>    {U V : <span class="kw">Type</span>} {f h : U → V} {g : V → U} {X : Set U} {x : U}</span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a>    (h1 : graph h = csb_func_graph f g X) (h2 : x ∈ X) : h x = f x := <span class="kw">by</span></span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←graph_def, h1, csb_func_graph_X f g h2]</span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rfl</span></span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb133-7"><a href="#cb133-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-8"><a href="#cb133-8" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> csb_func_not_X</span>
<span id="cb133-9"><a href="#cb133-9" aria-hidden="true" tabindex="-1"></a>    {U V : <span class="kw">Type</span>} {f h : U → V} {g : V → U} {X : Set U} {x : U}</span>
<span id="cb133-10"><a href="#cb133-10" aria-hidden="true" tabindex="-1"></a>    (h1 : graph h = csb_func_graph f g X) (h2 : x ∉ X) : g (h x) = x := <span class="kw">by</span></span>
<span id="cb133-11"><a href="#cb133-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : (x, h x) ∈ graph h := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb133-12"><a href="#cb133-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [h1, csb_func_graph_not_X f g h2] <span class="kw">at</span> h3</span>
<span id="cb133-13"><a href="#cb133-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> g (h x) = x <span class="kw">from</span> h3</span>
<span id="cb133-14"><a href="#cb133-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We still have to say how <code>X</code> will be defined. Let <code>A0 = {x : U | x ∉ range g}</code>. To make sure that the condition <code>∀ (x : U), x ∉ X → x ∈ range g</code> is satisfied, we will need to have <code>A0 ⊆ X</code>. As explained in <em>HTPI</em>, we can now get a suitable set <code>X</code> by repeatedly taking the image of <code>A0</code> under <code>g ∘ f</code>. Fortunately, we defined functions in Section 6.5 that do what we need: <code>rep_image (g ∘ f) n A0</code> is the result of taking the image of <code>A0</code> under <code>g ∘ f</code> <code>n</code> times. That is, <code>rep_image (g ∘ f) 0 A0 = A0</code>, <code>rep_image (g ∘ f) 1 A0 = image (g ∘ f) A0</code>, <code>rep_image (g ∘ f) 2 A0 = image (g ∘ f) (image (g ∘ f) A0)</code>, and so on. We will define <code>X</code> to be the union of all of the sets <code>rep_image (g ∘ f) n A0</code>, which is given by the function <code>cumul_image (g ∘ f) A0</code>.</p>
<p>To prove that <code>h</code> is one-to-one, we will need to know that it cannot happen that <code>h x1 = h x2</code>, <code>x1 ∈ X</code>, and <code>x2 ∉ X</code>. After proving this last lemma, we are ready to prove the Cantor–Schröder–Bernstein theorem.</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> csb_X_of_X</span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>    {U V : <span class="kw">Type</span>} {f h : U → V} {g : V → U} {A0 : Set U} {x1 x2 : U}</span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>    (h1 : graph h = csb_func_graph f g (cumul_image (g ∘ f) A0))</span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a>    (h2 : h x1 = h x2) (h3 : x1 ∈ cumul_image (g ∘ f) A0) :</span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>    x2 ∈ cumul_image (g ∘ f) A0 := <span class="kw">by</span></span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_contra</span> h4                      <span class="co">--h4 : x2 ∉ cumul_image (g ∘ f) A0</span></span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [csb_func_X h1 h3] <span class="kw">at</span> h2  <span class="co">--h2 : f x1 = h x2</span></span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h5 : (g ∘ f) x1 = x2 :=</span>
<span id="cb134-9"><a href="#cb134-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> (g ∘ f) x1</span>
<span id="cb134-10"><a href="#cb134-10" aria-hidden="true" tabindex="-1"></a>      _ = g (f x1) := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb134-11"><a href="#cb134-11" aria-hidden="true" tabindex="-1"></a>      _ = g (h x2) := <span class="kw">by</span> <span class="kw">rw</span> [h2]</span>
<span id="cb134-12"><a href="#cb134-12" aria-hidden="true" tabindex="-1"></a>      _ = x2 := csb_func_not_X h1 h4</span>
<span id="cb134-13"><a href="#cb134-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (n : Nat) (h6 : x1 ∈ rep_image (g ∘ f) n A0) <span class="kw">from</span> h3</span>
<span id="cb134-14"><a href="#cb134-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">contradict</span> h4               <span class="co">--Goal : x2 ∈ cumul_image (g ∘ f) A0</span></span>
<span id="cb134-15"><a href="#cb134-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (n + 1)  <span class="co">--Goal : x2 ∈ rep_image (g ∘ f) (n + 1) A0</span></span>
<span id="cb134-16"><a href="#cb134-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [rep_image_step]</span>
<span id="cb134-17"><a href="#cb134-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro x1</span>
<span id="cb134-18"><a href="#cb134-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> x1 ∈ rep_image (g ∘ f) n A0 ∧ (g ∘ f) x1 = x2 <span class="kw">from</span></span>
<span id="cb134-19"><a href="#cb134-19" aria-hidden="true" tabindex="-1"></a>    And.intro h6 h5</span>
<span id="cb134-20"><a href="#cb134-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb134-21"><a href="#cb134-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-22"><a href="#cb134-22" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Cantor_Schroeder_Bernstein_theorem</span>
<span id="cb134-23"><a href="#cb134-23" aria-hidden="true" tabindex="-1"></a>    {U V : <span class="kw">Type</span>} {f : U → V} {g : V → U}</span>
<span id="cb134-24"><a href="#cb134-24" aria-hidden="true" tabindex="-1"></a>    (h1 : one_to_one f) (h2 : one_to_one g) : U ∼ V := <span class="kw">by</span></span>
<span id="cb134-25"><a href="#cb134-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> A0 : Set U := {x : U | x ∉ range g}</span>
<span id="cb134-26"><a href="#cb134-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> X : Set U := cumul_image (g ∘ f) A0</span>
<span id="cb134-27"><a href="#cb134-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> H : Set (U × V) := csb_func_graph f g X</span>
<span id="cb134-28"><a href="#cb134-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h3 : ∀ (x : U), x ∉ X → x ∈ range g := <span class="kw">by</span></span>
<span id="cb134-29"><a href="#cb134-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> x : U</span>
<span id="cb134-30"><a href="#cb134-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">contrapos</span></span>
<span id="cb134-31"><a href="#cb134-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h3 : x ∉ range g</span>
<span id="cb134-32"><a href="#cb134-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb134-33"><a href="#cb134-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro 0</span>
<span id="cb134-34"><a href="#cb134-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [rep_image_base]</span>
<span id="cb134-35"><a href="#cb134-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> x ∈ A0 <span class="kw">from</span> h3</span>
<span id="cb134-36"><a href="#cb134-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb134-37"><a href="#cb134-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h4 : is_func_graph H := csb_func_graph_is_func_graph f h3 h2</span>
<span id="cb134-38"><a href="#cb134-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←func_from_graph] <span class="kw">at</span> h4</span>
<span id="cb134-39"><a href="#cb134-39" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (h : U → V) (h5 : graph h = H) <span class="kw">from</span> h4</span>
<span id="cb134-40"><a href="#cb134-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro h</span>
<span id="cb134-41"><a href="#cb134-41" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro</span>
<span id="cb134-42"><a href="#cb134-42" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- proof that h is one-to-one</span></span>
<span id="cb134-43"><a href="#cb134-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> x1 : U; <span class="kw">fix</span> x2 : U</span>
<span id="cb134-44"><a href="#cb134-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h6 : h x1 = h x2</span>
<span id="cb134-45"><a href="#cb134-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">by_cases</span> h7 : x1 ∈ X</span>
<span id="cb134-46"><a href="#cb134-46" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 1. h7 : x1 ∈ X</span></span>
<span id="cb134-47"><a href="#cb134-47" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h8 : x2 ∈ X := csb_X_of_X h5 h6 h7</span>
<span id="cb134-48"><a href="#cb134-48" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [csb_func_X h5 h7, csb_func_X h5 h8] <span class="kw">at</span> h6 <span class="co">--h6 : f x1 = f x2</span></span>
<span id="cb134-49"><a href="#cb134-49" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> x1 = x2 <span class="kw">from</span> h1 x1 x2 h6</span>
<span id="cb134-50"><a href="#cb134-50" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb134-51"><a href="#cb134-51" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 2. h7 : x1 ∉ X</span></span>
<span id="cb134-52"><a href="#cb134-52" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h8 : x2 ∉ X := <span class="kw">by</span></span>
<span id="cb134-53"><a href="#cb134-53" aria-hidden="true" tabindex="-1"></a>        <span class="kw">contradict</span> h7 <span class="kw">with</span> h8</span>
<span id="cb134-54"><a href="#cb134-54" aria-hidden="true" tabindex="-1"></a>        <span class="kw">show</span> x1 ∈ X <span class="kw">from</span> csb_X_of_X h5 h6.symm h8</span>
<span id="cb134-55"><a href="#cb134-55" aria-hidden="true" tabindex="-1"></a>        <span class="kw">done</span></span>
<span id="cb134-56"><a href="#cb134-56" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> x1 = x2 <span class="kw">from</span></span>
<span id="cb134-57"><a href="#cb134-57" aria-hidden="true" tabindex="-1"></a>        <span class="kw">calc</span> x1</span>
<span id="cb134-58"><a href="#cb134-58" aria-hidden="true" tabindex="-1"></a>          _ = g (h x1) := (csb_func_not_X h5 h7).symm</span>
<span id="cb134-59"><a href="#cb134-59" aria-hidden="true" tabindex="-1"></a>          _ = g (h x2) := <span class="kw">by</span> <span class="kw">rw</span> [h6]</span>
<span id="cb134-60"><a href="#cb134-60" aria-hidden="true" tabindex="-1"></a>          _ = x2 := csb_func_not_X h5 h8</span>
<span id="cb134-61"><a href="#cb134-61" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb134-62"><a href="#cb134-62" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb134-63"><a href="#cb134-63" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- proof that h is onto</span></span>
<span id="cb134-64"><a href="#cb134-64" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> y : V</span>
<span id="cb134-65"><a href="#cb134-65" aria-hidden="true" tabindex="-1"></a>    <span class="kw">by_cases</span> h6 : g y ∈ X</span>
<span id="cb134-66"><a href="#cb134-66" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 1. h6 : g y ∈ X</span></span>
<span id="cb134-67"><a href="#cb134-67" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span> <span class="kw">at</span> h6</span>
<span id="cb134-68"><a href="#cb134-68" aria-hidden="true" tabindex="-1"></a>      <span class="kw">obtain</span> (n : Nat) (h7 : g y ∈ rep_image (g ∘ f) n A0) <span class="kw">from</span> h6</span>
<span id="cb134-69"><a href="#cb134-69" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h8 : n ≠ 0 := <span class="kw">by</span></span>
<span id="cb134-70"><a href="#cb134-70" aria-hidden="true" tabindex="-1"></a>        <span class="kw">by_contra</span> h8</span>
<span id="cb134-71"><a href="#cb134-71" aria-hidden="true" tabindex="-1"></a>        <span class="kw">rewrite</span> [h8, rep_image_base] <span class="kw">at</span> h7 <span class="co">--h7 : g y ∈ A0</span></span>
<span id="cb134-72"><a href="#cb134-72" aria-hidden="true" tabindex="-1"></a>        <span class="kw">define</span> <span class="kw">at</span> h7                       <span class="co">--h7 : ¬∃ (x : V), g x = g y</span></span>
<span id="cb134-73"><a href="#cb134-73" aria-hidden="true" tabindex="-1"></a>        <span class="kw">contradict</span> h7</span>
<span id="cb134-74"><a href="#cb134-74" aria-hidden="true" tabindex="-1"></a>        <span class="kw">apply</span> Exists.intro y</span>
<span id="cb134-75"><a href="#cb134-75" aria-hidden="true" tabindex="-1"></a>        <span class="kw">rfl</span></span>
<span id="cb134-76"><a href="#cb134-76" aria-hidden="true" tabindex="-1"></a>        <span class="kw">done</span></span>
<span id="cb134-77"><a href="#cb134-77" aria-hidden="true" tabindex="-1"></a>      <span class="kw">obtain</span> (k : Nat) (h9 : n = k + 1) <span class="kw">from</span></span>
<span id="cb134-78"><a href="#cb134-78" aria-hidden="true" tabindex="-1"></a>        exists_eq_add_one_of_ne_zero h8</span>
<span id="cb134-79"><a href="#cb134-79" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [h9, rep_image_step] <span class="kw">at</span> h7</span>
<span id="cb134-80"><a href="#cb134-80" aria-hidden="true" tabindex="-1"></a>      <span class="kw">obtain</span> (x : U)</span>
<span id="cb134-81"><a href="#cb134-81" aria-hidden="true" tabindex="-1"></a>        (h10 : x ∈ rep_image (g ∘ f) k A0 ∧ (g ∘ f) x = g y) <span class="kw">from</span> h7</span>
<span id="cb134-82"><a href="#cb134-82" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h11 : g (f x) = g y := h10.right</span>
<span id="cb134-83"><a href="#cb134-83" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h12 : f x = y := h2 (f x) y h11</span>
<span id="cb134-84"><a href="#cb134-84" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h13 : x ∈ X := Exists.intro k h10.left</span>
<span id="cb134-85"><a href="#cb134-85" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro x</span>
<span id="cb134-86"><a href="#cb134-86" aria-hidden="true" tabindex="-1"></a>      <span class="kw">rewrite</span> [csb_func_X h5 h13]</span>
<span id="cb134-87"><a href="#cb134-87" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> f x = y <span class="kw">from</span> h12</span>
<span id="cb134-88"><a href="#cb134-88" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb134-89"><a href="#cb134-89" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Case 2. h6 : g y ∉ X</span></span>
<span id="cb134-90"><a href="#cb134-90" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Exists.intro (g y)</span>
<span id="cb134-91"><a href="#cb134-91" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h7 : g (h (g y)) = g y := csb_func_not_X h5 h6</span>
<span id="cb134-92"><a href="#cb134-92" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> h (g y) = y <span class="kw">from</span> h2 (h (g y)) y h7</span>
<span id="cb134-93"><a href="#cb134-93" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb134-94"><a href="#cb134-94" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb134-95"><a href="#cb134-95" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="exercises-3" class="level3">
<h3 class="anchored" data-anchor-id="exercises-3">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb135"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> csb_func_graph_not_X {U V : <span class="kw">Type</span>} {X : Set U} {x : U}</span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>    (f : U → V) (g : V → U) (h : x ∉ X) (y : V) :</span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>    (x, y) ∈ csb_func_graph f g X ↔ g y = x := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb136"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> intervals_equinum :</span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>    {x : Real | 0 &lt; x ∧ x &lt; 1} ∼ {x : Real | 0 &lt; x ∧ x ≤ 1} := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>3. The following theorem could be thought of as an extensionality principle for relations. You may find it useful in later exercises. Hint for proof: First show that <code>extension R = extension S</code>, and then use the fact that <code>R</code> and <code>S</code> can be determined from <code>extension R</code> and <code>extension S</code> (see Section 4.3).</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> relext {U V : <span class="kw">Type</span>} {R S : Rel U V}</span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>    (h : ∀ (u : U) (v : V), R u v ↔ S u v) : R = S := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="mdsk">

</div>
<p>The next six exercises lead up to a proof that the set of all equivalence relations on the natural numbers is equinumerous with the type <code>Set Nat</code>. These exercises use the following definitions:</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> EqRel (U : <span class="kw">Type</span>) : Set (BinRel U) :=</span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>  {R : BinRel U | equiv_rel R}</span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Part (U : <span class="kw">Type</span>) : Set (Set (Set U)) :=</span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true" tabindex="-1"></a>  {P : Set (Set U) | partition P}</span>
<span id="cb138-6"><a href="#cb138-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-7"><a href="#cb138-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> EqRelExt (U : <span class="kw">Type</span>) : Set (Set (U × U)) :=</span>
<span id="cb138-8"><a href="#cb138-8" aria-hidden="true" tabindex="-1"></a>  {E : Set (U × U) | ∃ (R : BinRel U), equiv_rel R ∧ extension R = E}</span>
<span id="cb138-9"><a href="#cb138-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-10"><a href="#cb138-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> shift_and_zero (X : Set Nat) : Set Nat :=</span>
<span id="cb138-11"><a href="#cb138-11" aria-hidden="true" tabindex="-1"></a>  {x + 2 | x ∈ X} ∪ {0}</span>
<span id="cb138-12"><a href="#cb138-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-13"><a href="#cb138-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> shift_and_zero_comp (X : Set Nat) : Set Nat :=</span>
<span id="cb138-14"><a href="#cb138-14" aria-hidden="true" tabindex="-1"></a>  {n : Nat | n ∉ shift_and_zero X}</span>
<span id="cb138-15"><a href="#cb138-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-16"><a href="#cb138-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> saz_pair (X : Set Nat) : Set (Set Nat) :=</span>
<span id="cb138-17"><a href="#cb138-17" aria-hidden="true" tabindex="-1"></a>  {shift_and_zero X, shift_and_zero_comp X}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb139"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> EqRel_equinum_Part (U : <span class="kw">Type</span>) : EqRel U ∼ Part U := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb140"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> EqRel_equinum_EqRelExt (U : <span class="kw">Type</span>) :</span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a>    EqRel U ∼ EqRelExt U := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="6">
<div class="sourceCode" id="cb141"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> EqRel_Nat_to_Set_Nat :</span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>    ∃ (f : EqRel Nat → Set Nat), one_to_one f := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="7">
<div class="sourceCode" id="cb142"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> saz_pair_part (X : Set Nat) : saz_pair X ∈ Part Nat := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="8">
<div class="sourceCode" id="cb143"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Set_Nat_to_EqRel_Nat :</span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a>    ∃ (f : Set Nat → EqRel Nat), one_to_one f := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="9">
<div class="sourceCode" id="cb144"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> EqRel_Nat_equinum_Set_Nat : EqRel Nat ∼ Set Nat := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>


</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>The axiom of choice was first stated by Ernst Zermelo in 1904. You can learn more about it in Gregory H. Moore, <em>Zermelo’s Axiom of Choice: Its Origins, Development, and Influence</em>, Dover Publications, 2013. See also <a href="https://en.wikipedia.org/wiki/Axiom_of_choice" class="uri">https://en.wikipedia.org/wiki/Axiom_of_choice</a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Chap7.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Number Theory</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./Appendix.html" class="pagination-link">
        <span class="nav-page-text">Appendix</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
      <div class="nav-footer-center">© 2023-2025 Daniel J. Velleman.<br>Short excerpts from Daniel J. Velleman, <a href="https://doi.org/10.1017/9781108539890"><i>How To Prove It: A Structured Approach, 3rd Edition</i></a><br>© Daniel J. Velleman 2019, published by Cambridge University Press, reprinted with permission.</div>
  </div>
</footer>



</body></html>