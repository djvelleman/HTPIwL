<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.189">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>How To Prove It with Lean - 4&nbsp; Relations</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Chap5.html" rel="next">
<link href="./Chap3.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="HTPIwLstyles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Relations</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">How To Prove It with Lean</a> 
        <div class="sidebar-tools-main">
    <a href="./How-To-Prove-It-with-Lean.pdf" title="Download PDF" class="sidebar-tool px-1"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Preface</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap1.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Sentential Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap2.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Quantificational Logic</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./IntroLean.html" class="sidebar-item-text sidebar-link">Introduction to Lean</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap3.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Proofs</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap4.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Relations</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap5.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Functions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap6.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Mathematical Induction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap7.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Number Theory</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap8.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Infinite Sets</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Appendix.html" class="sidebar-item-text sidebar-link">Appendix</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">In This Chapter</h2>
   
  <ul class="collapse">
  <li><a href="#ordered-pairs-and-cartesian-products" id="toc-ordered-pairs-and-cartesian-products" class="nav-link active" data-scroll-target="#ordered-pairs-and-cartesian-products">4.1. Ordered Pairs and Cartesian Products</a></li>
  <li><a href="#relations" id="toc-relations" class="nav-link" data-scroll-target="#relations">4.2. Relations</a></li>
  <li><a href="#more-about-relations" id="toc-more-about-relations" class="nav-link" data-scroll-target="#more-about-relations">4.3. More About Relations</a></li>
  <li><a href="#ordering-relations" id="toc-ordering-relations" class="nav-link" data-scroll-target="#ordering-relations">4.4. Ordering Relations</a></li>
  <li><a href="#equivalence-relations" id="toc-equivalence-relations" class="nav-link" data-scroll-target="#equivalence-relations">4.5. Equivalence Relations</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<div class="hidden">
$$
\newcommand{\setmin}{\mathbin{\backslash}}
\newcommand{\symmdiff}{\mathbin{∆}}
$$
</div>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Relations</span></h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<section id="ordered-pairs-and-cartesian-products" class="level2">
<h2 class="anchored" data-anchor-id="ordered-pairs-and-cartesian-products">4.1. Ordered Pairs and Cartesian Products</h2>
<p>Section 4.1 of <em>How To Prove It</em> defines the <em>Cartesian product</em> <span class="math inline">\(A \times B\)</span> of two sets <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> to be the set of all ordered pairs <span class="math inline">\((a, b)\)</span>, where <span class="math inline">\(a \in A\)</span> and <span class="math inline">\(b \in B\)</span>. However, in Lean, Cartesian product is an operation on <em>types</em>, not sets. If <code>A</code> and <code>B</code> are types, then <code>A × B</code> is the type of ordered pairs <code>(a, b)</code>, where <code>a</code> has type <code>A</code> and <code>b</code> has type <code>B</code>. (To enter the symbol <code>×</code> in Lean, type <code>\times</code> or <code>\x</code>.) In other words, if you have <code>a : A</code> and <code>b : B</code>, then <code>(a, b)</code> is an object of type <code>A × B</code>. There is also notation for the first and second coordinates of an ordered pair. If <code>p</code> has type <code>A × B</code>, then <code>p.fst</code> is the first coordinate of <code>p</code>, and <code>p.snd</code> is the second coordinate. You can also use the notation <code>p.1</code> for the first coordinate of <code>p</code> and <code>p.2</code> for the second coordinate. This means that <code>p = (p.fst, p.snd) = (p.1, p.2)</code>.</p>
</section>
<section id="relations" class="level2">
<h2 class="anchored" data-anchor-id="relations">4.2. Relations</h2>
<p>Section 4.2 of <em>HTPI</em> defines a <em>relation from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span></em> to be a subset of <span class="math inline">\(A \times B\)</span>. In other words, if <span class="math inline">\(R\)</span> is a relation from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span>, then <span class="math inline">\(R\)</span> is a set whose element are ordered pairs <span class="math inline">\((a, b)\)</span>, where <span class="math inline">\(a \in A\)</span> and <span class="math inline">\(b \in B\)</span>. We will see in the next section that in Lean, it is convenient to use a somewhat different definition of relations. Nevertheless, we will take some time in this section to study sets of ordered pairs. If <code>A</code> and <code>B</code> are types, and <code>R</code> has type <code>Set (A × B)</code>, then <code>R</code> is a set whose elements are ordered pairs <code>(a, b)</code>, where <code>a</code> has type <code>A</code> and <code>b</code> has type <code>B</code>.</p>
<p>Section 4.2 of <em>HTPI</em> discusses several concepts concerning relations. Here is how these concepts are defined in <em>HTPI</em> (<em>HTPI</em> p.&nbsp;183):</p>
<div class="ndfn" data-arguments="Definition 4.2.3">
<p>Suppose <span class="math inline">\(R\)</span> is a relation from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span>. Then the <em>domain</em> of <span class="math inline">\(R\)</span> is the set</p>
<div class="quote">
<p><span class="math inline">\(\text{Dom}(R) = \{a \in A \mid \exists b \in B((a, b) \in R)\}\)</span>.</p>
</div>
<p>The <em>range</em> of <span class="math inline">\(R\)</span> is the set</p>
<div class="quote">
<p><span class="math inline">\(\text{Ran}(R) = \{b \in B \mid \exists a \in A((a, b) \in R)\}\)</span>.</p>
</div>
<p>The <em>inverse</em> of <span class="math inline">\(R\)</span> is the relation <span class="math inline">\(R^{-1}\)</span> from <span class="math inline">\(B\)</span> to <span class="math inline">\(A\)</span> define as follows:</p>
<div class="quote">
<p><span class="math inline">\(R^{-1} = \{(b, a) \in B \times A \mid (a, b) \in R\}\)</span>.</p>
</div>
<p>Finally, suppose <span class="math inline">\(R\)</span> is a relation from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span> and <span class="math inline">\(S\)</span> is a relation from <span class="math inline">\(B\)</span> to <span class="math inline">\(C\)</span>. Then the <em>composition</em> of <span class="math inline">\(S\)</span> and <span class="math inline">\(R\)</span> is the relation <span class="math inline">\(S \circ R\)</span> from <span class="math inline">\(A\)</span> to <span class="math inline">\(C\)</span> defined as follows:</p>
<div class="quote">
<p><span class="math inline">\(S \circ R = \{(a, c) \in A \times C \mid \exists b \in B((a, b) \in R \text{ and } (b, c) \in S)\}\)</span>.</p>
</div>
</div>
<p>There are several examples in <em>HTPI</em> that illustrate these definitions. We will focus here on seeing how to work with these concepts in Lean.</p>
<p>We can write corresponding definitions in Lean as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Dom {A B : <span class="kw">Type</span>} (R : Set (A × B)) : Set A :=</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  {a : A | ∃ (b : B), (a, b) ∈ R}</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Ran {A B : <span class="kw">Type</span>} (R : Set (A × B)) : Set B :=</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  {b : B | ∃ (a : A), (a, b) ∈ R}</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> inv {A B : <span class="kw">Type</span>} (R : Set (A × B)) : Set (B × A) :=</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  {(b, a) : B × A | (a, b) ∈ R}</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> comp {A B C : <span class="kw">Type</span>}</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    (S : Set (B × C)) (R : Set (A × B)) : Set (A × C) :=</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  {(a, c) : A × C | ∃ (x : B), (a, x) ∈ R ∧ (x, c) ∈ S}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Definitions in Lean are introduced with the keyword <code>def</code>. In the definition of <code>Dom</code>, we have declared that <code>A</code> and <code>B</code> are implicit arguments and <code>R</code> is an explicit argument. That means that, in a Lean file containing these definitions, if we have <code>R : Set (A × B)</code>, then we can just write <code>Dom R</code> for the domain of <code>R</code>, and Lean will figure out for itself what <code>A</code> and <code>B</code> are. After the list of arguments there is a colon and then the type of <code>Dom R</code>, which is <code>Set A</code>. This is followed by <code>:=</code> and then the definition of <code>Dom R</code>. The definition says that <code>Dom R</code> is the set of all objects <code>a</code> of type <code>A</code> such that there is some <code>b</code> of type <code>B</code> with <code>(a, b) ∈ R</code>. This is a direct translation, into Lean’s type-theory language, of the first part of Definition 4.2.3. The other three definitions are similar; they define <code>Ran R</code> to be the range of <code>R</code>, <code>inv R</code> to be the inverse of <code>R</code>, and <code>comp S R</code> to be the composition of <code>S</code> and <code>R</code>.</p>
<p>Here is the main theorem about these concepts, as stated in <em>HTPI</em> (<em>HTPI</em> p.&nbsp;187):</p>
<div class="nthm" data-arguments="Theorem 4.2.5">
<p>Suppose <span class="math inline">\(R\)</span> is a relation from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span>, <span class="math inline">\(S\)</span> is a relation from <span class="math inline">\(B\)</span> to <span class="math inline">\(C\)</span>, and <span class="math inline">\(T\)</span> is a relation from <span class="math inline">\(C\)</span> to <span class="math inline">\(D\)</span>. Then:</p>
<ol type="1">
<li><span class="math inline">\((R^{-1})^{-1} = R\)</span>.</li>
<li><span class="math inline">\(\mathrm{Dom}(R^{-1}) = \mathrm{Ran}(R)\)</span>.</li>
<li><span class="math inline">\(\mathrm{Ran}(R^{-1}) = \mathrm{Dom}(R)\)</span>.</li>
<li><span class="math inline">\(T \circ (S \circ R) = (T \circ S) \circ R\)</span>.</li>
<li><span class="math inline">\((S \circ R)^{-1} = R^{-1} \circ S^{-1}\)</span>.</li>
</ol>
</div>
<p>All five parts of this theorem follow directly from the definitions of the relevant concepts. In fact, in the first three parts, Lean recognizes the two sides of the equation as being definitionally equal, and therefore the tactic <code>rfl</code> proves those parts:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_2_5_1 {A B : <span class="kw">Type</span>}</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    (R : Set (A × B)) : inv (inv R) = R := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_2_5_2 {A B : <span class="kw">Type</span>}</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    (R : Set (A × B)) : Dom (inv R) = Ran R := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_2_5_3 {A B : <span class="kw">Type</span>}</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    (R : Set (A × B)) : Ran (inv R) = Dom R := <span class="kw">by</span> <span class="kw">rfl</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The fourth part will take a little more work to prove. We start the proof like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_2_5_4 {A B C D : <span class="kw">Type</span>}</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    (R : Set (A × B)) (S : Set (B × C)) (T : Set (C × D)) :</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    comp T (comp S R) = comp (comp T S) R := <span class="kw">by</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> (a, d) : A × D</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>After the <code>apply Set.ext</code> tactic, the goal is</p>
<div class="quote">
<p><code>∀ (x : A × D), x ∈ comp T (comp S R) ↔︎ x ∈ comp (comp T S) R</code></p>
</div>
<p>The next step should be to introduce an arbitrary object of type <code>A × D</code>. We could just call this object <code>x</code>, but Lean lets us use a shortcut here. An object of type <code>A × D</code> must have the form of an ordered pair, where the first coordinate has type <code>A</code> and the second has type <code>D</code>. So Lean lets us write it as an ordered pair right away. That’s what we’ve done in the second step, <code>fix (a, d) : A × D</code>. This tactic introduces two new variables into the proof, <code>a : A</code> and <code>d : D</code>. (The proof in <em>HTPI</em> uses a similar shortcut. And we used a similar shortcut in the definitions of <code>inv R</code> and <code>comp R</code>, where the elements of these sets were written as ordered pairs.)</p>
<p>Here is the complete proof.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_2_5_4 {A B C D : <span class="kw">Type</span>}</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    (R : Set (A × B)) (S : Set (B × C)) (T : Set (C × D)) :</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    comp T (comp S R) = comp (comp T S) R := <span class="kw">by</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> (a, d) : A × D</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : (a, d) ∈ comp T (comp S R)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>                     <span class="co">--Goal : (a, d) ∈ comp (comp T S) R</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>           <span class="co">--Goal : ∃ (x : B), (a, x) ∈ R ∧ (x, d) ∈ comp T S</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1     <span class="co">--h1 : ∃ (x : C), (a, x) ∈ comp S R ∧ (x, d) ∈ T</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (c : C) (h2 : (a, c) ∈ comp S R ∧ (c, d) ∈ T) <span class="kw">from</span> h1</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : (a, c) ∈ comp S R := h2.left</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h3     <span class="co">--h3 : ∃ (x : B), (a, x) ∈ R ∧ (x, c) ∈ S</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (b : B) (h4 : (a, b) ∈ R ∧ (b, c) ∈ S) <span class="kw">from</span> h3</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro b    <span class="co">--Goal : (a, b) ∈ R ∧ (b, d) ∈ comp T S</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro h4.left <span class="co">--Goal : (b, d) ∈ comp T S</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>                  <span class="co">--Goal : ∃ (x : C), (b, x) ∈ S ∧ (x, d) ∈ T</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ∃ (x : C), (b, x) ∈ S ∧ (x, d) ∈ T <span class="kw">from</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>      Exists.intro c (And.intro h4.right h2.right)</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : (a, d) ∈ comp (comp T S) R</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>; <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (b : B) (h2 : (a, b) ∈ R ∧ (b, d) ∈ comp T S) <span class="kw">from</span> h1</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : (b, d) ∈ comp T S := h2.right</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h3</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (c : C) (h4 : (b, c) ∈ S ∧ (c, d) ∈ T) <span class="kw">from</span> h3</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro c</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro _ h4.right</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ∃ (x : B), (a, x) ∈ R ∧ (x, c) ∈ S <span class="kw">from</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>      Exists.intro b (And.intro h2.left h4.left)</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Of course, if you have trouble reading this proof, you can enter it into Lean and see how the tactic state changes over the course of the proof.</p>
<p>Here is a natural way to start the proof of part 5:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_2_5_5 {A B C : <span class="kw">Type</span>}</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    (R : Set (A × B)) (S : Set (B × C)) :</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    inv (comp S R) = comp (inv R) (inv S) := <span class="kw">by</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> (c, a) : C × A</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : (c, a) ∈ inv (comp S R)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>                      <span class="co">--Goal : (c, a) ∈ comp (inv R) (inv S)</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1      <span class="co">--h1 : ∃ (x : B), (a, x) ∈ R ∧ (x, c) ∈ S</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>            <span class="co">--Goal : ∃ (x : B), (c, x) ∈ inv S ∧ (x, a) ∈ inv R</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (b : B) (h2 : (a, b) ∈ R ∧ (b, c) ∈ S) <span class="kw">from</span> h1</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro b         <span class="co">--Goal : (c, b) ∈ inv S ∧ (b, a) ∈ inv R</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>After the tactics <code>apply Set.ext</code> and <code>fix (c, a) : C × A</code>, the goal is <code>(c, a) ∈ inv (comp S R) ↔︎ (c, a) ∈ comp (inv R) (inv S)</code>. For the proof of the left-to-right direction, we assume <code>h1 : (c, a) ∈ inv (comp S R)</code>, and we must prove <code>(c, a) ∈ comp (inv R) (inv S)</code>. The definition of <code>h1</code> is an existential statement, so we apply existential instantiation to obtain <code>b : B</code> and <code>h2 : (a, b) ∈ R ∧ (b, c) ∈ S</code>. The definition of the goal is also an existential statement, and after the tactic <code>apply Exists.intro b</code>, the goal is <code>(c, b) ∈ inv S ∧ (b, a) ∈ inv R</code>. It looks like this goal will follow easily from <code>h2</code>, using the definitions of the inverses of <code>S</code> and <code>R</code>.</p>
<p>One way to write out these definitions would be to use the tactics <code>define : (c, b) ∈ inv S</code> and <code>define : (b, a) ∈ inv R</code>. But we’re going to use this example to illustrate another way to proceed. To use this alternative method, we’ll need to prove a preliminary theorem before proving part 5 of Theorem 4.2.5:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> inv_def {A B : <span class="kw">Type</span>} (R : Set (A × B)) (a : A) (b : B) :</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    (b, a) ∈ inv R ↔ (a, b) ∈ R := <span class="kw">by</span> <span class="kw">rfl</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now, any time we have a relation <code>R : Set (A × B)</code> and objects <code>a : A</code> and <code>b : B</code>, the expression <code>inv_def R a b</code> will be a proof of the statement <code>(b, a) ∈ inv R ↔︎ (a, b) ∈ R</code>. (Note that <code>A</code> and <code>B</code> are implicit arguments and don’t need to be specified.) And that means that the tactic <code>rewrite [inv_def R a b]</code> will change <code>(b, a) ∈ inv R</code> to <code>(a, b) ∈ R</code>. In fact, as we’ve seen before, you can just write <code>rewrite [inv_def]</code>, and Lean will figure out how to apply the theorem <code>inv_def</code> to rewrite some part of the goal.</p>
<p>Returning to our proof of part 5 of Theorem 4.2.5, recall that after the step <code>apply Exists.intro b</code>, the goal is <code>(c, b) ∈ inv S ∧ (b, a) ∈ inv R</code>. Rather than using the <code>define</code> tactic to write out the definitions of the inverses, we’ll use the tactic <code>rewrite [inv_def, inv_def]</code>. Why do we list <code>inv_def</code> twice in the <code>rewrite</code> tactic? When we ask Lean to use the theorem <code>inv_def</code> as a rewriting rule, it figures out that <code>inv_def S b c</code> is a proof of the statement <code>(c, b) ∈ inv S ↔︎ (b, c) ∈ S</code>, which can be used to rewrite the left half of the goal. To rewrite the right half, we need a different application of the <code>inv_def</code> theorem, <code>inv_def R a b</code>. So we have to ask Lean to apply the theorem a second time. After the <code>rewrite</code> tactic, the goal is <code>(b, c) ∈ S ∧ (a, b) ∈ R</code>, which will follow easily from <code>h2</code>.</p>
<p>The rest of the proof of straightforward. Here is the complete proof.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_2_5_5 {A B C : <span class="kw">Type</span>}</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    (R : Set (A × B)) (S : Set (B × C)) :</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    inv (comp S R) = comp (inv R) (inv S) := <span class="kw">by</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> (c, a) : C × A</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : (c, a) ∈ inv (comp S R)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>                      <span class="co">--Goal : (c, a) ∈ comp (inv R) (inv S)</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1      <span class="co">--h1 : ∃ (x : B), (a, x) ∈ R ∧ (x, c) ∈ S</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>            <span class="co">--Goal : ∃ (x : B), (c, x) ∈ inv S ∧ (x, a) ∈ inv R</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (b : B) (h2 : (a, b) ∈ R ∧ (b, c) ∈ S) <span class="kw">from</span> h1</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro b         <span class="co">--Goal : (c, b) ∈ inv S ∧ (b, a) ∈ inv R</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [inv_def, inv_def] <span class="co">--Goal : (b, c) ∈ S ∧ (a, b) ∈ R</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> (b, c) ∈ S ∧ (a, b) ∈ R <span class="kw">from</span> And.intro h2.right h2.left</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : (c, a) ∈ comp (inv R) (inv S)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (b : B) (h2 : (c, b) ∈ inv S ∧ (b, a) ∈ inv R) <span class="kw">from</span> h1</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Exists.intro b</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [inv_def, inv_def] <span class="kw">at</span> h2</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> (a, b) ∈ R ∧ (b, c) ∈ S <span class="kw">from</span> And.intro h2.right h2.left</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>By the way, an alternative way to complete both directions of this proof would have been to apply the commutativity of “and”. See if you can guess the name of that theorem (you can use <code>#check</code> to confirm your guess) and apply it as a third rewriting rule in the <code>rewrite</code> steps.</p>
<section id="exercises" class="level3">
<h3 class="anchored" data-anchor-id="exercises">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb8"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_2_9a {A B C : <span class="kw">Type</span>} (R : Set (A × B))</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    (S : Set (B × C)) : Dom (comp S R) ⊆ Dom R := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb9"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_2_9b {A B C : <span class="kw">Type</span>} (R : Set (A × B))</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    (S : Set (B × C)) : Ran R ⊆ Dom S → Dom (comp S R) = Dom R := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb10"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">--Fill in the blank to get a correct theorem and then prove the theorem</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_2_9c {A B C : <span class="kw">Type</span>} (R : Set (A × B))</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    (S : Set (B × C)) : ___ → Ran (comp S R) = Ran S := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb11"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_2_12a {A B C : <span class="kw">Type</span>}</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    (R : Set (A × B)) (S T : Set (B × C)) :</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    (comp S R) \ (comp T R) ⊆ comp (S \ T) R := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>5. Here is an incorrect theorem with an incorrect proof.</p>
<div class="nthm" data-arguments="Incorrect Theorem">
<p>Suppose <span class="math inline">\(R\)</span> is a relation from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span> and <span class="math inline">\(S\)</span> and <span class="math inline">\(T\)</span> are relations from <span class="math inline">\(B\)</span> to <span class="math inline">\(C\)</span>. Then <span class="math inline">\((S \setmin T) \circ R \subseteq (S \circ R) \setmin (T \circ R)\)</span>.</p>
</div>
<div class="npf" data-arguments="Incorrect Proof (HTPI p. 190)">
<p>Suppose <span class="math inline">\((a, c) \in (S \setmin T) \circ R\)</span>. Then we can choose some <span class="math inline">\(b \in B\)</span> such that <span class="math inline">\((a, b) \in R\)</span> and <span class="math inline">\((b, c) \in S \setmin T\)</span>, so <span class="math inline">\((b, c) \in S\)</span> and <span class="math inline">\((b, c) \notin T\)</span>. Since <span class="math inline">\((a, b) \in R\)</span> and <span class="math inline">\((b, c) \in S\)</span>, <span class="math inline">\((a, c) \in S \circ R\)</span>. Similarly, since <span class="math inline">\((a, b) \in R\)</span> and <span class="math inline">\((b, c) \notin T\)</span>, <span class="math inline">\((a, c) \notin T \circ R\)</span>. Therefore <span class="math inline">\((a, c) \in (S \circ R) \setmin (T \circ R)\)</span>. Since <span class="math inline">\((a, c)\)</span> was arbitrary, this shows that <span class="math inline">\((S \setmin T) \circ R \subseteq (S \circ R) \setmin (T \circ R)\)</span>. <span class="excl">&nbsp;□</span></p>
</div>
<p>Find the mistake in the proof by attempting to write the proof in Lean:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">--You won't be able to complete this proof</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_2_12b {A B C : <span class="kw">Type</span>}</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    (R : Set (A × B)) (S T : Set (B × C)) :</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    comp (S \ T) R ⊆ (comp S R) \ (comp T R) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>6. Is the following theorem correct? Try to prove it in Lean. If you can’t prove it, see if you can find a counterexample.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">--You might not be able to complete this proof</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_2_14c {A B C : <span class="kw">Type</span>}</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    (R : Set (A × B)) (S T : Set (B × C)) :</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    comp (S ∩ T) R = (comp S R) ∩ (comp T R) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>7. Is the following theorem correct? Try to prove it in Lean. If you can’t prove it, see if you can find a counterexample.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">--You might not be able to complete this proof</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_2_14d {A B C : <span class="kw">Type</span>}</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    (R : Set (A × B)) (S T : Set (B × C)) :</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    comp (S ∪ T) R = (comp S R) ∪ (comp T R) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="more-about-relations" class="level2">
<h2 class="anchored" data-anchor-id="more-about-relations">4.3. More About Relations</h2>
<p>Section 4.3 of <em>HTPI</em> introduces new notation for working with relations. If <span class="math inline">\(R \subseteq A \times B\)</span>, <span class="math inline">\(a \in A\)</span>, and <span class="math inline">\(b \in B\)</span>, then <em>HTPI</em> introduces the notation <span class="math inline">\(aRb\)</span> as an alternative way of saying <span class="math inline">\((a, b) \in R\)</span>.</p>
<p>The notation we will use in Lean is slightly different. Corresponding to the notation <span class="math inline">\(aRb\)</span> in <em>HTPI</em>, in Lean we will use the notation <code>R a b</code>. And we cannot use this notation when <code>R</code> has type <code>Set (A × B)</code>. Rather, we will need to introduce a new type for the variable <code>R</code> in the notation <code>R a b</code>. The name we will use for this new type is <code>Rel A B</code>. Thus, if <code>R</code> has type <code>Rel A B</code>, <code>a</code> has type <code>A</code>, and <code>b</code> has type <code>B</code>, then <code>R a b</code> is a proposition. This should remind you of the way predicates work in Lean. If we have <code>P : Pred A</code>, then we think of <code>P</code> as representing a property that an object of type <code>A</code> might have, and if we also have <code>a : A</code>, then <code>P a</code> is the proposition asserting that <code>a</code> has the property represented by <code>P</code>. Similarly, if we have <code>R : Rel A B</code>, then we can think of <code>R</code> as representing a relationship that might hold between an object of type <code>A</code> and an object of type <code>B</code>, and if we also have <code>a : A</code> and <code>b : B</code>, then <code>R a b</code> is the proposition asserting that the relationship represented by <code>R</code> holds between <code>a</code> and <code>b</code>.</p>
<p>Notice that in <em>HTPI</em>, the same variable <span class="math inline">\(R\)</span> is used in both the notation <span class="math inline">\(aRb\)</span> and <span class="math inline">\((a, b) \in R\)</span>. But in Lean, the notation <code>R a b</code> is used when <code>R</code> has type <code>Rel A B</code>, and the notation <code>(a, b) ∈ R</code> is used when <code>R</code> has type <code>Set (A × B)</code>. The types <code>Rel A B</code> and <code>Set (A × B)</code> are different, so we cannot use the same variable <code>R</code> in the two notations. However, there is a correspondence between the two types. Suppose <code>R</code> has type <code>Rel A B</code>. If we let <code>R'</code> denote the set of all ordered pairs <code>(a, b) : A × B</code> such that the proposition <code>R a b</code> is true, then <code>R'</code> has type <code>Set (A × B)</code>. And there is then a simple relationship between <code>R</code> and <code>R'</code>: for any objects <code>a : A</code> and <code>b : B</code>, the propositions <code>R a b</code> and <code>(a, b) ∈ R'</code> are equivalent. For our work in Lean, we will say that <code>R</code> is a <em>relation</em> from <code>A</code> to <code>B</code>, and <code>R'</code> is the <em>extension</em> of <code>R</code>.</p>
<p>We can define the extension of a relation, and state the correspondence between a relation and its extension, in Lean as follows:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> extension {A B : <span class="kw">Type</span>} (R : Rel A B) : Set (A × B) :=</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  {(a, b) : A × B | R a b}</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> ext_def {A B : <span class="kw">Type</span>} (R : Rel A B) (a : A) (b : B) :</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    (a, b) ∈ extension R ↔ R a b := <span class="kw">by</span> <span class="kw">rfl</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The rest of Chapter 4 of <em>HTPI</em> focuses on relations from a set to itself; in Lean, the corresponding idea is a relation from a type to itself. If <code>A</code> is any type and <code>R</code> has type <code>Rel A A</code>, then we will say that <code>R</code> is a <em>binary relation on <code>A</code></em>. The notation <code>BinRel A</code> denotes the type of binary relations on <code>A</code>. In other words, <code>BinRel A</code> is just an abbreviation for <code>Rel A A</code>. If <code>R</code> is a binary relation on <code>A</code>, then we say that <code>R</code> is <em>reflexive</em> if for every <code>x</code> of type <code>A</code>, <code>R x x</code> holds. It is <em>symmetric</em> if for all <code>x</code> and <code>y</code> of type <code>A</code>, if <code>R x y</code> then <code>R y x</code>. And it is <em>transitive</em> if for all <code>x</code>, <code>y</code>, and <code>z</code> of type <code>A</code>, if <code>R x y</code> and <code>R y z</code> then <code>R x z</code>. Of course, we can tell Lean about these definitions, which correspond to Definition 4.3.2 in <em>HTPI</em>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reflexive {A : <span class="kw">Type</span>} (R : BinRel A) : <span class="kw">Prop</span> :=</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  ∀ (x : A), R x x</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> symmetric {A : <span class="kw">Type</span>} (R : BinRel A) : <span class="kw">Prop</span> :=</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  ∀ (x y : A), R x y → R y x</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> transitive {A : <span class="kw">Type</span>} (R : BinRel A) : <span class="kw">Prop</span> :=</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>  ∀ (x y z : A), R x y → R y z → R x z</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Once again, we refer you to <em>HTPI</em> to see examples of these concepts, and we focus here on proving theorems about these concepts in Lean. The main theorem about these concepts in Section 4.3 of <em>HTPI</em> is Theorem 4.3.4. Here is what it says (<em>HTPI</em> p.&nbsp;196):</p>
<div class="nthm" data-arguments="Theorem 4.3.4">
<p>Suppose <span class="math inline">\(R\)</span> is a relation on a set <span class="math inline">\(A\)</span>.</p>
<ol type="1">
<li><span class="math inline">\(R\)</span> is reflexive iff <span class="math inline">\(\{(x, y) \in A \times A \mid x = y\} \subseteq R\)</span>.</li>
<li><span class="math inline">\(R\)</span> is symmetric iff <span class="math inline">\(R = R^{-1}\)</span>.</li>
<li><span class="math inline">\(R\)</span> is transitive iff <span class="math inline">\(R \circ R \subseteq R\)</span>.</li>
</ol>
</div>
<p>We can prove corresponding statements in Lean, but we’ll have to be careful to distinguish between the types <code>BinRel A</code> and <code>Set (A × A)</code>. In <em>HTPI</em>, each of the three statements in the theorem uses the same letter <span class="math inline">\(R\)</span> on both sides of the “iff”, but we can’t write the statements that way in Lean. In each statement, the part before “iff” uses a concept that was defined for objects of type <code>BinRel A</code>, whereas the part after “iff” uses concepts that only make sense for objects of type <code>Set (A × A)</code>. So we’ll have to rephrase the statements by using the correspondence between a relation of type <code>BinRel A</code> and its extension, which has type <code>Set (A × A)</code>. Here’s the Lean theorem corresponding to statement 2 of Theorem 4.3.4:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_3_4_2 {A : <span class="kw">Type</span>} (R : BinRel A) :</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    symmetric R ↔ extension R = inv (extension R) := <span class="kw">by</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : symmetric R</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h1             <span class="co">--h1 : ∀ (x y : A), R x y → R y x</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Set.ext</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> (a, b) : A × A</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> (a, b) ∈ extension R ↔ (a, b) ∈ inv (extension R) <span class="kw">from</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">calc</span> (a, b) ∈ extension R</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>        _ ↔ R a b := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>        _ ↔ R b a := Iff.intro (h1 a b) (h1 b a)</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>        _ ↔ (a, b) ∈ inv (extension R) := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h1 : extension R = inv (extension R)</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>                   <span class="co">--Goal : ∀ (x y : A), R x y → R y x</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> a : A; <span class="kw">fix</span> b : A</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : R a b        <span class="co">--Goal : R b a</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←ext_def R, h1, inv_def, ext_def] <span class="kw">at</span> h2</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> R b a <span class="kw">from</span> h2</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Note that near the end of the proof, we assume <code>h2 : R a b</code>, and our goal is <code>R b a</code>. We convert <code>R a b</code> to <code>R b a</code> by a sequence of rewrites. Applying the right-to-left direction of the theorem <code>ext_def R a b</code> converts <code>R a b</code> to <code>(a, b) ∈ extension R</code>. Then rewriting with <code>h1</code> converts this to <code>(a, b) ∈ inv (extension R)</code>, using <code>inv_def (extension R) b a</code> converts this to <code>(b, a) ∈ extension R</code>, and finally <code>ext_def R b a</code> produces <code>R b a</code>. Usually we can leave out the arguments when we use a theorem as a rewriting rule, and Lean will figure them out for itself. But in this case, if you try using <code>←ext_def</code> as the first rewriting rule, you will see that Lean is unable to figure out that it should use the right-to-left direction of <code>ext_def R a b</code>. Supplying the first argument turns out to be enough of a hint for Lean to figure out the rest. That’s why our first rewriting rule is <code>←ext_def R</code>.</p>
<p>We’ll leave the proofs of the other two statements in Theorem 4.3.4 as exercises for you.</p>
<p>For any types <code>A</code> and <code>B</code>, if we want to define a particular relation <code>R</code> from <code>A</code> to <code>B</code>, we can do it by specifying, for any <code>a : A</code> and <code>b : B</code>, what proposition is represented by <code>R a b</code>. For example, for any type <code>A</code>, we can define a relation <code>elementhood A</code> from <code>A</code> to <code>Set A</code> as follows:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> elementhood (A : <span class="kw">Type</span>) (a : A) (X : Set A) : <span class="kw">Prop</span> := a ∈ X</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This definition says that if <code>A</code> is a type, <code>a</code> has type <code>A</code>, and <code>X</code> has type <code>Set A</code>, then <code>elementhood A a X</code> is the proposition <code>a ∈ X</code>. Thus, if <code>elementhood A</code> is followed by objects of type <code>A</code> and <code>Set A</code>, the result is a proposition, so <code>elementhood A</code> is functioning as a relation from <code>A</code> to <code>Set A</code>. For example, <code>elementhood Int</code> is a relation from integers to sets of integers, and <code>elementhood Int 6 {n : Int | ∃ (k : Int), n = 2 * k}</code> is the (true) statement that <code>6</code> is an element of the set of even integers. (You are asked to prove it in the exercises.)</p>
<p>We can also use this method to define an operation that reverses the process of forming the extension of a relation. If <code>R</code> has type <code>Set (A × B)</code>, then we define <code>RelFromExt R</code> to be the relation whose extension is <code>R</code>. A few simple theorems, which follow directly from the definition, clarify the meaning of <code>RelFromExt R</code>.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> RelFromExt {A B : <span class="kw">Type</span>}</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    (R : Set (A × B)) (a : A) (b : B) : <span class="kw">Prop</span> := (a, b) ∈ R</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> RelFromExt_def {A B : <span class="kw">Type</span>}</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    (R : Set (A × B)) (a : A) (b : B) :</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    RelFromExt R a b ↔ (a, b) ∈ R := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {A B : <span class="kw">Type</span>} (R : Rel A B) :</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    RelFromExt (extension R) = R := <span class="kw">by</span> <span class="kw">rfl</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> {A B : <span class="kw">Type</span>} (R : Set (A × B)) :</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    extension (RelFromExt R) = R := <span class="kw">by</span> <span class="kw">rfl</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="exercises-1" class="level3">
<h3 class="anchored" data-anchor-id="exercises-1">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb20"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> :</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    elementhood Int 6 {n : Int | ∃ (k : Int), n = 2 * k} := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb21"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_3_4_1 {A : <span class="kw">Type</span>} (R : BinRel A) :</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    reflexive R ↔ {(x, y) : A × A | x = y} ⊆ extension R := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb22"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_3_4_3 {A : <span class="kw">Type</span>} (R : BinRel A) :</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    transitive R ↔</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>      comp (extension R) (extension R) ⊆ extension R := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb23"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_3_12a {A : <span class="kw">Type</span>} (R : BinRel A) (h1 : reflexive R) :</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    reflexive (RelFromExt (inv (extension R))) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb24"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_3_12c {A : <span class="kw">Type</span>} (R : BinRel A) (h1 : transitive R) :</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    transitive (RelFromExt (inv (extension R))) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="6">
<div class="sourceCode" id="cb25"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_3_18 {A : <span class="kw">Type</span>}</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    (R S : BinRel A) (h1 : transitive R) (h2 : transitive S)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    (h3 : comp (extension S) (extension R) ⊆</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>      comp (extension R) (extension S)) :</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    transitive (RelFromExt (comp (extension R) (extension S))) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="7">
<div class="sourceCode" id="cb26"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_3_20 {A : <span class="kw">Type</span>} (R : BinRel A) (S : BinRel (Set A))</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    (h : ∀ (X Y : Set A), S X Y ↔ X ≠ ∅ ∧ Y ≠ ∅ ∧</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    ∀ (x y : A), x ∈ X → y ∈ Y → R x y) :</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    transitive R → transitive S := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="mdsk">

</div>
<p>In the next three exercises, determine whether or not the theorem is correct.</p>
<div class="numex" data-arguments="8">
<div class="sourceCode" id="cb27"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">--You might not be able to complete this proof</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_3_13b {A : <span class="kw">Type</span>}</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    (R1 R2 : BinRel A) (h1 : symmetric R1) (h2 : symmetric R2) :</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    symmetric (RelFromExt ((extension R1) ∪ (extension R2))) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="9">
<div class="sourceCode" id="cb28"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">--You might not be able to complete this proof</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_3_13c {A : <span class="kw">Type</span>}</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    (R1 R2 : BinRel A) (h1 : transitive R1) (h2 : transitive R2) :</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    transitive (RelFromExt ((extension R1) ∪ (extension R2))) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="10">
<div class="sourceCode" id="cb29"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co">--You might not be able to complete this proof</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_3_19 {A : <span class="kw">Type</span>} (R : BinRel A) (S : BinRel (Set A))</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    (h : ∀ (X Y : Set A), S X Y ↔ ∃ (x y : A), x ∈ X ∧ y ∈ Y ∧ R x y) :</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    transitive R → transitive S := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="ordering-relations" class="level2">
<h2 class="anchored" data-anchor-id="ordering-relations">4.4. Ordering Relations</h2>
<p>Section 4.4 of <em>HTPI</em> begins by defining several new concepts about binary relations. Here are the definitions, written in Lean:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> antisymmetric {A : <span class="kw">Type</span>} (R : BinRel A) : <span class="kw">Prop</span> :=</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  ∀ (x y : A), R x y → R y x → x = y</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> partial_order {A : <span class="kw">Type</span>} (R : BinRel A) : <span class="kw">Prop</span> :=</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>  reflexive R ∧ transitive R ∧ antisymmetric R</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> total_order {A : <span class="kw">Type</span>} (R : BinRel A) : <span class="kw">Prop</span> :=</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>  partial_order R ∧ ∀ (x y : A), R x y ∨ R y x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>These definitions say that if <code>R</code> is a binary relation on <code>A</code>, then <code>R</code> is <em>antisymmetric</em> if <code>R x y</code> and <code>R y x</code> cannot both be true unless <code>x = y</code>. <code>R</code> is a <em>partial order on <code>A</code></em>—or just a <em>partial order</em>, if <code>A</code> is clear from context—if it is reflexive, transitive, and antisymmetric. And <code>R</code> is a <em>total order on <code>A</code></em> if it is a partial order and also, for any <code>x</code> and <code>y</code> of type <code>A</code>, either <code>R x y</code> or <code>R y x</code>. Note that, since Lean groups the connective <code>∧</code> to the right, <code>partial_order R</code> means <code>reflexive R ∧ (transitive R ∧ antisymmetric R)</code>, and therefore if <code>h</code> is a proof of <code>partial_order R</code>, then <code>h.left</code> is a proof of <code>reflexive R</code>, <code>h.right.left</code> is a proof of <code>transitive R</code>, and <code>h.right.right</code> is a proof of <code>antisymmetric R</code>.</p>
<p>Example 4.4.3 in <em>HTPI</em> gives several examples of partial orders and total orders. We’ll give one of those examples here. For any type <code>A</code>, we define <code>sub A</code> to be the subset relation on sets of objects of type <code>A</code>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sub (A : <span class="kw">Type</span>) (X Y : Set A) : <span class="kw">Prop</span> := X ⊆ Y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>According to this definition, <code>sub A</code> is a binary relation on <code>Set A</code>, and for any two sets <code>X</code> and <code>Y</code> of type <code>Set A</code>, <code>sub A X Y</code> is the proposition <code>X ⊆ Y</code>. We will leave it as an exercise for you to prove that <code>sub A</code> is a partial order on the type <code>Set A</code>.</p>
<p>Notice that <code>X ⊆ Y</code> could be thought of as expressing a sense in which <code>Y</code> is “at least as large as” <code>X</code>. Often, if <code>R</code> is a partial order on <code>A</code> and <code>a</code> and <code>b</code> have type <code>A</code>, then <code>R a b</code> can be thought of as meaning that <code>b</code> is in some sense “at least as large as” <code>a</code>. Many of the concepts we study for partial and total orders are motivated by this interpretation of <code>R</code>.</p>
<p>For example, if <code>R</code> is a partial order on <code>A</code>, <code>B</code> has type <code>Set A</code>, and <code>b</code> has type <code>A</code>, then we say that <code>b</code> is an <em><code>R</code>-smallest element</em> of <code>B</code> if it is an element of <code>B</code>, and every element of <code>B</code> is at least as large as <code>b</code>, according to this interpretation of the ordering <code>R</code>. We say that <code>b</code> is an <em><code>R</code>-minimal element</em> of <code>B</code> if it is an element of <code>B</code>, and there is no other element of <code>B</code> that is smaller than <code>b</code>, according to the ordering <code>R</code>. We can state these precisely as definitions in Lean:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> smallestElt {A : <span class="kw">Type</span>} (R : BinRel A) (b : A) (B : Set A) : <span class="kw">Prop</span> :=</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  b ∈ B ∧ ∀ x ∈ B, R b x</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minimalElt {A : <span class="kw">Type</span>} (R : BinRel A) (b : A) (B : Set A) : <span class="kw">Prop</span> :=</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>  b ∈ B ∧ ¬∃ x ∈ B, R x b ∧ x ≠ b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Notice that, as in <em>HTPI</em>, in Lean we can write <code>∀ x ∈ B, P x</code> as an abbreviation for <code>∀ (x : A), x ∈ B → P x</code>, and <code>∃ x ∈ B, P x</code> as an abbreviation for <code>∃ (x : A), x ∈ B ∧ P x</code>. According to these definitions, <code>smallestElt R b B</code> is the proposition that <code>b</code> is an <code>R</code>-smallest element of <code>B</code>, and <code>minimalElt R b B</code> means that <code>b</code> is an <code>R</code>-minimal element of <code>B</code>.</p>
<p>Theorem 4.4.6 in <em>HTPI</em> asserts three statements about these concepts. We’ll prove the second and third, and leave the first as an exercise for you. The first statement in Theorem 4.4.6 says that if <code>B</code> has an <code>R</code>-smallest element, then that <code>R</code>-smallest element is unique. Thus, we can talk about <em>the</em> <code>R</code>-smallest element of <code>B</code> rather than <em>an</em> <code>R</code>-smallest element. The second says that if <code>b</code> is the <code>R</code>-smallest element of <code>B</code>, then it is also an <code>R</code>-minimal element, and it is the only <code>R</code>-minimal element. Here is how you might start the proof. (Although Lean sometimes uses bounded quantifiers as abbreviations in the Infoview, we have written out the unabbreviated statements in the comments, to make the logic of some steps easier to follow.)</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_4_6_2 {A : <span class="kw">Type</span>} (R : BinRel A) (B : Set A) (b : A)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    (h1 : partial_order R) (h2 : smallestElt R b B) :</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    minimalElt R b B ∧ ∀ (c : A), minimalElt R c B → b = c := <span class="kw">by</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1     <span class="co">--h1 : reflexive R ∧ transitive R ∧ antisymmetric R</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2     <span class="co">--h2 : b ∈ B ∧ ∀ (x : A), x ∈ B → R b x</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that b is minimal</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>           <span class="co">--Goal : b ∈ B ∧ ¬∃ (x : A), x ∈ B ∧ R x b ∧ x ≠ b</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro h2.left</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">quant_neg</span>        <span class="co">--Goal : ∀ (x : A), ¬(x ∈ B ∧ R x b ∧ x ≠ b)</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">demorgan</span><span class="er"> : ¬(x ∈ B ∧ R x b ∧ x ≠ b)</span><span class="sc">::</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that b is only minimal element</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>    <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>When the goal is <code>∀ (x : A), ¬(x ∈ B ∧ R x b ∧ x ≠ b)</code>, it is tempting to apply the <code>demorgan</code> tactic to <code>¬(x ∈ B ∧ R x b ∧ x ≠ b)</code>, but unfortunately this generates an error in Lean: <code>unknown identifier 'x'</code>. The problem is that <code>x</code> is not defined in the tactic state, so without the quantifier <code>∀ (x : A)</code> in front of it, <code>¬(x ∈ B ∧ R x b ∧ x ≠ b)</code> doesn’t mean anything to Lean. The solution to the problem is to deal with the universal quantifier first by introducing an arbitrary <code>x</code> of type <code>A</code>. Once <code>x</code> has been introduced, we can apply the <code>demorgan</code> tactic.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_4_6_2 {A : <span class="kw">Type</span>} (R : BinRel A) (B : Set A) (b : A)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    (h1 : partial_order R) (h2 : smallestElt R b B) :</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    minimalElt R b B ∧ ∀ (c : A), minimalElt R c B → b = c := <span class="kw">by</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1     <span class="co">--h1 : reflexive R ∧ transitive R ∧ antisymmetric R</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2     <span class="co">--h2 : b ∈ B ∧ ∀ (x : A), x ∈ B → R b x</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that b is minimal</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>           <span class="co">--Goal : b ∈ B ∧ ¬∃ (x : A), x ∈ B ∧ R x b ∧ x ≠ b</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> And.intro h2.left</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">quant_neg</span>        <span class="co">--Goal : ∀ (x : A), ¬(x ∈ B ∧ R x b ∧ x ≠ b)</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> x : A</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">demorgan</span>         <span class="co">--Goal : ¬x ∈ B ∨ ¬(R x b ∧ x ≠ b)</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">or_right</span> <span class="kw">with</span> h3 <span class="co">--h3 : x ∈ B; Goal : ¬(R x b ∧ x ≠ b)</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">demorgan</span>         <span class="co">--Goal : ¬R x b ∨ x = b</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">or_right</span> <span class="kw">with</span> h4 <span class="co">--h4 : R x b; Goal : x = b</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h5 : R b x := h2.right x h3</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h6 : antisymmetric R := h1.right.right</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h6     <span class="co">--h6 : ∀ (x y : A), R x y → R y x → x = y</span></span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> x = b <span class="kw">from</span> h6 x b h4 h5</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Proof that b is only minimal element</span></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> c : A</span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h3 : minimalElt R c B</span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h3    <span class="co">--h3 : c ∈ B ∧ ¬∃ (x : A), x ∈ B ∧ R x c ∧ x ≠ c</span></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">contradict</span> h3.right <span class="kw">with</span> h4</span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a>                  <span class="co">--h4 : ¬b = c; Goal : ∃ (x : A), x ∈ B ∧ R x c ∧ x ≠ c</span></span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h5 : R b c := h2.right c h3.left</span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ∃ (x : A), x ∈ B ∧ R x c ∧ x ≠ c <span class="kw">from</span></span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a>      Exists.intro b (And.intro h2.left (And.intro h5 h4))</span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally, the third statement in Theorem 4.4.6 says that if <code>R</code> is a total order, then any <code>R</code>-minimal element of a set <code>B</code> must be the <code>R</code>-smallest element of <code>B</code>. The beginning of the proof is straightforward:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_4_6_3 {A : <span class="kw">Type</span>} (R : BinRel A) (B : Set A) (b : A)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    (h1 : total_order R) (h2 : minimalElt R b B) : smallestElt R b B := <span class="kw">by</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1         <span class="co">--h1 : partial_order R ∧ ∀ (x y : A), R x y ∨ R y x</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2         <span class="co">--h2 : b ∈ B ∧ ¬∃ (x : A), x ∈ B ∧ R x b ∧ x ≠ b</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>               <span class="co">--Goal : b ∈ B ∧ ∀ (x : A), x ∈ B → R b x</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro h2.left  <span class="co">--Goal : ∀ (x : A), x ∈ B → R b x</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : A</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : x ∈ B        <span class="co">--Goal : R b x</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>  <span class="sc">**</span><span class="wa">done</span><span class="sc">::</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Surprisingly, at this point it is difficult to find a way to reach the goal <code>R b x</code>. See <em>HTPI</em> for an explanation of why it turns out to be helpful to split the proof into two cases, depending on whether or not <code>x = b</code>. Of course, we use the <code>by_cases</code> tactic for this.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_4_6_3 {A : <span class="kw">Type</span>} (R : BinRel A) (B : Set A) (b : A)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    (h1 : total_order R) (h2 : minimalElt R b B) : smallestElt R b B := <span class="kw">by</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h1         <span class="co">--h1 : partial_order R ∧ ∀ (x y : A), R x y ∨ R y x</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2         <span class="co">--h2 : b ∈ B ∧ ¬∃ (x : A), x ∈ B ∧ R x b ∧ x ≠ b</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>               <span class="co">--Goal : b ∈ B ∧ ∀ (x : A), x ∈ B → R b x</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro h2.left  <span class="co">--Goal : ∀ (x : A), x ∈ B → R b x</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : A</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : x ∈ B        <span class="co">--Goal : R b x</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> h4 : x = b</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 1. h4 : x = b</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [h4]           <span class="co">--Goal : R b b</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h5 : partial_order R := h1.left</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h5</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h6 : reflexive R := h5.left</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h6</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> R b b <span class="kw">from</span> h6 b</span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- Case 2. h4 : x ≠ b</span></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h5 : ∀ (x y : A), R x y ∨ R y x := h1.right</span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h6 : R x b ∨ R b x := h5 x b</span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h7 : ¬R x b := <span class="kw">by</span></span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>      <span class="kw">contradict</span> h2.right <span class="kw">with</span> h8</span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> ∃ (x : A), x ∈ B ∧ R x b ∧ x ≠ b <span class="kw">from</span></span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a>        Exists.intro x (And.intro h3 (And.intro h8 h4))</span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">disj_syll</span> h6 h7</span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> R b x <span class="kw">from</span> h6</span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Imitating the definitions above, you should be able to formulate definitions of <code>R</code>-largest and <code>R</code>-maximal elements. Section 4.4 of <em>HTPI</em> defines four more terms: upper bound, lower bound, least upper bound, and greatest lower bound. We will discuss upper bounds and least upper bounds, and leave lower bounds and greatest lower bounds for you to figure out on your own.</p>
<p>If <code>R</code> is a partial order on <code>A</code>, <code>B</code> has type <code>Set A</code>, and <code>a</code> has type <code>A</code>, then <code>a</code> is called an <em>upper bound</em> for <code>B</code> if it is at least as large as every element of <code>B</code>. If it is the smallest element of the set of upper bounds, then it is called the <em>least upper bound</em> of <code>B</code>. The phrase “least upper bound” is often abbreviated “lub”. Here are these definitions, written in Lean:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> upperBd {A : <span class="kw">Type</span>} (R : BinRel A) (a : A) (B : Set A) : <span class="kw">Prop</span> :=</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  ∀ x ∈ B, R x a</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lub {A : <span class="kw">Type</span>} (R : BinRel A) (a : A) (B : Set A) : <span class="kw">Prop</span> :=</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>  smallestElt R a {c : A | upperBd R c B}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>As usual, we will let you consult <em>HTPI</em> for examples of these concepts. But we will mention one example: If <code>A</code> is a type and <code>F</code> has type <code>Set (Set A)</code>—that is, <code>F</code> is a set whose elements are sets of objects of type <code>A</code>—then the least upper bound of <code>F</code>, with respect to the partial order <code>sub A</code>, is <code>⋃₀ F</code>. We leave the proof of this fact as an exercise.</p>
<section id="exercises-2" class="level3">
<h3 class="anchored" data-anchor-id="exercises-2">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb38"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Example_4_4_3_1 {A : <span class="kw">Type</span>} : partial_order (sub A) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb39"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_4_6_1 {A : <span class="kw">Type</span>} (R : BinRel A) (B : Set A) (b : A)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    (h1 : partial_order R) (h2 : smallestElt R b B) :</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    ∀ (c : A), smallestElt R c B → b = c := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb40"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co">--If F is a set of sets, then ⋃₀ F is the lub of F in the subset ordering</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_4_11 {A : <span class="kw">Type</span>} (F : Set (Set A)) :</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    lub (sub A) (⋃₀ F) F := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb41"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_4_8 {A B : <span class="kw">Type</span>} (R : BinRel A) (S : BinRel B)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    (T : BinRel (A × B)) (h1 : partial_order R) (h2 : partial_order S)</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    (h3 : ∀ (a a' : A) (b b' : B),</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>      T (a, b) (a', b') ↔ R a a' ∧ S b b') :</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    partial_order T := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb42"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_4_9_part {A B : <span class="kw">Type</span>} (R : BinRel A) (S : BinRel B)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    (L : BinRel (A × B)) (h1 : total_order R) (h2 : total_order S)</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    (h3 : ∀ (a a' : A) (b b' : B),</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>      L (a, b) (a', b') ↔ R a a' ∧ (a = a' → S b b')) :</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    ∀ (a a' : A) (b b' : B),</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>      L (a, b) (a', b') ∨ L (a', b') (a, b) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="6">
<div class="sourceCode" id="cb43"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_4_15a {A : <span class="kw">Type</span>}</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    (R1 R2 : BinRel A) (B : Set A) (b : A)</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    (h1 : partial_order R1) (h2 : partial_order R2)</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    (h3 : extension R1 ⊆ extension R2) :</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    smallestElt R1 b B → smallestElt R2 b B := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="7">
<div class="sourceCode" id="cb44"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_4_15b {A : <span class="kw">Type</span>}</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    (R1 R2 : BinRel A) (B : Set A) (b : A)</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    (h1 : partial_order R1) (h2 : partial_order R2)</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    (h3 : extension R1 ⊆ extension R2) :</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    minimalElt R2 b B → minimalElt R1 b B := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="8">
<div class="sourceCode" id="cb45"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_4_18a {A : <span class="kw">Type</span>}</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>    (R : BinRel A) (B1 B2 : Set A) (h1 : partial_order R)</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>    (h2 : ∀ x ∈ B1, ∃ y ∈ B2, R x y) (h3 : ∀ x ∈ B2, ∃ y ∈ B1, R x y) :</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    ∀ (x : A), upperBd R x B1 ↔ upperBd R x B2 := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="9">
<div class="sourceCode" id="cb46"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_4_22 {A : <span class="kw">Type</span>}</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    (R : BinRel A) (B1 B2 : Set A) (x1 x2 : A)</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    (h1 : partial_order R) (h2 : lub R x1 B1) (h3 : lub R x2 B2) :</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>    B1 ⊆ B2 → R x1 x2 := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="10">
<div class="sourceCode" id="cb47"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_4_24 {A : <span class="kw">Type</span>} (R : Set (A × A)) :</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    smallestElt (sub (A × A)) (R ∪ (inv R))</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    {T : Set (A × A) | R ⊆ T ∧ symmetric (RelFromExt T)} := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="equivalence-relations" class="level2">
<h2 class="anchored" data-anchor-id="equivalence-relations">4.5. Equivalence Relations</h2>
<p>Chapter 4 of <em>HTPI</em> concludes with the study of one more important combination of properties that a relation might have. A binary relation <span class="math inline">\(R\)</span> on a set <span class="math inline">\(A\)</span> is called an <em>equivalence relation</em> if it is reflexive, symmetric, and transitive. If <span class="math inline">\(x \in A\)</span>, then the <em>equivalence class</em> of <span class="math inline">\(x\)</span> with respect to <span class="math inline">\(R\)</span> is the set of all <span class="math inline">\(y \in A\)</span> such that <span class="math inline">\(yRx\)</span>. In <em>HTPI</em>, this equivalence class is denoted <span class="math inline">\([x]_R\)</span>, so we have <span class="math display">\[
[x]_R = \{y \in A \mid yRx\}.
\]</span> The set whose elements are all of these equivalence classes is called <span class="math inline">\(A\)</span> <em>mod</em> <span class="math inline">\(R\)</span>. It is written <span class="math inline">\(A/R\)</span>, so <span class="math display">\[
A/R = \{[x]_R \mid x \in A\}.
\]</span> Note that <span class="math inline">\(A/R\)</span> is a set whose elements are sets: for each <span class="math inline">\(x \in A\)</span>, <span class="math inline">\([x]_R\)</span> is a subset of <span class="math inline">\(A\)</span>, and <span class="math inline">\([x]_R \in A/R\)</span>.</p>
<p>To define these concepts in Lean, we write:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> equiv_rel {A : <span class="kw">Type</span>} (R : BinRel A) : <span class="kw">Prop</span> :=</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>  reflexive R ∧ symmetric R ∧ transitive R</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> equivClass {A : <span class="kw">Type</span>} (R : BinRel A) (x : A) : Set A :=</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>  {y : A | R y x}</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mod (A : <span class="kw">Type</span>) (R : BinRel A) : Set (Set A) :=</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>  {equivClass R x | x : A}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Thus, <code>equiv_rel R</code> is the proposition that <code>R</code> is an equivalence relation, <code>equivClass R x</code> is the equivalence class of <code>x</code> with respect to <code>R</code>, and <code>mod A R</code> is <code>A</code> mod <code>R</code>. Note that <code>equivClass R x</code> has type <code>Set A</code>, while <code>mod A R</code> has type <code>Set (Set A)</code>. The definition of <code>mod A R</code> is shorthand for <code>{X : Set A | ∃ (x : A), equivClass R x = X}</code>.</p>
<p><em>HTPI</em> gives several examples of equivalence relations, and these examples illustrate that equivalence classes always have certain properties. The most important of these are that each equivalence class is a nonempty set, the equivalence classes do not overlap, and their union is all of <code>A</code>. We say that the equivalence classes form a <em>partition</em> of <code>A</code>. To state and prove these properties in Lean we will need some definitions. We start with these:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> empty {A : <span class="kw">Type</span>} (X : Set A) : <span class="kw">Prop</span> := ¬∃ (x : A), x ∈ X </span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pairwise_disjoint {A : <span class="kw">Type</span>} (F : Set (Set A)) : <span class="kw">Prop</span> :=</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>  ∀ X ∈ F, ∀ Y ∈ F, X ≠ Y → empty (X ∩ Y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To say that a set <code>X</code> is empty, we could write <code>X = ∅</code>, but it is more convenient to have a statement that says more explicitly what it means for a set to be empty. Thus, we have defined <code>empty X</code> to be the proposition saying that <code>X</code> has no elements. If <code>F</code> has type <code>Set (Set A)</code>, then <code>pairwise_disjoint F</code> is the proposition that no two distinct elements of <code>F</code> have any element in common—in other words, the elements of <code>F</code> do not overlap. We can now give the precise definition of a partition:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> partition {A : <span class="kw">Type</span>} (F : Set (Set A)) : <span class="kw">Prop</span> :=</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>  (∀ (x : A), x ∈ ⋃₀ F) ∧ pairwise_disjoint F ∧ ∀ X ∈ F, ¬empty X</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The main theorem about equivalence relations in <em>HTPI</em> is Theorem 4.5.4, which says that <code>mod A R</code> is a partition of <code>A</code>. The proof of this theorem is hard enough that <em>HTPI</em> proves two facts about equivalence classes first. A fact that is proven just for the purpose of using it to prove something else is often called a <em>lemma</em>. We can use this term in Lean as well. Here is the first part of Lemma 4.5.5 from <em>HTPI</em></p>
<div class="sourceCode" id="cb51"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_4_5_5_1 {A : <span class="kw">Type</span>} (R : BinRel A) (h : equiv_rel R) :</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    ∀ (x : A), x ∈ equivClass R x := <span class="kw">by</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : A</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>           <span class="co">--Goal : R x x</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h      <span class="co">--h : reflexive R ∧ symmetric R ∧ transitive R</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> Rref : reflexive R := h.left</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> R x x <span class="kw">from</span> Rref x</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The command <code>#check @Lemma_4_5_5_1</code> produces the result</p>
<div class="ind">
<pre><code>@Lemma_4_5_5_1 : ∀ {A : Type} (R : BinRel A),
                  equiv_rel R → ∀ (x : A), x ∈ equivClass R x</code></pre>
</div>
<p>Thus, if we have <code>R : BinRel A</code>, <code>h : equiv_rel R</code>, and <code>x : A</code>, then <code>Lemma_4_5_5_1 R h x</code> is a proof of <code>x ∈ equivClass R x</code>. We will use this at the end of the proof of our next lemma:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_4_5_5_2 {A : <span class="kw">Type</span>} (R : BinRel A) (h : equiv_rel R) :</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>    ∀ (x y : A), y ∈ equivClass R x ↔</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>      equivClass R y = equivClass R x := <span class="kw">by</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> Rsymm : symmetric R := h.right.left</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> Rtrans : transitive R := h.right.right</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : A; <span class="kw">fix</span> y : A</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 :</span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>      y ∈ equivClass R x    <span class="co">--Goal : equivClass R y = equivClass R x</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h2                        <span class="co">--h2 : R y x</span></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Set.ext</span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fix</span> z : A</span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">apply</span> Iff.intro</span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that z ∈ equivClass R y → z ∈ equivClass R x</span></span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">assume</span> h3 : z ∈ equivClass R y</span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span>                            <span class="co">--Goal : R z x</span></span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span> <span class="kw">at</span> h3                      <span class="co">--h3 : R z y</span></span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> R z x <span class="kw">from</span> Rtrans z y x h3 h2</span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true" tabindex="-1"></a>    · <span class="co">-- Proof that z ∈ equivClass R x → z ∈ equivClass R y</span></span>
<span id="cb53-22"><a href="#cb53-22" aria-hidden="true" tabindex="-1"></a>      <span class="kw">assume</span> h3 : z ∈ equivClass R x</span>
<span id="cb53-23"><a href="#cb53-23" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span>                            <span class="co">--Goal : R z y</span></span>
<span id="cb53-24"><a href="#cb53-24" aria-hidden="true" tabindex="-1"></a>      <span class="kw">define</span> <span class="kw">at</span> h3                      <span class="co">--h3 : R z x</span></span>
<span id="cb53-25"><a href="#cb53-25" aria-hidden="true" tabindex="-1"></a>      <span class="kw">have</span> h4 : R x y := Rsymm y x h2</span>
<span id="cb53-26"><a href="#cb53-26" aria-hidden="true" tabindex="-1"></a>      <span class="kw">show</span> R z y <span class="kw">from</span> Rtrans z x y h3 h4</span>
<span id="cb53-27"><a href="#cb53-27" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb53-28"><a href="#cb53-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb53-29"><a href="#cb53-29" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb53-30"><a href="#cb53-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 :</span>
<span id="cb53-31"><a href="#cb53-31" aria-hidden="true" tabindex="-1"></a>      equivClass R y = equivClass R x   <span class="co">--Goal : y ∈ equivClass R x</span></span>
<span id="cb53-32"><a href="#cb53-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←h2]                       <span class="co">--Goal : y ∈ equivClass R y</span></span>
<span id="cb53-33"><a href="#cb53-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> y ∈ equivClass R y <span class="kw">from</span> Lemma_4_5_5_1 R h y</span>
<span id="cb53-34"><a href="#cb53-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb53-35"><a href="#cb53-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The definition of “partition” has three parts, so to prove Theorem 4.5.4 we will have to prove three statements. It will make the proof easier to read if we prove the three statements separately.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Theorem_4_5_4_part_1 {A : <span class="kw">Type</span>} (R : BinRel A) (h : equiv_rel R) :</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>    ∀ (x : A), x ∈ ⋃₀ (mod A R) := <span class="kw">by</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> x : A</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>        <span class="co">--Goal : ∃ (t : Set A), t ∈ mod A R ∧ x ∈ t</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro (equivClass R x)</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro _ (Lemma_4_5_5_1 R h x)</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>                <span class="co">--Goal : equivClass R x ∈ mod A R</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>        <span class="co">--Goal : ∃ (x_1 : A), equivClass R x_1 = equivClass R x</span></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro x</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rfl</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Theorem_4_5_4_part_2 {A : <span class="kw">Type</span>} (R : BinRel A) (h : equiv_rel R) :</span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a>    pairwise_disjoint (mod A R) := <span class="kw">by</span></span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span></span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> X : Set A</span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : X ∈ mod A R</span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> Y : Set A</span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h3 : Y ∈ mod A R           <span class="co">--Goal : X ≠ Y → empty (X ∩ Y)</span></span>
<span id="cb54-20"><a href="#cb54-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2; <span class="kw">define</span> <span class="kw">at</span> h3</span>
<span id="cb54-21"><a href="#cb54-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (x : A) (h4 : equivClass R x = X) <span class="kw">from</span> h2</span>
<span id="cb54-22"><a href="#cb54-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (y : A) (h5 : equivClass R y = Y) <span class="kw">from</span> h3</span>
<span id="cb54-23"><a href="#cb54-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">contrapos</span></span>
<span id="cb54-24"><a href="#cb54-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h6 : ∃ (x : A), x ∈ X ∩ Y  <span class="co">--Goal : X = Y</span></span>
<span id="cb54-25"><a href="#cb54-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (z : A) (h7 : z ∈ X ∩ Y) <span class="kw">from</span> h6</span>
<span id="cb54-26"><a href="#cb54-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h7</span>
<span id="cb54-27"><a href="#cb54-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←h4, ←h5] <span class="kw">at</span> h7 <span class="co">--h7 : z ∈ equivClass R x ∧ z ∈ equivClass R y</span></span>
<span id="cb54-28"><a href="#cb54-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h8 : equivClass R z = equivClass R x :=</span>
<span id="cb54-29"><a href="#cb54-29" aria-hidden="true" tabindex="-1"></a>    (Lemma_4_5_5_2 R h x z).ltr h7.left</span>
<span id="cb54-30"><a href="#cb54-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">have</span> h9 : equivClass R z = equivClass R y :=</span>
<span id="cb54-31"><a href="#cb54-31" aria-hidden="true" tabindex="-1"></a>    (Lemma_4_5_5_2 R h y z).ltr h7.right</span>
<span id="cb54-32"><a href="#cb54-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> X = Y <span class="kw">from</span></span>
<span id="cb54-33"><a href="#cb54-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">calc</span> X</span>
<span id="cb54-34"><a href="#cb54-34" aria-hidden="true" tabindex="-1"></a>      _ = equivClass R x := h4.symm</span>
<span id="cb54-35"><a href="#cb54-35" aria-hidden="true" tabindex="-1"></a>      _ = equivClass R z := h8.symm</span>
<span id="cb54-36"><a href="#cb54-36" aria-hidden="true" tabindex="-1"></a>      _ = equivClass R y := h9</span>
<span id="cb54-37"><a href="#cb54-37" aria-hidden="true" tabindex="-1"></a>      _ = Y              := h5</span>
<span id="cb54-38"><a href="#cb54-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb54-39"><a href="#cb54-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-40"><a href="#cb54-40" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Theorem_4_5_4_part_3 {A : <span class="kw">Type</span>} (R : BinRel A) (h : equiv_rel R) :</span>
<span id="cb54-41"><a href="#cb54-41" aria-hidden="true" tabindex="-1"></a>    ∀ X ∈ mod A R, ¬empty X := <span class="kw">by</span></span>
<span id="cb54-42"><a href="#cb54-42" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> X : Set A</span>
<span id="cb54-43"><a href="#cb54-43" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assume</span> h2 : X ∈ mod A R  <span class="co">--Goal : ¬empty X</span></span>
<span id="cb54-44"><a href="#cb54-44" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span>; <span class="kw">double_neg</span>       <span class="co">--Goal : ∃ (x : A), x ∈ X</span></span>
<span id="cb54-45"><a href="#cb54-45" aria-hidden="true" tabindex="-1"></a>  <span class="kw">define</span> <span class="kw">at</span> h2             <span class="co">--h2 : ∃ (x : A), equivClass R x = X</span></span>
<span id="cb54-46"><a href="#cb54-46" aria-hidden="true" tabindex="-1"></a>  <span class="kw">obtain</span> (x : A) (h3 : equivClass R x = X) <span class="kw">from</span> h2</span>
<span id="cb54-47"><a href="#cb54-47" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> [←h3]</span>
<span id="cb54-48"><a href="#cb54-48" aria-hidden="true" tabindex="-1"></a>  <span class="kw">show</span> ∃ (x_1 : A), x_1 ∈ equivClass R x <span class="kw">from</span></span>
<span id="cb54-49"><a href="#cb54-49" aria-hidden="true" tabindex="-1"></a>    Exists.intro x (Lemma_4_5_5_1 R h x)</span>
<span id="cb54-50"><a href="#cb54-50" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It’s easy now to put everything together to prove Theorem 4.5.4.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_5_4 {A : <span class="kw">Type</span>} (R : BinRel A) (h : equiv_rel R) :</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>    partition (mod A R) := And.intro (Theorem_4_5_4_part_1 R h)</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>      (And.intro (Theorem_4_5_4_part_2 R h) (Theorem_4_5_4_part_3 R h))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Theorem 4.5.4 shows that an equivalence relation on <code>A</code> determines a partition of <code>A</code>, namely <code>mod A R</code>. Our next project will be to prove Theorem 4.5.6 in <em>HTPI</em>, which says that every partition of <code>A</code> arises in this way; that is, every partition is <code>mod A R</code> for some equivalence relation <code>R</code>. To prove this, we must show how to use a partition <code>F</code> to define an equivalence relation <code>R</code> for which <code>mod A R = F</code>. The proof in <em>HTPI</em> defines the required equivalence relation <code>R</code> as a set of ordered pairs, but in Lean we will need to define it instead as a binary relation on <code>A</code>. Translating <em>HTPI</em>’s set-theoretic definition into Lean’s notation for binary relations leads to the following definition:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> EqRelFromPart {A : <span class="kw">Type</span>} (F : Set (Set A)) (x y : A) : <span class="kw">Prop</span> :=</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>  ∃ X ∈ F, x ∈ X ∧ y ∈ X</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In other words, <code>EqRelFromPart F</code> is the binary relation on <code>A</code> that is true of any two objects <code>x</code> and <code>y</code> of type <code>A</code> if and only if <code>x</code> and <code>y</code> belong to the same set in <code>F</code>. Our plan now is to show that if <code>F</code> is a partition of <code>A</code>, then <code>EqRelFromPart F</code> is an equivalence relation on <code>A</code>, and <code>mod A (EqRelFromPart F) = F</code>.</p>
<p>Once again, <em>HTPI</em> breaks the proof up by proving some lemmas first, and we will find it convenient to break the proof into even smaller pieces. We will leave the proofs of most of these lemmas as exercises for you.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> overlap_implies_equal {A : <span class="kw">Type</span>}</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>    (F : Set (Set A)) (h : partition F) :</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>    ∀ X ∈ F, ∀ Y ∈ F, ∀ (x : A), x ∈ X → x ∈ Y → X = Y := <span class="cn">sorry</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_4_5_7_ref {A : <span class="kw">Type</span>} (F : Set (Set A)) (h : partition F):</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>    reflexive (EqRelFromPart F) := <span class="cn">sorry</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_4_5_7_symm {A : <span class="kw">Type</span>} (F : Set (Set A)) (h : partition F):</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>    symmetric (EqRelFromPart F) := <span class="cn">sorry</span></span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_4_5_7_trans {A : <span class="kw">Type</span>} (F : Set (Set A)) (h : partition F):</span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>    transitive (EqRelFromPart F) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We can now put these pieces together to prove Lemma 4.5.7 in <em>HTPI</em>:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_4_5_7 {A : <span class="kw">Type</span>} (F : Set (Set A)) (h : partition F) :</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    equiv_rel (EqRelFromPart F) := And.intro (Lemma_4_5_7_ref F h)</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>      (And.intro (Lemma_4_5_7_symm F h) (Lemma_4_5_7_trans F h))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We need one more lemma before we can prove Theorem 4.5.6:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_4_5_8 {A : <span class="kw">Type</span>} (F : Set (Set A)) (h : partition F) :</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>    ∀ X ∈ F, ∀ x ∈ X, equivClass (EqRelFromPart F) x = X := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We are finally now ready to address Theorem 4.5.6. Here is the statement of the theorem:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_5_6 {A : <span class="kw">Type</span>} (F : Set (Set A)) (h: partition F) :</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>    ∃ (R : BinRel A), equiv_rel R ∧ mod A R = F</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Of course, the relation <code>R</code> that we will use to prove the theorem is <code>EqRelFromPart F</code>, so we could start the proof with the tactic <code>apply Exists.intro (EqRelFromPart F)</code>. But this means that the rest of the proof will involve many statements about the relation <code>EqRelFromPart F</code>. When a complicated object appears multiple times in a proof, it can make the proof a little easier to read if we give that object a name. We can do that by using a new tactic. The tactic <code>set R : BinRel A := EqRelFromPart F</code> introduces the new variable <code>R</code> into the tactic state. The variable <code>R</code> has type <code>BinRel A</code>, and it is definitionally equal to <code>EqRelFromPart F</code>. That means that, when necessary, Lean will fill in this definition of <code>R</code>. For example, one of our first steps will be to apply <code>Lemma_4_5_7</code> to <code>F</code> and <code>h</code>. The conclusion of that lemma is <code>equiv_rel (EqRelFromPart F)</code>, but Lean will recognize this as meaning the same thing as <code>equiv_rel R</code>. Here is the proof of the theorem:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_5_6 {A : <span class="kw">Type</span>} (F : Set (Set A)) (h: partition F) :</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>    ∃ (R : BinRel A), equiv_rel R ∧ mod A R = F := <span class="kw">by</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> R : BinRel A := EqRelFromPart F</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Exists.intro R               <span class="co">--Goal : equiv_rel R ∧ mod A R = F</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> And.intro (Lemma_4_5_7 F h)  <span class="co">--Goal : mod A R = F</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Set.ext</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fix</span> X : Set A                      <span class="co">--Goal :  X ∈ mod A R ↔ X ∈ F</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">apply</span> Iff.intro</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (→)</span></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : X ∈ mod A R          <span class="co">--Goal : X ∈ F</span></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h2                     <span class="co">--h2 : ∃ (x : A), equivClass R x = X</span></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (x : A) (h3 : equivClass R x = X) <span class="kw">from</span> h2</span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : x ∈ ⋃₀ F := h.left x</span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h4</span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (Y : Set A) (h5 : Y ∈ F ∧ x ∈ Y) <span class="kw">from</span> h4</span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h6 : equivClass R x = Y :=</span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>      Lemma_4_5_8 F h Y h5.left x h5.right</span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">rewrite</span> [←h3, h6]</span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> Y ∈ F <span class="kw">from</span> h5.left</span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb61-21"><a href="#cb61-21" aria-hidden="true" tabindex="-1"></a>  · <span class="co">-- (←)</span></span>
<span id="cb61-22"><a href="#cb61-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assume</span> h2 : X ∈ F                <span class="co">--Goal : X ∈ mod A R</span></span>
<span id="cb61-23"><a href="#cb61-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h3 : ¬empty X := h.right.right X h2</span>
<span id="cb61-24"><a href="#cb61-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span> <span class="kw">at</span> h3; <span class="kw">double_neg</span> <span class="kw">at</span> h3   <span class="co">--h3 : ∃ (x : A), x ∈ X</span></span>
<span id="cb61-25"><a href="#cb61-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">obtain</span> (x : A) (h4 : x ∈ X) <span class="kw">from</span> h3</span>
<span id="cb61-26"><a href="#cb61-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">define</span>                       <span class="co">--Goal : ∃ (x : A), equivClass R x = X</span></span>
<span id="cb61-27"><a href="#cb61-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">show</span> ∃ (x : A), equivClass R x = X <span class="kw">from</span></span>
<span id="cb61-28"><a href="#cb61-28" aria-hidden="true" tabindex="-1"></a>      Exists.intro x (Lemma_4_5_8 F h X h2 x h4)</span>
<span id="cb61-29"><a href="#cb61-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span></span>
<span id="cb61-30"><a href="#cb61-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="exercises-3" class="level3">
<h3 class="anchored" data-anchor-id="exercises-3">Exercises</h3>
<div class="numex" data-arguments="1">
<div class="sourceCode" id="cb62"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> overlap_implies_equal {A : <span class="kw">Type</span>}</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>    (F : Set (Set A)) (h : partition F) :</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>    ∀ X ∈ F, ∀ Y ∈ F, ∀ (x : A), x ∈ X → x ∈ Y → X = Y := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="2">
<div class="sourceCode" id="cb63"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_4_5_7_ref {A : <span class="kw">Type</span>} (F : Set (Set A)) (h : partition F) :</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    reflexive (EqRelFromPart F) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="3">
<div class="sourceCode" id="cb64"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_4_5_7_symm {A : <span class="kw">Type</span>} (F : Set (Set A)) (h : partition F) :</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>    symmetric (EqRelFromPart F) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="4">
<div class="sourceCode" id="cb65"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_4_5_7_trans {A : <span class="kw">Type</span>} (F : Set (Set A)) (h : partition F) :</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    transitive (EqRelFromPart F) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="5">
<div class="sourceCode" id="cb66"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> Lemma_4_5_8 {A : <span class="kw">Type</span>} (F : Set (Set A)) (h : partition F) :</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>    ∀ X ∈ F, ∀ x ∈ X, equivClass (EqRelFromPart F) x = X := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="6">
<div class="sourceCode" id="cb67"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lemma</span> elt_mod_equiv_class_of_elt</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>    {A : <span class="kw">Type</span>} (R : BinRel A) (h : equiv_rel R) :</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>    ∀ X ∈ mod A R, ∀ x ∈ X, equivClass R x = X := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="mdsk">

</div>
<p>The next three exercises use the following definitions:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dot {A : <span class="kw">Type</span>} (F G : Set (Set A)) : Set (Set A) :=</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>  {Z : Set A | ¬empty Z ∧ ∃ X ∈ F, ∃ Y ∈ G, Z = X ∩ Y}</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> conj {A : <span class="kw">Type</span>} (R S : BinRel A) (x y : A) : <span class="kw">Prop</span> :=</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>  R x y ∧ S x y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="numex" data-arguments="7">
<div class="sourceCode" id="cb69"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_5_20a {A : <span class="kw">Type</span>} (R S : BinRel A)</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>    (h1 : equiv_rel R) (h2 : equiv_rel S) :</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>    equiv_rel (conj R S) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="8">
<div class="sourceCode" id="cb70"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_5_20b {A : <span class="kw">Type</span>} (R S : BinRel A)</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>    (h1 : equiv_rel R) (h2 : equiv_rel S) :</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>    ∀ (x : A), equivClass (conj R S) x =</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>      equivClass R x ∩ equivClass S x := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="numex" data-arguments="9">
<div class="sourceCode" id="cb71"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Exercise_4_5_20c {A : <span class="kw">Type</span>} (R S : BinRel A)</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>    (h1 : equiv_rel R) (h2 : equiv_rel S) :</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>    mod A (conj R S) = dot (mod A R) (mod A S) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="mdsk">

</div>
<p>The next exercise uses the following definition:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> equiv_mod (m x y : Int) : <span class="kw">Prop</span> := m ∣ (x - y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="numex" data-arguments="10">
<div class="sourceCode" id="cb73"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">theorem</span> Theorem_4_5_10 : ∀ (m : Int), equiv_rel (equiv_mod m) := <span class="cn">sorry</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Chap3.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Proofs</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./Chap5.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Functions</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
      <div class="nav-footer-center">© 2023-2025 Daniel J. Velleman.<br>Short excerpts from Daniel J. Velleman, <a href="https://doi.org/10.1017/9781108539890"><i>How To Prove It: A Structured Approach, 3rd Edition</i></a><br>© Daniel J. Velleman 2019, published by Cambridge University Press, reprinted with permission.</div>
  </div>
</footer>



</body></html>